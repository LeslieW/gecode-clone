/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Patrick Pekczynski <pekczynski@ps.uni-sb.de>
 *
 *  Copyright:
 *     Patrick Pekczynski, 2006
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  Permission is hereby granted, free of charge, to any person obtaining
 *  a copy of this software and associated documentation files (the
 *  "Software"), to deal in the Software without restriction, including
 *  without limitation the rights to use, copy, modify, merge, publish,
 *  distribute, sublicense, and/or sell copies of the Software, and to
 *  permit persons to whom the Software is furnished to do so, subject to
 *  the following conditions:
 *
 *  The above copyright notice and this permission notice shall be
 *  included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

namespace Gecode { namespace CpltSet {

  forceinline void 
  CpltSetVarImp::printdom(void) const {
    manager.print_set(domain);
  }

  forceinline unsigned int 
  CpltSetVarImp::tableWidth(void) const { return max - min + 1; }

  forceinline bdd
  CpltSetVarImp::element(int i) const { 
    return manager.bddpos(_offset + i); 
  }

  forceinline bdd
  CpltSetVarImp::elementNeg(int i) const {
    return manager.negbddpos(_offset + i);
  }

  forceinline
  CpltSetVarImp::CpltSetVarImp(Space* home, 
                               int glbMin, int glbMax, int lubMin, int lubMax,
                               unsigned int cardMin, unsigned int cardMax) 
    : CpltSetVarImpBase(home), domain(bdd_true()), 
      min(lubMin), max(lubMax), _assigned(false) {

    IntSet glb(glbMin, glbMax);
    IntSet lub(lubMin, lubMax);
    testConsistency(glb, lub, cardMin, cardMax, "CpltSetVarImp");

    _offset = manager.allocate(tableWidth());

    for (int i = glbMax; i >= glbMin; i--) {
      domain &= element(i - min);
    } 

    unsigned int range = tableWidth();
    domain &= cardcheck(range, _offset,
                        static_cast<int> (cardMin), 
                        static_cast<int> (cardMax));   

    assert(!manager.cfalse(domain));
  }

  forceinline
  CpltSetVarImp::CpltSetVarImp(Space* home,
                               int glbMin, int glbMax, const IntSet& lubD,
                               unsigned int cardMin, unsigned int cardMax) 
    : CpltSetVarImpBase(home), domain(bdd_true()), 
      min(lubD.min()), max(lubD.max()),
      _assigned(false) {

    IntSet glb(glbMin, glbMax);
    testConsistency(glb, lubD, cardMin, cardMax, "CpltSetVarImp");

    IntSetRanges lub(lubD);
    Iter::Ranges::ToValues<IntSetRanges> lval(lub);
    Iter::Ranges::ValCache<Iter::Ranges::ToValues<IntSetRanges> > vc(lval);

    _offset = manager.allocate(tableWidth());
    vc.last();
    
    int c = glbMax;
    for (int i = max; i >= min; i--) {
      if (i != vc.val()) {
        if (c >= glbMin && c == i) {
          throw CpltSet::GlbLubSpecNoSubset("CpltSetVarImp");
        }
        domain &= elementNeg(i - min);
      } else {
        if (c >= glbMin && c == i) {
          domain &= element(i - min);
          c--;
        }
        --vc;
      }
    }

    unsigned int range = tableWidth();
    domain &= cardcheck(range, _offset,
                        static_cast<int> (cardMin), 
                        static_cast<int> (cardMax));   

    assert(!manager.cfalse(domain));
  }

  forceinline
  CpltSetVarImp::CpltSetVarImp(Space* home,
                               const IntSet& glbD, int lubMin, int lubMax,
                               unsigned int cardMin, unsigned int cardMax) 
    : CpltSetVarImpBase(home), domain(bdd_true()), 
      min(lubMin), max(lubMax), _assigned(false) {

    IntSet lub(lubMin, lubMax);
    testConsistency(glbD, lub, cardMin, cardMax, "CpltSetVarImp");

    IntSetRanges glb(glbD);
    Iter::Ranges::ToValues<IntSetRanges> gval(glb);
    Iter::Ranges::ValCache<Iter::Ranges::ToValues<IntSetRanges> > vc(gval);
    
    vc.last();
    _offset = manager.allocate(tableWidth());

    for (vc.last(); vc(); --vc) {
      domain &= element(vc.val() - min);
    } 

    unsigned int range = tableWidth();
    domain &= cardcheck(range, _offset,
                        static_cast<int> (cardMin), 
                        static_cast<int> (cardMax));

    assert(!manager.cfalse(domain));
  }

  forceinline
  CpltSetVarImp::CpltSetVarImp(Space* home,
                               const IntSet& glbD,const IntSet& lubD,
                               unsigned int cardMin, unsigned int cardMax) 
    : CpltSetVarImpBase(home), domain(bdd_true()), 
      min(lubD.min()), max(lubD.max()),
      _assigned(false) {

    testConsistency(glbD, lubD, cardMin, cardMax, "CpltSetVarImp");

    IntSetRanges glb(glbD);
    Iter::Ranges::ToValues<IntSetRanges> gval(glb);
    Iter::Ranges::ValCache<Iter::Ranges::ToValues<IntSetRanges> > 
      vcglb(gval);
    IntSetRanges lub(lubD);
    Iter::Ranges::ToValues<IntSetRanges> lval(lub);
    Iter::Ranges::ValCache<Iter::Ranges::ToValues<IntSetRanges> > 
      vclub(lval);
  
    _offset = manager.allocate(tableWidth());

    vcglb.last();
    vclub.last();
  
    for (int i = max; i >= min; i--) {
      if (i != vclub.val()) {
        if (vcglb() && vcglb.val() == i) {
          throw CpltSet::GlbLubSpecNoSubset("CpltSetVarImp");
        }
        domain &= elementNeg(i - min);
      } else {
        if (vcglb() && vcglb.val() == i) {
          domain &= element(i - min);
        }
        --vclub;
      }
    }

    unsigned int range = tableWidth();
    domain &= cardcheck(range, _offset,
                        static_cast<int> (cardMin), 
                        static_cast<int> (cardMax));   

    assert(!manager.cfalse(domain));
  }

  forceinline bdd 
  CpltSetVarImp::dom(void) const {
    return domain;
  }

  forceinline void 
  CpltSetVarImp::dispose(Space*) {
    manager.dispose(domain);
    // only variables with nodes in the table need to be disposed
    if (!(_offset == 0 && 
          min == Set::Limits::int_min &&
          max == Set::Limits::int_max)
        ) {
      manager.dispose(_offset, (int) tableWidth());
    }
  }

  // a variable is only assigned if all bdd variables representing
  // the elements of the set have either a constant false or a constant true
  forceinline bool
  CpltSetVarImp::assigned(void) {
    if (!_assigned) {
      // (C1) there is only one solution (i.e. only one path)
      bool cond1 = (unsigned int) manager.bddpath(domain) == 1;
      // (C2) the solution talks about all elements 
      //      (i.e. the number of nodes used for the bdd uses the bdd nodes
      //      of all elements for the CpltSetVar)
      bool cond2 = (unsigned int) manager.bddsize(domain) == tableWidth();
      _assigned = cond1 && cond2;
    } 
    return _assigned;
  }

  forceinline unsigned int
  CpltSetVarImp::offset(void) const { return _offset; }

  forceinline int
  CpltSetVarImp::initialLubMin(void) const { return min; }

  forceinline int
  CpltSetVarImp::initialLubMax(void) const { return max; }

  forceinline unsigned int 
  CpltSetVarImp::cardMin(void) const {
    if (manager.ctrue(domain)) { return 0; }
    bdd d = domain;
    int l = 0;
    int u = 0;
    getcardbounds(d, l, u);
    return l;
  }

  forceinline unsigned int 
  CpltSetVarImp::cardMax(void) const {
    if (manager.ctrue(domain)) { return tableWidth(); }
    bdd d = domain;
    int l = 0;
    int u = 0;
    getcardbounds(d, l, u);
    return u;
  }

  forceinline ModEvent 
  CpltSetVarImp::intersect(Space* home, bdd& d) {
    bool assigned_before = assigned();
    bdd olddom = domain;
    domain &= d;

    bool assigned_new = assigned();
    if (manager.cfalse(domain)) 
      return ME_CPLTSET_FAILED; 

    ModEvent me = ME_CPLTSET_NONE;
    if (assigned_new) {
      if (assigned_before) {
        me = ME_CPLTSET_NONE;
        return me;
      } else {
        me =  ME_CPLTSET_VAL;
      }
      Delta d;
      return notify(home, me, &d);
    } else {
      if (olddom != domain) {
        me = ME_CPLTSET_DOM;
        Delta d;
        return notify(home, me, &d);
      }
    }
    return me;
  }

  forceinline ModEvent 
  CpltSetVarImp::exclude(Space* home, int a, int b) {
    // values are already excluded
    if (a > max  || b < min) 
      return ME_CPLTSET_NONE;

    int mi = std::max(min, a);
    int ma = std::min(b, max);

    bdd notinlub  = bdd_true();
    // get the negated bdds for value i in [a..b]
    for (int i = ma; i >= mi; i--)         
      notinlub &= elementNeg(i - min);

    return intersect(home, notinlub);
  }

  forceinline ModEvent 
  CpltSetVarImp::exclude(Space* home, int v) {
    return exclude(home, v, v);
  }

  template <class I> 
  forceinline ModEvent 
  CpltSetVarImp::excludeI(Space* home, I& i) {
    // we can only exclude what intersects the min and max element of the variable
    Iter::Ranges::Singleton s(min, max);
    Iter::Ranges::Inter<Iter::Ranges::Singleton, I> inter(s, i);
  
    if (!inter()) 
      return ME_CPLTSET_NONE;
  
    bdd not_lub = bdd_true();
    Iter::Ranges::ToValues<
      Iter::Ranges::Inter<Iter::Ranges::Singleton, I>
      > val(inter);

    Iter::Ranges::ValCache<
      Iter::Ranges::ToValues<
      Iter::Ranges::Inter<Iter::Ranges::Singleton, I> >
      > cache(val);
  
    for (cache.last(); cache(); --cache) {
      int v = cache.min();
      not_lub &= elementNeg(v - min);
    }
    return intersect(home, not_lub);
  }

  forceinline ModEvent 
  CpltSetVarImp::include(Space* home, int a, int b) {
    if (a < min || b > max) 
      return ME_CPLTSET_FAILED;

    bdd in_glb  = bdd_true();
    for (int i = b; i >= a; i--)
      in_glb &= element(i - min);

    return intersect(home, in_glb);
  }

  forceinline ModEvent 
  CpltSetVarImp::include(Space* home, int v) { return include(home, v, v); }

  template <class I> 
  forceinline ModEvent 
  CpltSetVarImp::includeI(Space* home, I& i) {
    if (!i()) 
      return ME_CPLTSET_NONE;

    bdd in_glb  = bdd_true();
    Iter::Ranges::ToValues<I> val(i);
    Iter::Ranges::ValCache<Iter::Ranges::ToValues<I> > cache(val);

    for (cache.last(); cache(); --cache) {
      int v = cache.min();
      if (v < min || max < v) 
        return ME_CPLTSET_FAILED;
      in_glb &= element(v - min);
    }
    return intersect(home, in_glb);  
  }


  forceinline ModEvent
  CpltSetVarImp::nq(Space* home, int a, int b) {
    if (b < min || a > max) 
      return ME_CPLTSET_NONE;

    Iter::Ranges::Singleton m(a, b);
    bdd ass = !(iterToBdd(m));    
    return intersect(home, ass);
  }

  forceinline ModEvent
  CpltSetVarImp::nq(Space* home, int v) { return nq(home, v, v); }

  template <class I>
  forceinline ModEvent
  CpltSetVarImp::nqI(Space* home, I& i) {
    bdd ass = !(iterToBdd(i));
    return intersect(home, ass);
  }

  forceinline ModEvent
  CpltSetVarImp::eq(Space* home, int a, int b) {
    if (b < min || a > max) 
      return ME_CPLTSET_FAILED;

    Iter::Ranges::Singleton m(a, b);
    bdd ass = iterToBdd(m);
    return intersect(home, ass);
  }

  forceinline ModEvent
  CpltSetVarImp::eq(Space* home, int v) { return eq(home, v, v); }

  // gen _assigned needs a test in case
  // we try to build an _assigned
  // that is not allowed by the variable domain
  template <class I>
  forceinline ModEvent
  CpltSetVarImp::eqI(Space* home, I& i) {
    if (i()) {
      if (i.min() < min || i.min() > max) 
        return ME_CPLTSET_FAILED;
    }
    bdd ass = iterToBdd(i);
    return intersect(home, ass);
  }

  forceinline ModEvent 
  CpltSetVarImp::intersect(Space* home, int a, int b) {
    ModEvent me_left = exclude(home, Set::Limits::int_min, a - 1);

    if (me_failed(me_left) || me_left == ME_CPLTSET_VAL) 
      return me_left;

    ModEvent me_right = exclude(home, b + 1, Set::Limits::int_max);

    if (me_failed(me_right) || me_right == ME_CPLTSET_VAL) 
      return me_right;

    if (me_left > 0 || me_right > 0) 
      return ME_CPLTSET_DOM;

    return ME_CPLTSET_NONE;    
  }

  forceinline ModEvent 
  CpltSetVarImp::intersect(Space* home, int i) {
    return intersect(home, i, i);
  }

  template <class I> 
  forceinline ModEvent 
  CpltSetVarImp::intersectI(Space* home, I& i) {
    Iter::Ranges::Compl<Set::Limits::int_min, Set::Limits::int_max, I> 
      compI(i);
    return excludeI(home, compI); 
  }

  forceinline ModEvent 
  CpltSetVarImp::cardinality(Space* home, int l, int u) {
    unsigned int maxcard = tableWidth();
    // compute the cardinality formula
    bdd c = cardcheck(maxcard, _offset, l, u);
    return intersect(home, c);
  }

  forceinline ModEvent 
  CpltSetVarImp::cardMin(Space* home, unsigned int newMin) {
    return cardinality(home, newMin, tableWidth());
  }

  forceinline ModEvent 
  CpltSetVarImp::cardMax(Space* home, unsigned int newMax) {
    return cardinality(home, 0, newMax);
  }

  // given the empty iterator we should produce an 
  // _assigned for the empty set.
  template <class I>
  forceinline bdd
  CpltSetVarImp::iterToBdd(I& i) {

    Iter::Ranges::ToValues<I> vali(i);
    Iter::Ranges::ValCache<Iter::Ranges::ToValues<I> > vc(vali);

    bdd ass = bdd_true();
    // start at the end for backwards iteration
    vc.last();
    for (int v = max; v >= min; v--) {
      if (vc()) {
        if (vc.val() == v) {
          ass &= element(v - min);
          --vc;
        } else {
          ass &= elementNeg(v - min);
        }
      } else {
        ass &= elementNeg(v - min);
      }
    }

    return ass;
  }

  forceinline bool
  CpltSetVarImp::range(void) const { return manager.ctrue(domain); }

  /*
   * Copying a variable
   *
   */

  forceinline CpltSetVarImp*
  CpltSetVarImp::copy(Space* home, bool share) {
    return copied() ? static_cast<CpltSetVarImp*>(forward())
      : perform_copy(home,share);
  }

  /*
   * Subscribing to variables
   *
   */
  forceinline void
  CpltSetVarImp::subscribe(Space* home, Propagator* p, PropCond pc,
                           bool process) {
    CpltSetVarImpBase::subscribe(home,p,pc,assigned(), process);
  }

  forceinline void
  CpltSetVarImp::cancel(Space* home, Propagator* p, PropCond pc) {
    CpltSetVarImpBase::cancel(home,p,pc,assigned());
  }

  forceinline bool
  CpltSetVarImp::knownIn(int v) const {
    if (manager.ctrue(domain)) 
      return false;
    if (v<min || v>max)
      return false;
    bdd bv = manager.negbddpos(_offset+v-min);
    return (manager.cfalse(domain & bv));
  }

  forceinline bool
  CpltSetVarImp::knownOut(int v) const {
    if (manager.ctrue(domain)) 
      return false;
    if (v<min || v>max)
      return false;
    bdd bv = manager.bddpos(_offset+v-min);
    return (manager.cfalse(domain & bv));
  }

  /// Iterator for the values in the greatest lower bound of a bdd variable implementation
  template <> 
  class GlbValues<CpltSetVarImp*> : public DomBddIterator {
  private:
    int mi;
    int ma;
  public:
    /// \name Constructors and initialization
    //@{
    /// Default constructor
    GlbValues(void);
    /// Initialize with ranges for variable implementation \a x
    GlbValues(const CpltSetVarImp* x);
    /// Initialize with ranges for variable implementation \a x
    void init(const CpltSetVarImp* x);
    //@}
    /// \name Iteration control
    //@{
    /// Iterate to the next glb value
    void operator++(void);
    //@}    
    int val(void) const;
  };

  /// Iterator for the values in the least upper bound of a bdd variable implementation
  template <> 
  class LubValues<CpltSetVarImp*> : public DomBddIterator {
  private:
    int mi;
    int ma;
  public:
    /// \name Constructors and initialization
    //@{
    /// Default constructor
    LubValues(void);
    /// Initialize with ranges for variable implementation \a x
    LubValues(const CpltSetVarImp* x);
    /// Initialize with ranges for variable implementation \a x
    void init(const CpltSetVarImp* x);
    //@}
    /// \name Iteration control
    //@{
    /// Iterate to the next glb value
    void operator++(void);
    /// Check validity
    bool operator()(void) const;
    //@}    
    int val(void) const;
  };

  /// Iterator for the unknown values of a bdd variable implementation
  template <> 
  class UnknownValues<CpltSetVarImp*> : public DomBddIterator {
  private:
    int mi;
    int ma;
  public:
    /// \name Constructors and initialization
    //@{
    /// Default constructor
    UnknownValues(void);
    /// Initialize with ranges for variable implementation \a x
    UnknownValues(const CpltSetVarImp* x);
    /// Initialize with ranges for variable implementation \a x 
    UnknownValues(const CpltSetVarImp* x, bdd& remain);
    /// Initialize with ranges for variable implementation \a x
    void init(const CpltSetVarImp* x);
    /// Initialize with ranges for variable implementation \a x
    void init(const CpltSetVarImp* x, bdd& remain);
    //@}
    /// \name Iteration control
    //@{
    /// Iterate to the next glb value
    void operator++(void);
    //@}    
    int val(void) const;
  };

  /*
   * BddIterator
   *
   */

  forceinline
  BddIterator::BddIterator(void) {}

  forceinline
  BddIterator::BddIterator(const bdd& b) {
    init(b);
  }

  forceinline NodeStatus 
  BddIterator::status(void) const { return flag; }

  forceinline int 
  BddIterator::level(void) const { return _level; }

  forceinline bool
  BddIterator::empty(void) const { return (l == 0) && (r == n - 1); }

  forceinline bool
  BddIterator::operator()(void) const {
    bool valid = (!empty() || singleton );
    return valid;
  }

  forceinline int 
  BddIterator::label(void) const { 
    if (!operator()()) { 
      return -1; 
    } else {
      return manager.bddidx(cur); 
    }
  }

  forceinline int
  BddIterator::size(void) const { return n; }
  
  /*
   * DomBddIterator
   *
   */

  forceinline void
  DomBddIterator::init(const CpltSetVarImp* x, bdd& remain) {
    vector_level = 0;
    mi    = x->min;
    ma    = x->max;
    off   = x->_offset;

    bdd dom = x->dom();
    if (dom != remain)
      dom &= remain;
    
    BddIterator::init(dom);
    bdd_level   = BddIterator::label() - off;
  }

  forceinline void
  DomBddIterator::init(const CpltSetVarImp* x) {
    bdd dom = x->dom();
    init(x, dom);
  }

  forceinline   
  DomBddIterator::DomBddIterator(void) {}

  forceinline
  DomBddIterator::DomBddIterator(const CpltSetVarImp* x) {
    bdd dom = x->dom();
    DomBddIterator::init(x, dom);
  }

  forceinline
  DomBddIterator::DomBddIterator(const CpltSetVarImp* x, bdd& remain) {
    vector_level = 0;
    mi    = x->min;
    ma    = x->max;
    off   = x->_offset;
    bdd dom = x->dom();
    if (dom != remain) {
      dom &= remain;
    }
    BddIterator::init(dom);
    bdd_level = BddIterator::label() - off;
  }

  forceinline bool
  DomBddIterator::same(void) const { return bdd_level == vector_level; }

  forceinline bool
  DomBddIterator::operator()(void) const {
    return vector_level < (ma-mi+1);
  }

  forceinline void
  DomBddIterator::operator++(void) {
    if (same()) {
      BddIterator::operator++();
      bdd_level   = BddIterator::label() - off;
    } 
    vector_level++;
  }

  forceinline NodeStatus
  DomBddIterator::status(void) const{
    return same() ? BddIterator::status() : FIX_UNKNOWN;
  }

  forceinline int
  DomBddIterator::val(void) const {
    return same() ? mi + BddIterator::label() - off : mi + vector_level;
  }

  forceinline
  GlbValues<CpltSetVarImp*>::GlbValues(void) {}

  forceinline
  GlbValues<CpltSetVarImp*>::GlbValues(const CpltSetVarImp* x) 
    : mi(x->min), ma(x->max) {
    DomBddIterator::init(x);
    while (operator()() && status() != FIX_GLB) {
      DomBddIterator::operator++();
    }

  }

  forceinline void 
  GlbValues<CpltSetVarImp*>::init(const CpltSetVarImp* x) {
    mi = x->min;  
    ma = x->max;
    DomBddIterator::init(x);
    while (operator()() && status() != FIX_GLB) {
      DomBddIterator::operator++();
    }
  }

  forceinline void 
  GlbValues<CpltSetVarImp*>::operator++(void) {
    DomBddIterator::operator++();
    while (operator()() && status() != FIX_GLB) {
      DomBddIterator::operator++();
    }
  }

  forceinline int
  GlbValues<CpltSetVarImp*>::val(void) const {
    return DomBddIterator::val();
  }
  
  forceinline
  LubValues<CpltSetVarImp*>::LubValues(void) {}

  forceinline
  LubValues<CpltSetVarImp*>::LubValues(const CpltSetVarImp* x) 
    : mi(x->min), ma(x->max) {
    DomBddIterator::init(x);
    while (DomBddIterator::operator()() && status() == FIX_NOT_LUB) {
      DomBddIterator::operator++();
    }
  }

  forceinline void 
  LubValues<CpltSetVarImp*>::init(const CpltSetVarImp* x) {
    mi = x->min;  
    ma = x->max;

    DomBddIterator::init(x);
    while (DomBddIterator::operator()() && status() == FIX_NOT_LUB) {
      DomBddIterator::operator++();
    }
  }

  forceinline void 
  LubValues<CpltSetVarImp*>::operator++(void) {
    DomBddIterator::operator++();
    while (DomBddIterator::operator()() && status() == FIX_NOT_LUB) {
      DomBddIterator::operator++();
    }
  }

  forceinline bool
  LubValues<CpltSetVarImp*>::operator()(void) const {
    return DomBddIterator::operator()() && status() != FIX_NOT_LUB;
  }

  forceinline int
  LubValues<CpltSetVarImp*>::val(void) const {
    return DomBddIterator::val();
  }

  forceinline
  UnknownValues<CpltSetVarImp*>::UnknownValues(void) {
  }

  forceinline
  UnknownValues<CpltSetVarImp*>::UnknownValues(const CpltSetVarImp* x) 
    : mi(x->min), ma(x->max) {
    DomBddIterator::init(x);
    while (operator()() && 
           !(status() == FIX_UNKNOWN || status() == UNDET)) {
      DomBddIterator::operator++();
    }
  }

  forceinline void 
  UnknownValues<CpltSetVarImp*>::init(const CpltSetVarImp* x) {
    mi = x->min;  
    ma = x->max;

    DomBddIterator::init(x);
    while (operator()() && 
           !(status() == FIX_UNKNOWN || status() == UNDET)) {
      DomBddIterator::operator++();
    }
  }

  forceinline void 
  UnknownValues<CpltSetVarImp*>::operator++(void) {
    DomBddIterator::operator++();
    while (operator()() && 
           !(status() == FIX_UNKNOWN || status() == UNDET)) {
      DomBddIterator::operator++();
    }
  }

  forceinline int
  UnknownValues<CpltSetVarImp*>::val(void) const {
    return DomBddIterator::val();
  }
  
  forceinline int 
  CpltSetVarImp::lubMaxN(int n) const {
    if (manager.ctrue(domain)) 
      return initialLubMax() - n;

    GECODE_AUTOARRAY(NodeStatus, status, tableWidth());
    DomBddIterator iter(this);

    if (!iter()) 
      return MAX_OF_EMPTY;
    
    for (int i = 0; iter(); i++, ++iter) {
      status[i] = iter.status();     
    }
    int c = 0;
    for (int j = tableWidth() - 1; j--; ) {
      if (status[j] != FIX_NOT_LUB) {
        if (c == n) { 
          c = j; 
          break; 
        } 
        c++;
      }
    }
    return initialLubMax() - c;
  }

  forceinline unsigned int
  CpltSetVarImp::lubSize(void) const {
    if (manager.ctrue(domain)) 
      return tableWidth();
    
    BddIterator iter(domain);
    int out = 0;
    while (iter()) {
      if (iter.status() == FIX_NOT_LUB)
        out++;
      ++iter;
    }
    return tableWidth() - out;
  }

  forceinline int 
  CpltSetVarImp::glbMin(void) const {
    if (manager.ctrue(domain)) 
      return initialLubMin();

    BddIterator iter(domain);
    while (iter()) {
      if (iter.status() == FIX_GLB) {
        int idx = iter.label() - offset();
        return initialLubMin() + idx;
      } 
      ++iter;
    }
    return MIN_OF_EMPTY;
  }

  forceinline int 
  CpltSetVarImp::glbMax(void) const {
    if (manager.ctrue(domain)) 
      return initialLubMax();
  
    BddIterator iter(domain);
    int lastglb = -1;
    while (iter()) {
      if (iter.status() == FIX_GLB) {
        int idx = iter.label() - offset();
        lastglb = initialLubMin() + idx;
      } 
      ++iter;
    }
    return (lastglb == -1) ? MAX_OF_EMPTY : lastglb;
  }

  forceinline unsigned int
  CpltSetVarImp::glbSize(void) const {
    if (manager.ctrue(domain)) { return 0; }
    BddIterator iter(domain);
    int size = 0;
    while (iter()) {
      if (iter.status() == FIX_GLB) { size++; }
      ++iter;
    }
    return size;
  }

  forceinline int 
  CpltSetVarImp::unknownMin(void) const {
    if (manager.ctrue(domain)) { return initialLubMin(); } 
    BddIterator iter(domain);
    while (iter()) {
      NodeStatus status = iter.status();
      if (status == FIX_UNKNOWN || status == UNDET) {
        int idx = iter.label() - offset();
        return initialLubMin() + idx;
      } 
      ++iter;
    }
    return MIN_OF_EMPTY;
  }

  forceinline int 
  CpltSetVarImp::unknownMax(void) const {
    if (manager.ctrue(domain)) 
      return initialLubMax();

    BddIterator iter(domain);
    int lastunknown = -1;
    while (iter()) {
      NodeStatus status = iter.status();
      if (status == FIX_UNKNOWN || status == UNDET) {
        int idx = iter.label() - offset();
        lastunknown = initialLubMin() + idx;
      } 
      ++iter;
    }
    return (lastunknown == -1) ?  MAX_OF_EMPTY : lastunknown;
  }

  forceinline unsigned int
  CpltSetVarImp::unknownSize(void) const {
    int size = tableWidth();
    if (manager.ctrue(domain))
      return size;

    BddIterator iter(domain);
    while (iter()) {
      NodeStatus status = iter.status();
      if (status == FIX_GLB || status == FIX_NOT_LUB) { size--; }
      ++iter;
    }
    return size;
  }    
}

namespace Set {

  /** \brief Range iterator for greatest lower bound of CpltSet variable 
    * implementation */
  template <> 
  class GlbRanges<CpltSet::CpltSetVarImp*> 
    : public Iter::Values::ToRanges<CpltSet::GlbValues<CpltSet::CpltSetVarImp*> > {
  public:
    /// \name Constructors and initialization
    //@{
    /// Default constructor
    GlbRanges(void);
    /// Initialize with ranges for variable implementation \a x
    GlbRanges(const CpltSet::CpltSetVarImp* x);
    /// Initialize with ranges for variable implementation \a x
    void init(const CpltSet::CpltSetVarImp* x);
    //@}
  };

  forceinline
  GlbRanges<CpltSet::CpltSetVarImp*>::GlbRanges(void) {}

  forceinline
  GlbRanges<CpltSet::CpltSetVarImp*>::GlbRanges(const CpltSet::CpltSetVarImp* x) {
    CpltSet::GlbValues<CpltSet::CpltSetVarImp*> v(x);
    Iter::Values::ToRanges<CpltSet::GlbValues<CpltSet::CpltSetVarImp*> >::init(v);
  }

  forceinline void 
  GlbRanges<CpltSet::CpltSetVarImp*>::init(const CpltSet::CpltSetVarImp* x) {
    CpltSet::GlbValues<CpltSet::CpltSetVarImp*> v(x);
    Iter::Values::ToRanges<CpltSet::GlbValues<CpltSet::CpltSetVarImp*> >::init(v);
  }

  /** \brief Range iterator for least upper bound of CpltSet variable 
    * implementation */
  template <> 
  class LubRanges<CpltSet::CpltSetVarImp*> 
  : public 
    Iter::Values::ToRanges<CpltSet::LubValues<CpltSet::CpltSetVarImp*> > {
  public:
    /// \name Constructors and initialization
    //@{
    /// Default constructor
    LubRanges(void);
    /// Initialize with ranges for variable implementation \a x
    LubRanges(const CpltSet::CpltSetVarImp* x);
    /// Initialize with ranges for variable implementation \a x
    void init(const CpltSet::CpltSetVarImp* x);
    //@}
  };

  forceinline
  LubRanges<CpltSet::CpltSetVarImp*>::LubRanges(void) {}

  forceinline
  LubRanges<CpltSet::CpltSetVarImp*>::LubRanges(const CpltSet::CpltSetVarImp* x) {
    CpltSet::LubValues<CpltSet::CpltSetVarImp*> v(x);
    Iter::Values::ToRanges<CpltSet::LubValues<CpltSet::CpltSetVarImp*> >::init(v);
  }

  forceinline void 
  LubRanges<CpltSet::CpltSetVarImp*>::init(const CpltSet::CpltSetVarImp* x) {
    CpltSet::LubValues<CpltSet::CpltSetVarImp*> v(x);
    Iter::Values::ToRanges<CpltSet::LubValues<CpltSet::CpltSetVarImp*> >::init(v);
  }
  
  /// Range iterator for the unknown set of CpltSet variable implementation
  template <> 
  class UnknownRanges<CpltSet::CpltSetVarImp*> 
    : public Iter::Values::ToRanges<CpltSet::UnknownValues<CpltSet::CpltSetVarImp*> > {
  public:
    /// \name Constructors and initialization
    //@{
    /// Default constructor
    UnknownRanges(void);
    /// Initialize with ranges for variable implementation \a x
    UnknownRanges(const CpltSet::CpltSetVarImp* x);
    /// Initialize with ranges for variable implementation \a x
    void init(const CpltSet::CpltSetVarImp* x);
    //@}
  };

  forceinline
  UnknownRanges<CpltSet::CpltSetVarImp*>::UnknownRanges(void) {}

  forceinline
  UnknownRanges<CpltSet::CpltSetVarImp*>
  ::UnknownRanges(const CpltSet::CpltSetVarImp* x) {
    CpltSet::UnknownValues<CpltSet::CpltSetVarImp*> v(x);
    Iter::Values::ToRanges<CpltSet::UnknownValues<
      CpltSet::CpltSetVarImp*> >::init(v);
  }

  forceinline void 
  UnknownRanges<CpltSet::CpltSetVarImp*>
  ::init(const CpltSet::CpltSetVarImp* x) {
    CpltSet::UnknownValues<CpltSet::CpltSetVarImp*> v(x);
    Iter::Values::ToRanges<CpltSet::UnknownValues<
      CpltSet::CpltSetVarImp*> >::init(v);
  }

}

namespace CpltSet {

  forceinline int 
  CpltSetVarImp::lubMin(void) const {
    if (manager.ctrue(domain)) { return initialLubMin(); }
    Gecode::Set::LubRanges<CpltSetVarImp*> lub(this);
    return !lub() ? MIN_OF_EMPTY : lub.min();
  }

  forceinline int 
  CpltSetVarImp::lubMax(void) const {
    if (manager.ctrue(domain)) { return initialLubMax(); }
    Gecode::Set::LubRanges<CpltSetVarImp*> lub(this);
    if (!lub()) { return MAX_OF_EMPTY; }
    int maxlub = initialLubMax();
    while (lub()) {
      maxlub = lub.max();
      ++lub;
    }
    return maxlub;
  }

  forceinline int 
  CpltSetVarImp::lubMinN(int n) const {
    if (manager.ctrue(domain)) 
      return initialLubMin() + n; 

    Gecode::Set::LubRanges<CpltSetVarImp*> lub(this);

    if (!lub()) 
      return MIN_OF_EMPTY; 

    while (lub()) {
      if (n < (int) lub.width()) {
        return lub.min() + n;
      } else {
        n -= lub.width();
      }
      ++lub;
    }
    // what to return if n is greater than the number of possible values ?
    // we should throw an exception here
    return MIN_OF_EMPTY;
  }

  /*
   * Support for delta information
   *
   */
  forceinline ModEvent
  CpltSetVarImp::modevent(const Delta* d) {
    return d->modevent();
  }
  
}}

// STATISTICS: cpltset-var
