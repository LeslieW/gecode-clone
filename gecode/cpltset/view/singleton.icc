/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Guido Tack <tack@gecode.org>
 *
 *  Contributing authors:
 *     Christian Schulte <schulte@gecode.org>
 *
 *  Copyright:
 *     Guido Tack, 2004
 *     Christian Schulte, 2004
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  Permission is hereby granted, free of charge, to any person obtaining
 *  a copy of this software and associated documentation files (the
 *  "Software"), to deal in the Software without restriction, including
 *  without limitation the rights to use, copy, modify, merge, publish,
 *  distribute, sublicense, and/or sell copies of the Software, and to
 *  permit persons to whom the Software is furnished to do so, subject to
 *  the following conditions:
 *
 *  The above copyright notice and this permission notice shall be
 *  included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

namespace Gecode { 

  namespace CpltSet {

    // Unfortunately using an IntView as CpltSetView
    // requires us to allocate boolean bdd nodes in the manager
    // note that these nodes are NOT ordered
    forceinline
    SingletonCpltSetView::SingletonCpltSetView(void) {}

    forceinline
    SingletonCpltSetView::SingletonCpltSetView(BMI* manager, int a, int b, 
                                       const Int::IntView& i0)
      : DerivedViewBase<Int::IntView>(i0) {
      mgr     = manager;
      min     = a;
      max     = b;
      range   = max - min + 1;
      _offset = mgr->allocate(range);
      domain.init();
      domain  = BDDTOP;

      // exclude values not in dom(i0)     
      Int::ViewValues<Int::IntView> values(view);
      if (!values())
        throw CpltSet::VariableInvalidDomainSpec("SingletonCpltSetView");

      Iter::Ranges::ValCache<Int::ViewValues<Int::IntView> > vc(values);
      vc.last();
      
      for (int i = max; i >= min; i--) {
        if (vc()) {
          if (vc.val() != i) {
            domain &= getnegbdd(i - min);
          } else {
            --vc;
          }
        } else {
          domain &= getnegbdd(i - min);
        }
      }
      
      GecodeBdd card = cardcheck(mgr, range, _offset, 1, 1);
      domain &= card;
    }


    forceinline void
    SingletonCpltSetView::init(BMI* manager, int a, int b, const Int::IntView& i0) {
      view = i0;
      mgr     = manager;
      min     = a;
      max     = b;
      // range   = view.width();
      range   = max - min + 1;
      _offset = mgr->allocate(range);
      domain.init();
      domain  = BDDTOP;

      // exclude values not in dom(i0)     
      Int::ViewValues<Int::IntView> values(view);
      if (!values())
        throw CpltSet::VariableInvalidDomainSpec("SingletonCpltSetView");

      Iter::Ranges::ValCache<Int::ViewValues<Int::IntView> > vc(values);
      vc.last();
      
      for (int i = max; i >= min; i--) {
        if (vc()) {
          if (vc.val() != i) {
            domain &= getnegbdd(i - min);
          } else {
            --vc;
          }
        } else {
          domain &= getnegbdd(i - min);
        }
      }
      
      GecodeBdd card = cardcheck(mgr, range, _offset, 1, 1);
      domain &= card;
    }

    forceinline
    SingletonCpltSetView::~SingletonCpltSetView(void) {
      mgr->dispose(domain);
      mgr->dispose(_offset, (int) range);
    }

    forceinline PropCond
    SingletonCpltSetView::pc_bddtoint(PropCond pc) {
      switch(pc) {
      case PC_CPLTSET_DOM:
        return Int::PC_INT_DOM;
      case PC_CPLTSET_VAL:
        return Int::PC_INT_VAL;
      default:
        return Int::PC_INT_DOM;
      }
    }

    forceinline ModEvent
    SingletonCpltSetView::me_inttobdd(ModEvent me) {
      switch(me) {
      case Int::ME_INT_FAILED: 
        return ME_CPLTSET_FAILED;
      case Int::ME_INT_NONE: 
        return ME_CPLTSET_NONE;
      case Int::ME_INT_VAL: 
        return ME_CPLTSET_VAL;
      case Int::ME_INT_DOM: 
        return ME_CPLTSET_DOM;
      default:
        return ME_CPLTSET_DOM;
      }
    }

    /*
     * Domain Tests
     *
     */ 
    forceinline bool
    SingletonCpltSetView::assigned(void) const { return view.assigned(); }


    forceinline bool
    SingletonCpltSetView::contains(int n) const { 
      return view.assigned() ? (view.val()==n) : false; 
    }

    forceinline bool
    SingletonCpltSetView::notContains(int n) const { return !view.in(n); }

    /*
     * Variable information
     *
     */

    forceinline unsigned int
    SingletonCpltSetView::glbSize(void) const { return view.assigned() ? 1 : 0; }

    forceinline unsigned int
    SingletonCpltSetView::lubSize(void) const { return view.size(); }

    forceinline unsigned int
    SingletonCpltSetView::unknownSize(void) const { return lubSize() - glbSize(); }

    forceinline unsigned int
    SingletonCpltSetView::cardMin() const { return 1; }

    forceinline unsigned int
    SingletonCpltSetView::cardMax() const { return 1; }

    forceinline int
    SingletonCpltSetView::lubMin() const { return view.min(); }

    forceinline int
    SingletonCpltSetView::lubMax() const { return view.max(); }

    forceinline int
    SingletonCpltSetView::glbMin() const { 
      return view.assigned() ? view.val() : CpltSetVarImp::MIN_OF_EMPTY; 
    }

    forceinline int
    SingletonCpltSetView::glbMax() const { 
      return view.assigned() ? view.val() : CpltSetVarImp::MAX_OF_EMPTY; 
    }

    /*
     * Bdd information
     *
     */

    forceinline unsigned int
    SingletonCpltSetView::offset(void)  const { return _offset; }

    forceinline unsigned int
    SingletonCpltSetView::table_width(void)  const { return range; }

    forceinline GecodeBdd
    SingletonCpltSetView::getbdd(int i)  const { return mgr->bddpos(_offset + i); }

    forceinline GecodeBdd
    SingletonCpltSetView::getnegbdd(int i)  const { 
      return mgr->negbddpos(_offset + i); 
    }

    forceinline int
    SingletonCpltSetView::getlevel(int i) { return mgr->var2bdd(_offset + i); }
    
    forceinline int
    SingletonCpltSetView::getvar(int i) { return mgr->bdd2var(_offset + i); }

    forceinline void
    SingletonCpltSetView::dom_and(GecodeBdd& d) { d &= bdd_domain(); }
    
    forceinline void
    SingletonCpltSetView::dom_or(GecodeBdd& d) { d |= bdd_domain(); }
    
    forceinline BMI*
    SingletonCpltSetView::manager(void) const { return mgr; }
    
    forceinline int
    SingletonCpltSetView::mgr_min(void)  const { return min; }
    
    forceinline int
    SingletonCpltSetView::mgr_max(void)  const { return max; }

    forceinline int
    SingletonCpltSetView::valididx(int v)  const { 
      if (v < min || v > max) return -1 ;
      return offset() +v - min;
    }

    forceinline GecodeBdd 
    SingletonCpltSetView::bdd_domain(void) const { return domain; };

    forceinline ModEvent
    SingletonCpltSetView::cardinality(Space* home,unsigned int l, unsigned int u) {
      return u <=1 ? ME_CPLTSET_NONE : ME_CPLTSET_FAILED;
    }
    
    forceinline ModEvent
    SingletonCpltSetView::cardMin(Space* home,unsigned int c) {
      return c<=1 ? ME_CPLTSET_NONE : ME_CPLTSET_FAILED;
    }

    forceinline ModEvent
    SingletonCpltSetView::cardMax(Space* home,unsigned int c) {
      return c<1 ? ME_CPLTSET_FAILED : ME_CPLTSET_NONE;
    }

    forceinline ModEvent
    SingletonCpltSetView::include(Space* home,int c) { 
      return me_inttobdd(view.eq(home,c)); 
    }

    forceinline ModEvent
    SingletonCpltSetView::intersect(Space* home,int c) { 
      return me_inttobdd(view.eq(home,c)); 
    }

    forceinline ModEvent
    SingletonCpltSetView::intersect(Space* home,int i, int j) { 

      ModEvent me1 = me_inttobdd(view.gq(home,i));
      ModEvent me2 = me_inttobdd(view.lq(home,j));
      if (me_failed(me1) || me_failed(me2)) {
        domain = BDDBOT;
        return ME_CPLTSET_FAILED;
      }
      
      for (int r = max; r >= min; r--) {
        if (r <= i || j <= r) 
          domain &= getnegbdd(r - min);
      }
      
      switch (me1) {
      case ME_CPLTSET_NONE:
      case ME_CPLTSET_DOM:
        return me2;
      case ME_CPLTSET_VAL:
        return ME_CPLTSET_VAL;
      default:
        GECODE_NEVER;
        return ME_CPLTSET_VAL;
      }
    }

    forceinline ModEvent
    SingletonCpltSetView::exclude(Space* home,int c) { 
      domain &= getnegbdd(c - min);
      return me_inttobdd(view.nq(home,c)); 
    }

    forceinline ModEvent
    SingletonCpltSetView::include(Space* home, int j, int k) {
      return j==k ? me_inttobdd(view.eq(home,j)) : ME_CPLTSET_FAILED ;
    }

    forceinline ModEvent
    SingletonCpltSetView::exclude(Space* home, int j, int k) {

      ModEvent me1 = me_inttobdd(view.gr(home,j));
      ModEvent me2 = me_inttobdd(view.le(home,k));
      if (me_failed(me1) || me_failed(me2)) {
        domain = BDDBOT;
        return ME_CPLTSET_FAILED;
      }
      
      for (int i = k; i >= j; i--) {
        domain &= getnegbdd(i - min);
      }

      switch (me1) {
      case ME_CPLTSET_NONE:
      case ME_CPLTSET_DOM:
        return me2;
      case ME_CPLTSET_VAL:
        return ME_CPLTSET_VAL;
      default:
        GECODE_NEVER;
        return ME_CPLTSET_VAL;
      }
    }

    template <class I> ModEvent
    SingletonCpltSetView::excludeI(Space* home, I& iter) {
      Iter::Ranges::ValCache<I> vci(iter);
      for (vci.last(); vci(); --vci) {
        for (int i = vci.max(); i>= vci.min(); i--) {
          domain &= getnegbdd(i - min);
        }
      }
      vci.reset();
      return me_inttobdd(view.minus_r(home,vci));
    }

    template <class I> ModEvent
    SingletonCpltSetView::includeI(Space* home, I& iter) {
      if (!iter())
        return ME_CPLTSET_NONE;

      if (iter.min()!=iter.max())
        return ME_CPLTSET_FAILED;

      int val = iter.min();
      ++iter;
      if ( iter() )
        return ME_CPLTSET_FAILED;

      return me_inttobdd(view.eq(home, val));
    }

    template <class I> ModEvent
    SingletonCpltSetView::intersectI(Space* home, I& iter) {

      Iter::Ranges::ToValues<I> val(iter);
      Iter::Ranges::ValCache<Iter::Ranges::ToValues<I> > vc(val);

      for (int i = max; i >= min; i--) {
        if (vc()) {
          if (vc.val() != i) {
            domain &= getnegbdd(i - min);
          } else {
            --vc;
          }
        } else {
          domain &= getnegbdd(i - min);
        }
      }

      vc.reset();
      return me_inttobdd(view.inter_r(home, vc));
    }

    forceinline ModEvent
    SingletonCpltSetView::nq(Space* home, int a, int b) { 
      return exclude(home, a, b); 
    }

    template <class I>
    forceinline ModEvent
    SingletonCpltSetView::nqI(Space* home, I& i) { return excludeI(home, i); }

    forceinline ModEvent
    SingletonCpltSetView::eq(Space* home, int v) { return include(home, v); }
    
    forceinline ModEvent
    SingletonCpltSetView::eq(Space* home, int a, int b) { 
      return include(home, a, b); 
    }

    template <class I>
    forceinline ModEvent
    SingletonCpltSetView::eqI(Space* home, I& i) { return includeI(home, i); }

    forceinline ModEvent 
    SingletonCpltSetView::tell_formula(Space* home, GecodeBdd& d) {
      if (assigned()) {
        int v = view.val();
        for (int i = max; i >= min; i--) {
          if (i != v) {
            domain &= getnegbdd(i - min);
          } else {
            domain &= getbdd(i - min);
          }
        }
        return ME_CPLTSET_VAL;
      }
      d &= domain;
      if (mgr->cfalse(d)) 
        return ME_CPLTSET_FAILED;

      ModEvent me = Int::ME_INT_NONE;
      GecodeBdd conv = BDDTOP;
      conv_hull(mgr, d, conv);
      if (!mgr->ctrue(conv)) {
        BddIterator iter(mgr, conv);
        while (iter()) {
          if (iter.status() == FIX_NOT_LUB) {
            int idx = iter.label() - _offset;
            me = view.nq(home, min + idx);
            if (me_failed(me)) {
              break;
            }
          }
          if (iter.status() == FIX_GLB) {
            int idx = iter.label() - _offset;
            me = view.eq(home, min + idx);
            break;
          }
          ++iter;
        }
      }
      return me_inttobdd(me);
    }

    forceinline void
    SingletonCpltSetView::subscribe(Space* home, Propagator* p, PropCond pc,
                             bool process) {
      view.subscribe(home,p,pc_bddtoint(pc),process);
    }
    forceinline void
    SingletonCpltSetView::cancel(Space* home, Propagator* p, PropCond pc) {
      view.cancel(home, p,pc_bddtoint(pc));
    }

    forceinline ModEvent
    SingletonCpltSetView::pme(const Propagator* p) {     
      return me_inttobdd(Int::IntView::pme(p));
    }

    forceinline PropModEvent
    SingletonCpltSetView::pme(ModEvent me) { return CpltSetView::pme(me); }

    forceinline void
    SingletonCpltSetView::update(Space* home, bool share, SingletonCpltSetView& y) {
      view.update(home,share,y.view);
      mgr = y.mgr;
      min = y.min;
      max = y.max;
      range = y.range;
      _offset = y._offset;
      domain.init();
      domain = y.domain;
    }

    /*
     * Serialization
     *
     */
    forceinline Reflection::Arg*
    SingletonCpltSetView::spec(Space* home, Reflection::VarMap& m) {
      return view.spec(home, m);
    }
    forceinline Reflection::Type*
    SingletonCpltSetView::type(void) {
      return new Reflection::Type("CpltSet::SingletonCpltSetView");
    }

    /*
     * Iterators
     *
     */

  }
  namespace Set {
    /**
     * \brief %Range iterator for least upper bound of singleton set view
     * \ingroup TaskActorSetView
     */
    template <>
    class LubRanges<CpltSet::SingletonCpltSetView> : public Int::IntVarImpFwd {
    public:
      /// \name Constructors and initialization
      //@{
      /// Default constructor
      LubRanges(void);
      /// Initialize with ranges for view \a x
      LubRanges(const CpltSet::SingletonCpltSetView& x);
      /// Initialize with ranges for view \a x
      void init(const CpltSet::SingletonCpltSetView& x);
      //@}
    };

    forceinline
    LubRanges<CpltSet::SingletonCpltSetView>::LubRanges(void) {}

    forceinline
    LubRanges<CpltSet::SingletonCpltSetView>::LubRanges(const CpltSet::SingletonCpltSetView& s) :
      Int::IntVarImpFwd(s.base().variable()) {}

    forceinline void
    LubRanges<CpltSet::SingletonCpltSetView>::init(const CpltSet::SingletonCpltSetView& s) {
      Int::IntVarImpFwd::init(s.base().variable());
    }
  }
  namespace CpltSet {

    /**
     * \brief %Value iterator for least upper bound of singleton set view
     * \ingroup TaskActorSetView
     */
    template <>
    class LubValues<SingletonCpltSetView> : 
      public Iter::Ranges::ToValues<Set::LubRanges<SingletonCpltSetView> > {
    public:
      /// \name Constructors and initialization
      //@{
      /// Default constructor
      LubValues(void);
      /// Initialize with ranges for view \a x
      LubValues(const SingletonCpltSetView& x);
      /// Initialize with ranges for view \a x
      void init(const SingletonCpltSetView& x);
      //@}
    };

    forceinline
    LubValues<SingletonCpltSetView>::LubValues(void) {}

    forceinline
    LubValues<SingletonCpltSetView>::LubValues(const SingletonCpltSetView& s) {
      Set::LubRanges<SingletonCpltSetView> lub(s);
      Iter::Ranges::ToValues<Set::LubRanges<SingletonCpltSetView> >::init(lub);
    }

    forceinline void
    LubValues<SingletonCpltSetView>::init(const SingletonCpltSetView& s) {
      Set::LubRanges<SingletonCpltSetView> lub(s);
      Iter::Ranges::ToValues<Set::LubRanges<SingletonCpltSetView> >::init(lub);
    }
  }
  namespace Set {
    /**
     * \brief %Range iterator for greatest lower bound of singleton set view
     * \ingroup TaskActorSetView
     */
    template <>
    class GlbRanges<CpltSet::SingletonCpltSetView> {
    private:
      int  val;
      bool flag;
    public:
      /// \name Constructors and initialization
      //@{
      /// Default constructor
      GlbRanges(void);
      /// Initialize with ranges for view \a x
      GlbRanges(const CpltSet::SingletonCpltSetView& x);
      /// Initialize with ranges for view \a x
      void init(const CpltSet::SingletonCpltSetView& x);

      /// \name Iteration control
      //@{
      /// Test whether iterator is still at a range or done
      bool operator()(void) const;
      /// Move iterator to next range (if possible)
      void operator++(void);
      //@}

      /// \name Range access
      //@{
      /// Return smallest value of range
      int min(void) const;
      /// Return largest value of range
      int max(void) const;
      /// Return width of ranges (distance between minimum and maximum)
      unsigned int width(void) const;
      //@}
    };

    forceinline
    GlbRanges<CpltSet::SingletonCpltSetView>::GlbRanges(void) {}

    forceinline void
    GlbRanges<CpltSet::SingletonCpltSetView>::init(const CpltSet::SingletonCpltSetView& s) {
      if (s.base().assigned()) {
        val = s.base().val();
        flag = true;
      } else {
        val = 0;
        flag = false;
      }
    }

    forceinline
    GlbRanges<CpltSet::SingletonCpltSetView>::GlbRanges(const CpltSet::SingletonCpltSetView& s) {
      init(s);
    }

    forceinline bool
    GlbRanges<CpltSet::SingletonCpltSetView>::operator()(void) const { return flag; }

    forceinline void
    GlbRanges<CpltSet::SingletonCpltSetView>::operator++(void) { flag=false; }

    forceinline int
    GlbRanges<CpltSet::SingletonCpltSetView>::min(void) const { return val; }
    forceinline int
    GlbRanges<CpltSet::SingletonCpltSetView>::max(void) const { return val; }
    forceinline unsigned int
    GlbRanges<CpltSet::SingletonCpltSetView>::width(void) const { return 1; }

  }

  /*
   * Testing
   *
   */
  forceinline bool
  same(const CpltSet::SingletonCpltSetView& x, const CpltSet::SingletonCpltSetView& y) {
    return same(x.base(),y.base());
  }
  forceinline bool
  before(const CpltSet::SingletonCpltSetView& x, const CpltSet::SingletonCpltSetView& y) {
    return before(x.base(),y.base());
  }


}

// STATISTICS: bdd-var
