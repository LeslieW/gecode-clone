/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Patrick Pekczynski <pekczynski@ps.uni-sb.de>
 *
 *  Copyright:
 *     Patrick Pekczynski, 2006
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  Permission is hereby granted, free of charge, to any person obtaining
 *  a copy of this software and associated documentation files (the
 *  "Software"), to deal in the Software without restriction, including
 *  without limitation the rights to use, copy, modify, merge, publish,
 *  distribute, sublicense, and/or sell copies of the Software, and to
 *  permit persons to whom the Software is furnished to do so, subject to
 *  the following conditions:
 *
 *  The above copyright notice and this permission notice shall be
 *  included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include <cmath>
#include "gecode/limits.hh"
#include "gecode/int.hh"

namespace Gecode { 

  namespace CpltSet {

    /// Iterator for the values of a bdd variable implementation
    template <> 
    class DomValues<CpltSetVarImp*> {
    private:
      IntSet is;
      bool valid;
      GecodeBdd d;
      int o;
      int mi;
      int ma;
      int i;
      BMI* mgr;
      int range;
      int total;

    protected:
      bool assignment(IntSet& r, int& i);
    public:
      /// \name Constructors and initialization
      //@{
      /// Default constructor
      DomValues(void);
      /// Initialize with ranges for variable implementation \a x
      DomValues(const CpltSetVarImp* x);
      /// Initialize with ranges for variable implementation \a x
      void init(const CpltSetVarImp* x);
      //@}
      /// \name Iteration control
      //@{
      /// Test whether iterator has reachead a leaf of the bdd or not
      bool operator()(void) const;
      void operator++(void);
      //@}
      /// Set the domain \a d to be iterated to \f$ d \wedge remain\f$
      void dom_and(GecodeBdd& remain);   
      IntSet val(void) const;
    };

    inline  bool
    DomValues<CpltSetVarImp*>::assignment(IntSet& r, int& i) {
      // int value = i;
      GecodeBdd b = d;

      // \todo FIXME: REPLACE INTSET WITH DYNARRAY

      // //     std::cout << "assignment for i="<< i << "\n ";
      // //     int testv = value;
      // //     for (int z = 0 ; z < range; z++, testv >>= 1) {
      // //       std::cout << (testv & 1) << " ";
      // //     }
      // //     std::cout << "\n";

      // //     mgr->bdd2dot(b);
      // //     std::cout << "type.value=" << b.getNode()->type.value << "\n";
      // //     std::cout << "******* END START ASS DOT *****\n";

      //     IntSet out = IntSet::empty;

      //     // given an integer i, such that 0 <= i <= range
      //     // we can interpret i as a bitvector whose k-th bit
      //     // tells us whether element (mi + k) belongs to the set or not
      //     for (int z = 0 ; z < range; z++, value >>= 1) {
      //       if (mgr->cfalse(b)) {
      //         // std::cout << "NOT VALID\n";
      //         return false;
      //       }

      //       bool flag    = value & 1;
      //       // now finally respecting negative values d'oh
      //       int val = mi + z;
      //       bool outside = false;
      //       if (!mgr->leaf(b)) {
      //         // the assignment talks about a variable
      //         // which is not in the current reduced ROBDD
      //         if (mgr->bddidx(b) - o > (unsigned int) z) { 
      //           outside = true;
      //         }
      //       }
      //       if (! outside ) {
      //         if (flag) {
      //           IntSetRanges ir(r);
      //           // std::cout << "have " << r << " ";
      //           Iter::Ranges::Singleton s(val, val);
      //           Iter::Ranges::Union<IntSetRanges, Iter::Ranges::Singleton> a(ir, s);
  
      //           IntSet ur(a);
      //           // std::cout << " update to " << ur << "\n";
      //           r.update(false, ur);
      //           // std::cout << " gives us " <<  r << "\n";
      //           if (!mgr->leaf(b)) {
      //               b = mgr->iftrue(b);
      //               // std::cout << "branch true is \n" << b << "\n";
      //               // mgr->bdd2dot(b);
      // //               std::cout << "type.value=" << b.getNode()->type.value << "\n";
      // //               std::cout << "******* END BRANCH TRUE *****\n";
      //           }
      //         } else {
      //           if (!mgr->leaf(b)) {
      //             b = mgr->iffalse(b);
      // //             std::cout << "branch false is \n" << b << "\n";
      // //             mgr->bdd2dot(b);
      // //             std::cout << "type.value=" << b.getNode()->type.value << "\n";
      // //             std::cout << "******* END BRANCH FALSE *****\n";
      // //             std::cout << "test whether valid?";
      // //             std::cout << "leaf = " << mgr->leaf(b) << " top ?" << mgr->ctrue(b) << "\n";
            
      //           }
      //         }
      //       } else {
      //         if (flag) {
      //           IntSetRanges ir(out);
      //           Iter::Ranges::Singleton s(val, val);
      //           Iter::Ranges::Union<IntSetRanges, Iter::Ranges::Singleton> a(ir, s);
      //           IntSet ur(a);
      //           out.update(false, ur);
      //         }
      //       }
      //     }

      //     bool isvalid = mgr->ctrue(b);
      //     // std::cout << "VALID ? " << isvalid << "\n";
      //     if (isvalid) {
      //       IntSetRanges irout(out);
      //       IntSetRanges ir(r);
      //       Iter::Ranges::Union<IntSetRanges, IntSetRanges> a(ir, irout);
      //       IntSet ur(a);
      //       r.update(false, ur);
      //     }
      //     return isvalid;

      return true;
    }

    forceinline
    DomValues<CpltSetVarImp*>::DomValues(void) {}

    forceinline
    DomValues<CpltSetVarImp*>::DomValues(const CpltSetVarImp* x)
      : valid(false), d((x->bdd_domain())), o(x->_offset), 
        mi(x->min), ma(x->max), i(-1), mgr(x->mgr), 
        range(ma - mi + 1),
        total(static_cast<int> (std::pow(2.0, static_cast<double> (range)))) {
      // std::cerr << "DomValues(x): ";
      // std::cerr << x->min << " " << x->max << " ";
      // std::cerr << x->_offset << " " << x->table_width() << "\n";
      // int testtotal = static_cast<int> (std::pow(2.0, static_cast<double> (x->table_width())));
      // std::cerr << testtotal << "\n";
      operator++();
    }

    forceinline void 
    DomValues<CpltSetVarImp*>::init(const CpltSetVarImp* x) {
      valid = false;
      d = x->bdd_domain();
      o = x->_offset;
      mi = x->min;
      ma = x->max;
      i = -1;
      mgr = x->mgr;
      range = (ma - mi + 1);
      total = static_cast<int> (std::pow(2.0, static_cast<double> (range)));
      operator++();
    }

    forceinline bool
    DomValues<CpltSetVarImp*>::operator()(void) const{
      // std::cerr << "operator(): ";
      // std::cerr << i << " < " << total << "\n";
      return i < total;
    }

    forceinline void 
    DomValues<CpltSetVarImp*>::operator++(void) {
      // std::cerr << "operator++()\t";
      valid = false;
      is = IntSet::empty;
    
      while (!valid && operator()()) {
        // std::cerr << "!val-ass ";
        ++i;
        valid = assignment(is,i);
        if (!valid) {
          is = IntSet::empty;
        }
      }
      // std::cerr << "end op++\n";
    }

    forceinline IntSet
    DomValues<CpltSetVarImp*>::val(void)  const {
      return is;
    }

    /// Iterator for the values in the greatest lower bound of a bdd variable implementation
    template <> 
    class GlbValues<CpltSetVarImp*> : public DomBddIterator {
    private:
      int mi;
      int ma;
    public:
      /// \name Constructors and initialization
      //@{
      /// Default constructor
      GlbValues(void);
      /// Initialize with ranges for variable implementation \a x
      GlbValues(const CpltSetVarImp* x);
      /// Initialize with ranges for variable implementation \a x
      void init(const CpltSetVarImp* x);
      //@}
      /// \name Iteration control
      //@{
      /// Iterate to the next glb value
      void operator++(void);
      //@}    
      int val(void) const;
    };

    forceinline
    GlbValues<CpltSetVarImp*>::GlbValues(void) {}

    forceinline
    GlbValues<CpltSetVarImp*>::GlbValues(const CpltSetVarImp* x) 
      : mi(x->min), ma(x->max) {
      DomBddIterator::init(x);
      while (operator()() && status() != FIX_GLB) {
        DomBddIterator::operator++();
      }

    }

    forceinline void 
    GlbValues<CpltSetVarImp*>::init(const CpltSetVarImp* x) {
      mi = x->min;  
      ma = x->max;
      DomBddIterator::init(x);
      while (operator()() && status() != FIX_GLB) {
        DomBddIterator::operator++();
      }
    }

    forceinline void 
    GlbValues<CpltSetVarImp*>::operator++(void) {
      DomBddIterator::operator++();
      // std::cout << "increase further\n";
      while (operator()() && status() != FIX_GLB) {
        DomBddIterator::operator++();
      }
    }

    forceinline int
    GlbValues<CpltSetVarImp*>::val(void) const {
      //     return mi + DomBddIterator::getlevel();
      return DomBddIterator::val();
    }

  }
  namespace Set {
    template <> 
    class GlbRanges<CpltSet::CpltSetVarImp*> 
      : public Iter::Values::ToRanges<CpltSet::GlbValues<CpltSet::CpltSetVarImp*> > {
    public:
      /// \name Constructors and initialization
      //@{
      /// Default constructor
      GlbRanges(void);
      /// Initialize with ranges for variable implementation \a x
      GlbRanges(const CpltSet::CpltSetVarImp* x);
      /// Initialize with ranges for variable implementation \a x
      void init(const CpltSet::CpltSetVarImp* x);
      //@}
    };

    forceinline
    GlbRanges<CpltSet::CpltSetVarImp*>::GlbRanges(void) {}

    forceinline
    GlbRanges<CpltSet::CpltSetVarImp*>::GlbRanges(const CpltSet::CpltSetVarImp* x) {
      CpltSet::GlbValues<CpltSet::CpltSetVarImp*> v(x);
      Iter::Values::ToRanges<CpltSet::GlbValues<CpltSet::CpltSetVarImp*> >::init(v);
    }

    forceinline void 
    GlbRanges<CpltSet::CpltSetVarImp*>::init(const CpltSet::CpltSetVarImp* x) {
      CpltSet::GlbValues<CpltSet::CpltSetVarImp*> v(x);
      Iter::Values::ToRanges<CpltSet::GlbValues<CpltSet::CpltSetVarImp*> >::init(v);
    }

  }
  namespace CpltSet {

    /// Iterator for the values in the least upper bound of a bdd variable implementation
    template <> 
    class LubValues<CpltSetVarImp*> : public DomBddIterator {
    private:
      int mi;
      int ma;
    public:
      /// \name Constructors and initialization
      //@{
      /// Default constructor
      LubValues(void);
      /// Initialize with ranges for variable implementation \a x
      LubValues(const CpltSetVarImp* x);
      /// Initialize with ranges for variable implementation \a x
      void init(const CpltSetVarImp* x);
      //@}
      /// \name Iteration control
      //@{
      /// Iterate to the next glb value
      void operator++(void);
      /// Check validity
      bool operator()(void) const;
      //@}    
      int val(void) const;
    };

    forceinline
    LubValues<CpltSetVarImp*>::LubValues(void) {}

    forceinline
    LubValues<CpltSetVarImp*>::LubValues(const CpltSetVarImp* x) 
      : mi(x->min), ma(x->max) {
      DomBddIterator::init(x);
      while (DomBddIterator::operator()() && status() == FIX_NOT_LUB) {
        DomBddIterator::operator++();
      }
    }

    forceinline void 
    LubValues<CpltSetVarImp*>::init(const CpltSetVarImp* x) {
      mi = x->min;  
      ma = x->max;

      DomBddIterator::init(x);
      while (DomBddIterator::operator()() && status() == FIX_NOT_LUB) {
        DomBddIterator::operator++();
      }
    }

    forceinline void 
    LubValues<CpltSetVarImp*>::operator++(void) {
      DomBddIterator::operator++();
      // std::cout << "increase further\n";
      while (DomBddIterator::operator()() && status() == FIX_NOT_LUB) {
        DomBddIterator::operator++();
      }
    }

    forceinline bool
    LubValues<CpltSetVarImp*>::operator()(void) const {
      // std::cout << DomBddIterator::label() << ">>" << DomBddIterator::getlevel() << " ~ " << status() << "\n";
      return DomBddIterator::operator()() && status() != FIX_NOT_LUB;
    }

    forceinline int
    LubValues<CpltSetVarImp*>::val(void) const {
      return DomBddIterator::val();
      //     return mi + DomBddIterator::getlevel();
    }

  }
  namespace Set {

    template <> 
    class LubRanges<CpltSet::CpltSetVarImp*> 
      : public Iter::Values::ToRanges<CpltSet::LubValues<CpltSet::CpltSetVarImp*> > {
    public:
      /// \name Constructors and initialization
      //@{
      /// Default constructor
      LubRanges(void);
      /// Initialize with ranges for variable implementation \a x
      LubRanges(const CpltSet::CpltSetVarImp* x);
      /// Initialize with ranges for variable implementation \a x
      void init(const CpltSet::CpltSetVarImp* x);
      //@}
    };

    forceinline
    LubRanges<CpltSet::CpltSetVarImp*>::LubRanges(void) {}

    forceinline
    LubRanges<CpltSet::CpltSetVarImp*>::LubRanges(const CpltSet::CpltSetVarImp* x) {
      CpltSet::LubValues<CpltSet::CpltSetVarImp*> v(x);
      Iter::Values::ToRanges<CpltSet::LubValues<CpltSet::CpltSetVarImp*> >::init(v);
    }

    forceinline void 
    LubRanges<CpltSet::CpltSetVarImp*>::init(const CpltSet::CpltSetVarImp* x) {
      CpltSet::LubValues<CpltSet::CpltSetVarImp*> v(x);
      Iter::Values::ToRanges<CpltSet::LubValues<CpltSet::CpltSetVarImp*> >::init(v);
    }
  }
  namespace CpltSet {

    /// Iterator for the unknown values of a bdd variable implementation
    template <> 
    class UnknownValues<CpltSetVarImp*> : public DomBddIterator {
    private:
      int mi;
      int ma;
    public:
      /// \name Constructors and initialization
      //@{
      /// Default constructor
      UnknownValues(void);
      /// Initialize with ranges for variable implementation \a x
      UnknownValues(const CpltSetVarImp* x);
      /// Initialize with ranges for variable implementation \a x 
      UnknownValues(const CpltSetVarImp* x, GecodeBdd& remain);
      /// Initialize with ranges for variable implementation \a x
      void init(const CpltSetVarImp* x);
      /// Initialize with ranges for variable implementation \a x
      void init(const CpltSetVarImp* x, GecodeBdd& remain);
      //@}
      /// \name Iteration control
      //@{
      /// Iterate to the next glb value
      void operator++(void);
      //@}    
      int val(void) const;
    };

    forceinline
    UnknownValues<CpltSetVarImp*>::UnknownValues(void) {
      // std::cout << "UnknownValues<CpltSetVarImp*>(void)\n";
    }

    forceinline
    UnknownValues<CpltSetVarImp*>::UnknownValues(const CpltSetVarImp* x) 
      : mi(x->min), ma(x->max) {
      DomBddIterator::init(x);
      while (operator()() && 
             !(status() == FIX_UNKNOWN || status() == UNDET)) {
        DomBddIterator::operator++();
      }
    }

    forceinline void 
    UnknownValues<CpltSetVarImp*>::init(const CpltSetVarImp* x) {
      mi = x->min;  
      ma = x->max;

      DomBddIterator::init(x);
      while (operator()() && 
             !(status() == FIX_UNKNOWN || status() == UNDET)) {
        DomBddIterator::operator++();
      }
    }

    forceinline void 
    UnknownValues<CpltSetVarImp*>::operator++(void) {
      DomBddIterator::operator++();
      while (operator()() && 
             !(status() == FIX_UNKNOWN || status() == UNDET)) {
        DomBddIterator::operator++();
      }
    }

    forceinline int
    UnknownValues<CpltSetVarImp*>::val(void) const {
      // std::cout << "val = " << iter.val() << "\n";
      return DomBddIterator::val();
      //     return mi + DomBddIterator::getlevel();
    }
  }

  namespace Set {
    template <> 
    class UnknownRanges<CpltSet::CpltSetVarImp*> 
      : public Iter::Values::ToRanges<CpltSet::UnknownValues<CpltSet::CpltSetVarImp*> > {
    public:
      /// \name Constructors and initialization
      //@{
      /// Default constructor
      UnknownRanges(void);
      /// Initialize with ranges for variable implementation \a x
      UnknownRanges(const CpltSet::CpltSetVarImp* x);
      /// Initialize with ranges for variable implementation \a x
      void init(const CpltSet::CpltSetVarImp* x);
      //@}
    };

    forceinline
    UnknownRanges<CpltSet::CpltSetVarImp*>::UnknownRanges(void) {
      // std::cout << "UnknownRanges<CpltSetVarImp*>::UnknownRanges(void)\n";
    }

    forceinline
    UnknownRanges<CpltSet::CpltSetVarImp*>::UnknownRanges(const CpltSet::CpltSetVarImp* x) {
      // std::cout << "UnknownRanges<CpltSetVarImp*>::UnknownRanges(x)\n";
      CpltSet::UnknownValues<CpltSet::CpltSetVarImp*> v(x);
      Iter::Values::ToRanges<CpltSet::UnknownValues<CpltSet::CpltSetVarImp*> >::init(v);
      // std::cout << "END UnknownRanges<CpltSetVarImp*>::UnknownRanges(x)\n";
    }

    forceinline void 
    UnknownRanges<CpltSet::CpltSetVarImp*>::init(const CpltSet::CpltSetVarImp* x) {
      // std::cout << "UnknownRanges<CpltSetVarImp*>::init(x)\n";
      CpltSet::UnknownValues<CpltSet::CpltSetVarImp*> v(x);
      Iter::Values::ToRanges<CpltSet::UnknownValues<CpltSet::CpltSetVarImp*> >::init(v);
      // std::cout << "END UnknownRanges<CpltSetVarImp*>::init(x)\n";
    }
  }
  namespace CpltSet {

    forceinline void 
    CpltSetVarImp::printdom(void) const {
      // std::cout << "printdom: ";
      // mgr->print_set(bounds & remain);
      mgr->print_set(domain);
    }

    forceinline void 
    CpltSetVarImp::printall(void) const{
      //     if (mgr->ctrue(domain)) {
      //       std::cout << "P(|";
      //       std::cout << min;
      //       for (int i = min + 1; i <= max; i++) {
      //         std::cout <<","<< i;
      //       }
      //       std::cout << "|)";
      //     } 
      // std::cout << "print all \n";
      DomValues<CpltSetVarImp*> d(this);
      // std::cout << "domvalues are valid ? " << d() << "\n";
      while(d()) {
        IntSet is;
        is = d.val();
        std::cout << "{";
        IntSetRanges ir(is);
        if (ir()) {
          if (ir.min() == ir.max()) {
            std::cout << ir.min();
          } else {
            std::cout << ir.min()<<"#"<<ir.max();
          }
          ++ir;
        }
        while(ir()) {
          std::cout << ",";
          if (ir.min() == ir.max()) {
            std::cout << ir.min();
          } else {
            std::cout << ir.min()<<"#"<<ir.max();
          }
          ++ir;
        }
        std::cout << "}";
        ++d;
      }
    }

    forceinline
    CpltSetVarImp::CpltSetVarImp(Space* home, BMI* m) 
      : CpltSetVarImpBase(home), mgr(m), domain(BDDTOP),
        min(Limits::Int::int_min), max(Limits::Int::int_max), 
        _offset(0), assignment(false) {}

    // the problem with cudd at this position is
    // BDDTOP for cudd needs mgr->top()
    // mgr(m) before domain(BDDTOP) 
    // does not give the desired result

    forceinline
    CpltSetVarImp::CpltSetVarImp(Space* home, BMI* m, int a, int b)
      : CpltSetVarImpBase(home), mgr(m), domain(BDDTOP), min(a), max(b), 
        assignment(false) {
      _offset = mgr->allocate(table_width());
    }

    forceinline
    CpltSetVarImp::CpltSetVarImp(Space* home, BMI* m, 
                         int glbMin, int glbMax, int lubMin, int lubMax,
                         unsigned int cardMin, unsigned int cardMax) 
      : CpltSetVarImpBase(home), mgr(m), domain(BDDTOP), 
        min(lubMin), max(lubMax), assignment(false) {

      IntSet glb(glbMin, glbMax);
      IntSet lub(lubMin, lubMax);
      testConsistency(glb, lub, cardMin, cardMax, "CpltSetVarImp");

      _offset = mgr->allocate(table_width());

      for (int i = glbMax; i >= glbMin; i--) {
        domain &= getbdd(i - min);
      } 

      unsigned int range = table_width();
      domain &= cardcheck(mgr, range, _offset,
                          static_cast<int> (cardMin), 
                          static_cast<int> (cardMax));   

      assert(!mgr->cfalse(domain));
    }

    forceinline
    CpltSetVarImp::CpltSetVarImp(Space* home, BMI* m, 
                         int glbMin, int glbMax, const IntSet& lubD,
                         unsigned int cardMin, unsigned int cardMax) 
      : CpltSetVarImpBase(home), mgr(m), domain(BDDTOP), 
        min(lubD.min()), max(lubD.max()),
        assignment(false) {

      IntSet glb(glbMin, glbMax);
      testConsistency(glb, lubD, cardMin, cardMax, "CpltSetVarImp");

      IntSetRanges lub(lubD);
      Iter::Ranges::ToValues<IntSetRanges> lval(lub);
      Iter::Ranges::ValCache<Iter::Ranges::ToValues<IntSetRanges> > vc(lval);

      _offset = mgr->allocate(table_width());
      vc.last();
      
      int c = glbMax;
      for (int i = max; i >= min; i--) {
        if (i != vc.val()) {
          if (c >= glbMin && c == i) {
            throw CpltSet::GlbLubSpecNoSubset("CpltSetVarImp");
          }
          domain &= getnegbdd(i - min);
        } else {
          if (c >= glbMin && c == i) {
            domain &= getbdd(i - min);
            c--;
          }
          --vc;
        }
      }

      unsigned int range = table_width();
      domain &= cardcheck(mgr, range, _offset,
                          static_cast<int> (cardMin), 
                          static_cast<int> (cardMax));   

      assert(!mgr->cfalse(domain));
    }

    forceinline
    CpltSetVarImp::CpltSetVarImp(Space* home, BMI* m, 
                         const IntSet& glbD, int lubMin, int lubMax,
                         unsigned int cardMin, unsigned int cardMax) 
      : CpltSetVarImpBase(home), mgr(m), domain(BDDTOP), 
        min(lubMin), max(lubMax), assignment(false) {

      IntSet lub(lubMin, lubMax);
      testConsistency(glbD, lub, cardMin, cardMax, "CpltSetVarImp");

      IntSetRanges glb(glbD);
      Iter::Ranges::ToValues<IntSetRanges> gval(glb);
      Iter::Ranges::ValCache<Iter::Ranges::ToValues<IntSetRanges> > vc(gval);
      
      vc.last();
      _offset = mgr->allocate(table_width());

      for (vc.last(); vc(); --vc) {
        domain &= getbdd(vc.val() - min);
      } 

      unsigned int range = table_width();
      domain &= cardcheck(mgr, range, _offset,
                          static_cast<int> (cardMin), 
                          static_cast<int> (cardMax));

      assert(!mgr->cfalse(domain));
    }

    forceinline
    CpltSetVarImp::CpltSetVarImp(Space* home, BMI* m, 
                         const IntSet& glbD,const IntSet& lubD,
                         unsigned int cardMin, unsigned int cardMax) 
      : CpltSetVarImpBase(home), mgr(m), domain(BDDTOP), 
        min(lubD.min()), max(lubD.max()),
        assignment(false) {

      testConsistency(glbD, lubD, cardMin, cardMax, "CpltSetVarImp");

      IntSetRanges glb(glbD);
      Iter::Ranges::ToValues<IntSetRanges> gval(glb);
      Iter::Ranges::ValCache<Iter::Ranges::ToValues<IntSetRanges> > vcglb(gval);
      IntSetRanges lub(lubD);
      Iter::Ranges::ToValues<IntSetRanges> lval(lub);
      Iter::Ranges::ValCache<Iter::Ranges::ToValues<IntSetRanges> > vclub(lval);
    
      _offset = mgr->allocate(table_width());

      vcglb.last();
      vclub.last();
    
      for (int i = max; i >= min; i--) {
        if (i != vclub.val()) {
          if (vcglb() && vcglb.val() == i) {
            throw CpltSet::GlbLubSpecNoSubset("CpltSetVarImp");
          }
          domain &= getnegbdd(i - min);
        } else {
          if (vcglb() && vcglb.val() == i) {
            domain &= getbdd(i - min);
          }
          --vclub;
        }
      }

      unsigned int range = table_width();
      domain &= cardcheck(mgr, range, _offset,
                          static_cast<int> (cardMin), 
                          static_cast<int> (cardMax));   

      assert(!mgr->cfalse(domain));
    }

    forceinline void 
    CpltSetVarImp::init(Space* home, BMI* m, int a, int b) {
      // allocate (b - a + 1) indices in the manager
      mgr     = m;
      domain  = BDDTOP;
      min     = a;
      max     = b;
      assignment = false;
      _offset  = mgr->allocate(table_width());
      assert(mgr == m);
    }

    forceinline GecodeBdd 
    CpltSetVarImp::bdd_domain(void) const { return domain; };

    forceinline void 
    CpltSetVarImp::dispose(Space* home) {
      mgr->dispose(domain);
      // only variables with nodes in the table need to dipose them 
      if (!(_offset == 0 && 
            min == Limits::Int::int_min &&
            max == Limits::Int::int_max)
          ) {
        mgr->dispose(_offset, (int) table_width());
      }
    }

    // a variable is only assigned if all bdd variables representing
    // the elements of the set have either a constant false or a constant true
    forceinline bool
    CpltSetVarImp::assigned(void) {
      if (!assignment) {
        // (C1) there is only one solution (i.e. only one path)
        bool cond1 = (unsigned int) mgr->bddpath(domain) == 1;
        // (C2) the solution talks about all elements 
        //      (i.e. the number of nodes used for the bdd uses the bdd nodes
        //      of all elements for the CpltSetVar)
        bool cond2 = (unsigned int) mgr->bddsize(domain) == table_width();
        assignment = cond1 && cond2;
      } 
      return assignment;
    }

    forceinline unsigned int
    CpltSetVarImp::offset(void) const { return _offset; }

    forceinline GecodeBdd
    CpltSetVarImp::getbdd(int i) const { 
      // std::cout << "bdd var imp: " << _offset << "+" << i << "\n";
      return mgr->bddpos(_offset + i); 
    }

    forceinline GecodeBdd
    CpltSetVarImp::getnegbdd(int i) const { return mgr->negbddpos(_offset + i); }

    forceinline int
    CpltSetVarImp::getlevel(int i) { return mgr->var2bdd(_offset + i); }

    forceinline int
    CpltSetVarImp::getvar(int i) { return mgr->bdd2var(_offset + i); }

    forceinline int
    CpltSetVarImp::mgr_min(void) const { return min; }

    forceinline int
    CpltSetVarImp::mgr_max(void) const { return max; }
  
    forceinline void
    CpltSetVarImp::dom_and(GecodeBdd& d) { d &= domain; }

    forceinline void
    CpltSetVarImp::dom_or(GecodeBdd& d) { d |= domain; }

    forceinline unsigned int 
    CpltSetVarImp::table_width(void) const { return max - min + 1; }

    forceinline BMI*
    CpltSetVarImp::manager(void) const { return mgr; }

    forceinline unsigned int 
    CpltSetVarImp::cardMin(void) const {
      if (mgr->ctrue(domain)) { return 0; }
      GecodeBdd d = domain;
      int l = 0;
      int u = 0;
      getcardbounds(mgr, d, l, u);
      return l;
    }

    forceinline unsigned int 
    CpltSetVarImp::cardMax(void) const {
      if (mgr->ctrue(domain)) { return table_width(); }
      GecodeBdd d = domain;
      int l = 0;
      int u = 0;
      getcardbounds(mgr, d, l, u);
      return u;
    }

    forceinline int 
    CpltSetVarImp::lubMin(void) const {
      if (mgr->ctrue(domain)) { return mgr_min(); }
      Gecode::Set::LubRanges<CpltSetVarImp*> lub(this);
      return !lub() ? MIN_OF_EMPTY : lub.min();
    }

    forceinline int 
    CpltSetVarImp::lubMax(void) const {
      if (mgr->ctrue(domain)) { return mgr_max(); }
      Gecode::Set::LubRanges<CpltSetVarImp*> lub(this);
      if (!lub()) { return MAX_OF_EMPTY; }
      int maxlub = mgr_max();
      while (lub()) {
        maxlub = lub.max();
        ++lub;
      }
      return maxlub;
    }

    forceinline int 
    CpltSetVarImp::lubMinN(int n) const {
      if (mgr->ctrue(domain)) 
        return mgr_min() + n; 

      Gecode::Set::LubRanges<CpltSetVarImp*> lub(this);

      if (!lub()) 
        return MIN_OF_EMPTY; 

      while (lub()) {
        if (n < (int) lub.width()) {
          return lub.min() + n;
        } else {
          n -= lub.width();
        }
        ++lub;
      }
      // what to return if n is greater than the number of possible values ?
      // we should throw an exception here
      return MIN_OF_EMPTY;
    }

    forceinline int 
    CpltSetVarImp::lubMaxN(int n) const {
      if (mgr->ctrue(domain)) 
        return mgr_max() - n;

      GECODE_AUTOARRAY(NodeStatus, status, table_width());
      DomBddIterator iter(this);

      if (!iter()) 
        return MAX_OF_EMPTY;
      
      for (int i = 0; iter(); i++, ++iter) {
        status[i] = iter.status();     
      }
      int c = 0;
      for (int j = table_width() - 1; j--; ) {
        if (status[j] != FIX_NOT_LUB) {
          if (c == n) { 
            c = j; 
            break; 
          } 
          c++;
        }
      }
      return mgr_max() - c;
    }

    forceinline unsigned int
    CpltSetVarImp::lubSize(void) const {
      if (mgr->ctrue(domain)) 
        return table_width();
      
      BddIterator iter(mgr, domain);
      int out = 0;
      while (iter()) {
        if (iter.status() == FIX_NOT_LUB)
          out++;
        ++iter;
      }
      return table_width() - out;
    }

    forceinline int 
    CpltSetVarImp::glbMin(void) const {
      if (mgr->ctrue(domain)) 
        return mgr_min();

      BddIterator iter(mgr, domain);
      while (iter()) {
        if (iter.status() == FIX_GLB) {
          int idx = iter.label() - offset();
          return mgr_min() + idx;
        } 
        ++iter;
      }
      return MIN_OF_EMPTY;
    }

    forceinline int 
    CpltSetVarImp::glbMax(void) const {
      if (mgr->ctrue(domain)) 
        return mgr_max();
    
      BddIterator iter(mgr, domain);
      int lastglb = -1;
      while (iter()) {
        if (iter.status() == FIX_GLB) {
          int idx = iter.label() - offset();
          lastglb = mgr_min() + idx;
        } 
        ++iter;
      }
      return (lastglb == -1) ? MAX_OF_EMPTY : lastglb;
    }

    forceinline unsigned int
    CpltSetVarImp::glbSize(void) const {
      if (mgr->ctrue(domain)) { return 0; }
      BddIterator iter(mgr, domain);
      int size = 0;
      while (iter()) {
        if (iter.status() == FIX_GLB) { size++; }
        ++iter;
      }
      return size;
    }

    forceinline int 
    CpltSetVarImp::unknownMin(void) const {
      if (mgr->ctrue(domain)) { return mgr_min(); } 
      BddIterator iter(mgr, domain);
      while (iter()) {
        NodeStatus status = iter.status();
        if (status == FIX_UNKNOWN || status == UNDET) {
          int idx = iter.label() - offset();
          return mgr_min() + idx;
        } 
        ++iter;
      }
      return MIN_OF_EMPTY;
    }

    forceinline int 
    CpltSetVarImp::unknownMax(void) const {
      if (mgr->ctrue(domain)) 
        return mgr_max();

      BddIterator iter(mgr, domain);
      int lastunknown = -1;
      while (iter()) {
        NodeStatus status = iter.status();
        if (status == FIX_UNKNOWN || status == UNDET) {
          int idx = iter.label() - offset();
          lastunknown = mgr_min() + idx;
        } 
        ++iter;
      }
      return (lastunknown == -1) ?  MAX_OF_EMPTY : lastunknown;
    }

    forceinline unsigned int
    CpltSetVarImp::unknownSize(void) const {
      int size = table_width();
      if (mgr->ctrue(domain))
        return size;

      BddIterator iter(mgr, domain);
      while (iter()) {
        NodeStatus status = iter.status();
        if (status == FIX_GLB || status == FIX_NOT_LUB) { size--; }
        ++iter;
      }
      return size;
    };

    forceinline ModEvent 
    CpltSetVarImp::exclude(Space* home, int a, int b) {
      // values are already excluded
      if (a > max  || b < min) 
        return ME_CPLTSET_NONE;

      int mi = std::max(min, a);
      int ma = std::min(b, max);

      GecodeBdd notinlub  = BDDTOP;
      // get the negated bdds for value i in [a..b]
      for (int i = ma; i >= mi; i--)         
        notinlub &= getnegbdd(i - min);

      return tell_formula(home, notinlub);
    }

    forceinline ModEvent 
    CpltSetVarImp::exclude(Space* home, int v) {  return exclude(home, v, v); }

    template <class I> 
    forceinline ModEvent 
    CpltSetVarImp::excludeI(Space* home, I& i) {
      // we can only exclude what intersects the min and max element of the variable
      Iter::Ranges::Singleton s(min, max);
      Iter::Ranges::Inter<Iter::Ranges::Singleton, I> inter(s, i);
    
      if (!inter()) 
        return ME_CPLTSET_NONE;
    
      GecodeBdd not_lub = BDDTOP;
      Iter::Ranges::ToValues<
        Iter::Ranges::Inter<Iter::Ranges::Singleton, I>
        > val(inter);

      Iter::Ranges::ValCache<
        Iter::Ranges::ToValues<
        Iter::Ranges::Inter<Iter::Ranges::Singleton, I> >
        > cache(val);
    
      for (cache.last(); cache(); --cache) {
        int v = cache.min();
        not_lub &= getnegbdd(v - min);
      }
      return tell_formula(home, not_lub);
    }

    forceinline ModEvent 
    CpltSetVarImp::include(Space* home, int a, int b) {
      if (a < min || b > max) 
        return ME_CPLTSET_FAILED;

      GecodeBdd in_glb  = BDDTOP;
      for (int i = b; i >= a; i--)
        in_glb &= getbdd(i - min);

      return tell_formula(home, in_glb);
    }

    forceinline ModEvent 
    CpltSetVarImp::include(Space* home, int v) { return include(home, v, v); }

    template <class I> 
    forceinline ModEvent 
    CpltSetVarImp::includeI(Space* home, I& i) {
      if (!i()) 
        return ME_CPLTSET_NONE;

      GecodeBdd in_glb  = BDDTOP;
      Iter::Ranges::ToValues<I> val(i);
      Iter::Ranges::ValCache<Iter::Ranges::ToValues<I> > cache(val);

      for (cache.last(); cache(); --cache) {
        int v = cache.min();
        if (v < min || max < v) 
          return ME_CPLTSET_FAILED;
        in_glb &= getbdd(v - min);
      }
      return tell_formula(home, in_glb);  
    }

  
    forceinline ModEvent
    CpltSetVarImp::nq(Space* home, int a, int b) {
      if (b < min || a > max) 
        return ME_CPLTSET_NONE;

      Iter::Ranges::Singleton m(a, b);
      GecodeBdd ass = !(gen_assignment(m));    
      return tell_formula(home, ass);
    }

    forceinline ModEvent
    CpltSetVarImp::nq(Space* home, int v) { return nq(home, v, v); }

    template <class I>
    forceinline ModEvent
    CpltSetVarImp::nqI(Space* home, I& i) {
      GecodeBdd ass = !(gen_assignment(i));
      return tell_formula(home, ass);
    }

    forceinline ModEvent
    CpltSetVarImp::eq(Space* home, int a, int b) {
      if (b < min || a > max) 
        return ME_CPLTSET_FAILED;

      Iter::Ranges::Singleton m(a, b);
      GecodeBdd ass = gen_assignment(m);
      return tell_formula(home, ass);
    }

    forceinline ModEvent
    CpltSetVarImp::eq(Space* home, int v) { return eq(home, v, v); }

    // gen assignment needs a test in case
    // we try to build an assignment
    // that is not allowed by the variable domain
    template <class I>
    forceinline ModEvent
    CpltSetVarImp::eqI(Space* home, I& i) {
      if (i()) {
        if (i.min() < min || i.min() > max) 
          return ME_CPLTSET_FAILED;
      }
      GecodeBdd ass = gen_assignment(i);
      return tell_formula(home, ass);
    }

    forceinline ModEvent 
    CpltSetVarImp::intersect(Space* home, int a, int b) {
      ModEvent me_left = exclude(home, Limits::Set::int_min, a - 1);

      if (me_failed(me_left) || me_left == ME_CPLTSET_VAL) 
        return me_left;

      ModEvent me_right = exclude(home, b + 1, Limits::Set::int_max);

      if (me_failed(me_right) || me_right == ME_CPLTSET_VAL) 
        return me_right;

      if (me_left > 0 || me_right > 0) 
        return ME_CPLTSET_DOM;

      return ME_CPLTSET_NONE;    
    }

    forceinline ModEvent 
    CpltSetVarImp::intersect(Space* home, int i) { return intersect(home, i, i); }

    template <class I> 
    forceinline ModEvent 
    CpltSetVarImp::intersectI(Space* home, I& i) {
      Iter::Ranges::Compl<Limits::Set::int_min, Limits::Set::int_max, I> compI(i);
      return excludeI(home, compI); 
    }

    forceinline ModEvent 
    CpltSetVarImp::cardinality(Space* home, int l, int u) {
      unsigned int maxcard = table_width();
      // compute the cardinality formula
      GecodeBdd c = cardcheck(mgr, maxcard, _offset, l, u);
      return tell_formula(home, c);
    }

    forceinline ModEvent 
    CpltSetVarImp::cardMin(Space* home, unsigned int newMin) {
      return cardinality(home, newMin, table_width());
    }

    forceinline ModEvent 
    CpltSetVarImp::cardMax(Space* home, unsigned int newMax) {
      return cardinality(home, 0, newMax);
    }
  
    forceinline ModEvent 
    CpltSetVarImp::tell_formula(Space* home, GecodeBdd& d) {
      bool assigned_before = assigned();
      GecodeBdd olddom = domain;
      // 130507: maybe we should first check for equality 
      //         and then perform the conjunction ?
      domain &= d;

      bool assigned_new = assigned();
      if (mgr->cfalse(domain)) 
        return ME_CPLTSET_FAILED; 

      ModEvent me = ME_CPLTSET_NONE;
      if (assigned_new) {
        if (assigned_before) {
          me = ME_CPLTSET_NONE;
          return me;
        } else {
          me =  ME_CPLTSET_VAL;
        }
        notify(home, me);
      } else {
        if (olddom != domain) {
          me = ME_CPLTSET_DOM;
          notify(home, me);
        }
      }
      return me;
    }

    // given the empty iterator we should produce an 
    // assignment for the empty set.
    template <class I>
    forceinline GecodeBdd
    CpltSetVarImp::gen_assignment(I& i) {

      Iter::Ranges::ToValues<I> vali(i);
      Iter::Ranges::ValCache<Iter::Ranges::ToValues<I> > vc(vali);

      GecodeBdd ass = BDDTOP;
      // start at the end for backwards iteration
      vc.last();
      for (int v = max; v >= min; v--) {
        if (vc()) {
          if (vc.val() == v) {
            ass &= getbdd(v - min);
            --vc;
          } else {
            ass &= getnegbdd(v - min);
          }
        } else {
          ass &= getnegbdd(v - min);
        }
      }

      return ass;
    }

    forceinline bool
    CpltSetVarImp::range(void) const { return mgr->ctrue(domain); }

    /*
     * Copying a variable
     *
     */

    forceinline CpltSetVarImp*
    CpltSetVarImp::copy(Space* home, bool share) {
      return copied() ? static_cast<CpltSetVarImp*>(forward())
        : perform_copy(home,share);
    }

    /*
     * Subscribing to variables
     *
     */
    forceinline void
    CpltSetVarImp::subscribe(Space* home, Propagator* p, PropCond pc, bool process) {
      CpltSetVarImpBase::subscribe(home,p,pc,assigned(), process);
    }

    forceinline void
    CpltSetVarImp::cancel(Space* home, Propagator* p, PropCond pc) {
      CpltSetVarImpBase::cancel(home,p,pc,assigned());
    }

    forceinline void
    CpltSetVarImp::viewdot(void) const { mgr->bdd2dot(domain); }

    forceinline int 
    CpltSetVarImp::valididx(int v) const{
      int idx = _offset + v - min;
      // std::cout << "valididx:" << _offset << "+"<<v <<"-" << min << "=" << idx << "\n";
      if ((idx < (int) _offset) || 
          (idx > (int) (_offset + table_width() - 1)))
        return -1;

      return idx;
    }

    forceinline bool
    CpltSetVarImp::knownIn(int v) const {
      if (mgr->ctrue(domain)) 
        return false;
      int idx = valididx(v);
      if (idx < 0) 
        return false;
      GecodeBdd bv = mgr->negbddpos(idx);
      return (mgr->cfalse(domain & bv));
    }

    forceinline bool
    CpltSetVarImp::knownOut(int v) const {
      if (mgr->ctrue(domain)) 
        return false;
      int idx = valididx(v);
      if (idx < 0) 
        return false;
      GecodeBdd bv = mgr->bddpos(idx);
      return (mgr->cfalse(domain & bv));
    }

    /*
     * BddIterator
     *
     */

    forceinline
    BddIterator::BddIterator(void) {}

    forceinline
    BddIterator::BddIterator(BMI* manager, const GecodeBdd& b) {
      init(manager, b);
    }

    forceinline NodeStatus 
    BddIterator::status(void) const { return flag; }

    forceinline int 
    BddIterator::level(void) const { return _level; }

    forceinline int 
    BddIterator::label(void) const { 
      if (!operator()()) { 
        return -1; 
      } else {
        return mgr->bddidx(cur); 
      }
    }
  
    forceinline bool
    BddIterator::empty(void) const { return (l == 0) && (r == n - 1); }

    forceinline bool 
    BddIterator::operator()(void) const {
      bool valid = (!empty() || singleton );
      return valid;
    }

    forceinline int
    BddIterator::size(void) const { return n; }
    
    /*
     * DomBddIterator
     *
     */

    forceinline   
    DomBddIterator::DomBddIterator(void) {}

    forceinline
    DomBddIterator::DomBddIterator(const CpltSetVarImp* x) {
      GecodeBdd dom = x->bdd_domain();
      DomBddIterator::init(x, dom);
    }

    forceinline
    DomBddIterator::DomBddIterator(const CpltSetVarImp* x, GecodeBdd& remain) {
      // std::cout <<"DomBddIterator::DomBddIterator(x)\n";
      vector_level = 0;
      mi    = x->min;
      ma    = x->max;
      off   = x->_offset;
      GecodeBdd dom = x->bdd_domain();
      if (dom != remain) {
        dom &= remain;
      }
      BddIterator::init(x->mgr, dom);
      bdd_level = BddIterator::label() - off;
    }

    forceinline void
    DomBddIterator::init(const CpltSetVarImp* x) {
      GecodeBdd dom = x->bdd_domain();
      init(x, dom);
    }

    forceinline void
    DomBddIterator::init(const CpltSetVarImp* x, GecodeBdd& remain) {
      vector_level = 0;
      mi    = x->min;
      ma    = x->max;
      off   = x->_offset;

      GecodeBdd dom = x->bdd_domain();
      if (dom != remain)
        dom &= remain;
      
      BddIterator::init(x->mgr, dom);
      bdd_level   = BddIterator::label() - off;
    }

    forceinline bool
    DomBddIterator::same(void) const { return bdd_level == vector_level; }

    forceinline bool
    DomBddIterator::operator()(void) const { return vector_level < (ma-mi+1); }

    forceinline void
    DomBddIterator::operator++(void) {
      if (same()) {
        BddIterator::operator++();
        bdd_level   = BddIterator::label() - off;
      } 
      vector_level++;
    }

    forceinline NodeStatus
    DomBddIterator::status(void) const{
      return same() ? BddIterator::status() : FIX_UNKNOWN;
    }
  
    forceinline int
    DomBddIterator::getlevel(void) const{ return vector_level; }

    forceinline int
    DomBddIterator::val(void) const {
      return same() ? mi + BddIterator::label() - off : mi + vector_level;
    }

  }
}

// STATISTICS: cpltset-var
