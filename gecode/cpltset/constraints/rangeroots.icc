/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Patrick Pekczynski <pekczynski@ps.uni-sb.de>
 *
 *  Copyright:
 *     Patrick Pekczynski, 2006
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  Permission is hereby granted, free of charge, to any person obtaining
 *  a copy of this software and associated documentation files (the
 *  "Software"), to deal in the Software without restriction, including
 *  without limitation the rights to use, copy, modify, merge, publish,
 *  distribute, sublicense, and/or sell copies of the Software, and to
 *  permit persons to whom the Software is furnished to do so, subject to
 *  the following conditions:
 *
 *  The above copyright notice and this permission notice shall be
 *  included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

namespace Gecode { namespace CpltSet {

  /*
   * Range Propagators
   *
   */

  template <class View0, class View1>
  ExecStatus
  Range<View0, View1>::divide_conquer(Space* home, bdd& p, 
                                      int l, int r, int ypos, int zpos) {
    if (l == r) {
      ModEvent me = ME_CPLTSET_NONE;
      if (l == ypos) {
        me  = y.tell_formula(home, p);
      } else {
        if (l == zpos) {
          me = z.tell_formula(home, p);
        } else {
          me = x[l].tell_formula(home, p);
        }
      }
      if (me_failed(me)) {
        return ES_FAILED;
      }
      return ES_OK;
    }
    int h = (r + l) / 2;

    // computing psi without recursion
    bdd left = p;
    for (int i = r; i >= h + 1; i--) {
      if (i == zpos) {
        quantify(left, z);
      } else {
        if (i == ypos) {
          quantify(left, y);
        } else {
          quantify(left, x[i]);
        }
      }
    }
   
    ExecStatus es = ES_OK;
    GECODE_ES_CHECK(es = divide_conquer(home, left, l, h, ypos, zpos));

    bdd right = p;
    for (int i = h; i >= l; i-- ) {
      if (i == zpos) {
        quantify(right, z);
      } else {
        if (i == ypos) {
          quantify(right, y);
        } else {
          quantify(right, x[i]);
        }
      }
    }

    GECODE_ES_CHECK(es = divide_conquer(home, right, h + 1, r , ypos, zpos));
    return es;
  }
  
  template <class View0, class View1>
  forceinline
  Range<View0, View1>::Range(Space* home, ViewArray<View0>& x, 
                             View1& y, View1& z, bdd& d0)
    : MixNaryTwoPropagator<View0, PC_CPLTSET_DOM, View1, PC_CPLTSET_DOM>(home, x, y, z), 
      d(d0) {
    MixNaryTwoPropagator<View0, PC_CPLTSET_DOM, View1, PC_CPLTSET_DOM>::force(home);
  }

  template <class View0, class View1>
  forceinline
  Range<View0, View1>::Range(Space* home, bool share, Range& p)
    : MixNaryTwoPropagator<View0, PC_CPLTSET_DOM, View1, PC_CPLTSET_DOM>(home, share, p), 
      d(p.d) {}

  template <class View0, class View1>
  forceinline ExecStatus
  Range<View0, View1>::post(Space* home, ViewArray<View0>& x, 
                            View1& y, View1& z, bdd& d0) {
    (void) new (home) Range(home, x, y, z, d0);
    return ES_OK;
  }

  template <class View0, class View1>
  Support::Symbol
  Range<View0, View1>::name(void) {
    return Reflection::mangle<View0,View1>("CpltSet::Range");
  }

  template <class View0, class View1>
  Reflection::ActorSpec&
  Range<View0,View1>::spec(Space* home, Reflection::VarMap& m) {
    throw Reflection::ReflectionException("Not implemented");
  } 

  template <class View0, class View1>
  forceinline Actor*
  Range<View0, View1>::copy(Space* home, bool share) {
    return new (home) Range(home, share, *this);
  }
  
  template <class View0, class View1>
  forceinline ExecStatus 
  Range<View0, View1>::propagate(Space* home) {
    bool assigned = true;
    int n = x.size();
    ExecStatus es = ES_OK;
    int ypos = n;
    int zpos = n + 1;

    GECODE_ES_CHECK(es = divide_conquer(home, d, 0, n + 1, ypos, zpos));

    assigned = true;
    for (int i = x.size(); i--; ) {
      assigned &= x[i].assigned();
    }
    if (assigned) {
      return ES_SUBSUMED(this, home);
    }

    return ES_FIX;
  }

  template <class View0, class View1>
  size_t
  Range<View0, View1>::dispose(Space* home) {
    MixNaryTwoPropagator<View0, PC_CPLTSET_DOM, View1, PC_CPLTSET_DOM>::unforce(home);
    if (!home->failed()) {
      x.cancel(home, this, PC_CPLTSET_DOM);
      y.cancel(home, this, PC_CPLTSET_DOM);
      z.cancel(home, this, PC_CPLTSET_DOM);
    }
    manager.dispose(d);
    MixNaryTwoPropagator<View0, PC_CPLTSET_DOM, View1, PC_CPLTSET_DOM>::dispose(home);
    return sizeof(*this);
  }

  /*
   * Posting functions
   *
   */

  /// Constructs \a d0 as the bdd representing the Range constraint for the given variables
  template <class View0, class View1>
  forceinline void
  buildRange(Space* home, ViewArray<View0>& seq, View1 selview,
             View1 unionview, bdd& d0) {

    if (home->failed()) return;
    int n = seq.size();

    unsigned int xrange = seq[0].table_width();
    int xmax            = seq[0].mgr_max();
    int xmin            = seq[0].mgr_min();
    // compute maximum value
    for (int i = n; i--; ) {
      if (seq[i].mgr_max() > xmax) {
        xmax = seq[i].mgr_max();
      }
      if (seq[i].mgr_min() < xmin) {
        xmin = seq[i].mgr_min();
      }
      if (seq[i].table_width() > xrange) {
        xrange = seq[i].table_width();
      }
    }

    GECODE_ME_FAIL(home, unionview.intersect(home, xmin, xmax));

    int unionmin = unionview.mgr_min();

    // restrict selector variable s to be \f$ s\subseteq \{0, n - 1\}\f$
    Iter::Ranges::Singleton idx(0, n - 1);
    // shift selection view to the right index
    int shift = 0 - selview.mgr_min();
    GECODE_ME_FAIL(home, selview.intersectI(home, idx));

    // check for different ranges

    // std::cout << (int) xrange << " bits and " << n << " seq vars\n";
    for (int k = 0; k < (int) xrange; k++) {
      // std::cout << "bit k=" << k << "\t";

      bdd inter = bdd_false();
//       bool kthbitempty = true;
      for (int j = 0; j < n; j++) {
      // std::cout << "seq j=" << j << ": ";
        LubValues<View0> lub(seq[j]);
        int seqmin = seq[j].mgr_min();
        int seqmax = seq[j].mgr_max();
        int cur    = xmin + k;
        if (seqmin <= cur && cur <= seqmax) {
          while (lub() && cur != lub.val()) {
            ++lub;
          }
          if (lub() && cur == lub.val()) {
            // check & or %
            // std::cout << "inter or (" << j + shift << " and " << (k - (seqmin - xmin)) << "\n";
            inter |= (selview.getbdd(j + shift) & seq[j].getbdd(k - (seqmin - xmin)));
            ++lub;
          }
//           kthbitempty &= !lub();
        }

//         if (xmin + k >= seq[j].mgr_min() && xmin + k <= seq[j].mgr_max()) {
//           cur |= (selview.getbdd(j + shift) & seq[j].getbdd(k));
//         }
      }

      // shouldnt we allow inter to be bdd_false() ?
//       if (inter != bdd_false()) {
//         d0 &= (unionview.getbdd(k - (unionmin - xmin)) % inter);
//       }
        d0 &= (unionview.getbdd(k - (unionmin - xmin)) % inter);

//       if (kthbitempty) {
//         std::cout << "kthbitempty\n";
//         d0 &= (!unionview.getbdd(k - (unionmin - xmin)));
//       }
    }

    for (int i = 0; i < n; i++) {
      if (seq[i].assigned()) {
        d0 &= seq[i].bdd_domain();
      }
    }
    if (selview.assigned()) {
      // std::cout << "selview: " << selview.bdd_domain() << "\n";
      d0 &= selview.bdd_domain();
    }
    if (unionview.assigned()) {
      d0 &= unionview.bdd_domain();
    }

  }

  template <class View0, class View1>
  forceinline void 
  range_post(Space* home, ViewArray<View0>& seq, View1 selview,
             View1 unionview) {
    if (home->failed())  return;

    bdd d0 = bdd_true();
    buildRange(home, seq, selview, unionview, d0);
    if (home->failed())  return;
    GECODE_ES_FAIL(home, (Range<View0, View1>::post(home, seq, selview, unionview, d0)));
  }

  forceinline void 
  range_con(Space* home, const IntVarArgs& x, const CpltSetVar& s,
            const CpltSetVar& t) {
    int n = x.size();
    CpltSetView selview(s);
    CpltSetView unionview(t);

    ViewArray<Gecode::Int::IntView> iv(home, n);
    for (int i = 0; i < n; i++) {
      iv[i] = x[i];
    }
    ViewArray<SingletonCpltSetView> sbv(home, n);
    for (int i = 0; i < n; i++) {
      int rmin = std::min(unionview.mgr_min(), iv[i].min());
      int rmax = std::max(unionview.mgr_max(), iv[i].max());
      sbv[i].init(rmin, rmax, iv[i]);
    }

    range_post(home, sbv, selview, unionview);
  }
    
  /// Constructs \a d0 as the bdd representing the Roots constraint for the given variables
  template <class View0, class View1>
  forceinline void
  buildRoots(Space* home, ViewArray<View0>& seq, View1 selview,
             View1 unionview, bdd& d0) {
    if (home->failed()) return;
    int n = seq.size();

    unsigned int xrange = seq[0].table_width();
    int xmax            = seq[0].mgr_max();
    int xmin            = seq[0].mgr_min();
    // compute maximum value
    for (int i = n; i--; ) {
      if (seq[i].table_width() > xrange) {
        xrange = seq[i].table_width();
      }
      if (seq[i].mgr_max() > xmax) {
        xmax = seq[i].mgr_max();
      }
      if (seq[i].mgr_min() < xmin) {
        xmin = seq[i].mgr_min();
      }
    }

    int unionmin = unionview.mgr_min();
    int unionmax = unionview.mgr_max();
    if (unionview.assigned()) {
      xmin = unionview.glbMin();
      xmax = unionview.glbMax();
      xrange = xmax - xmin + 1;
    } else {
      if (unionmin < xmin) { xmin = unionmin; }
      if (unionmax < xmax) { xmax = unionmax; }
      if (unionview.table_width() > xrange) {
        xrange = unionview.table_width();
      }
    }

    // restrict selection variable s to be \f$ s\subseteq \{0, n - 1\}\f$
    Iter::Ranges::Singleton idx(0, n - 1);
    GECODE_ME_FAIL(home, selview.intersectI(home, idx));
    // in case the selection variable ranges over negative values
    int shift = 0 - selview.mgr_min();

    for (int j = 0; j < n; j++) {    
      bdd subset = bdd_true();
      LubValues<SingletonCpltSetView> lub(seq[j]);
      for (unsigned int k = 0; k < xrange; k++) {
        int seqmin = seq[j].mgr_min();
        int seqmax = seq[j].mgr_max();
        int cur    = xmin + k;
        if (seqmin <= cur && cur <= seqmax) {
          while (lub() && cur != lub.val()) {
            ++lub;
          }
          if (lub() && cur == lub.val()) {
            if (unionmin <= cur && cur <= unionmax) {
              subset &= (seq[j].getbdd(k - (seqmin - xmin)) >>= unionview.getbdd(k - (unionmin - xmin)));
            }
            ++lub;
          }
        }
      }
      if (!manager.ctrue(subset)) {
        d0 &= (selview.getbdd(j + shift) % (subset));
      }
      if (seq[j].assigned()) {
        d0 &= seq[j].bdd_domain();
      }
    }

    if (unionview.assigned()) {
      d0 &= unionview.bdd_domain();
    }   
    if (selview.assigned()) {
      d0 &= selview.bdd_domain();
    }

    std::cout << "d0 size = " << manager.bddsize(d0) << "\n";
//     std::cout << "d0 = " << d0 << "\n";
  }

  template <class View0, class View1>
  forceinline void 
  roots_post(Space* home, ViewArray<View0>& seq, View1 selview,
             View1 unionview) {
    if (home->failed()) return;

    bdd d0 = bdd_true();
    buildRoots(home, seq, selview, unionview, d0);
    if (home->failed()) return;
    GECODE_ES_FAIL(home, (Range<View0, View1>::post(home, seq, selview, unionview, d0)));
  }

  forceinline void 
  roots_con(Space* home, const IntVarArgs& x, const CpltSetVar& s,
            const CpltSetVar& t, const CpltSetVarArgs& allvars) {
    int n = x.size();

    CpltSetView selview(s);
    CpltSetView unionview(t);

    ViewArray<Gecode::Int::IntView> iv(home, n);
    for (int i = 0; i < n; i++) {
      iv[i] = x[i];
    }
    ViewArray<SingletonCpltSetView> sbv(home, n);
    for (int i = 0; i < n; i++) {
//       int rmin = std::min(unionview.mgr_min(), iv[i].min());
//       int rmax = std::max(unionview.mgr_max(), iv[i].max());
//       sbv[i].init(mgr, rmin, rmax, iv[i]);
      sbv[i].init(iv[i].min(), iv[i].max(), iv[i]);
    }


    // do ordering
    ViewArray<CpltSetView> vars(home, allvars.size());
    for (int i = allvars.size(); i--; ) {
      vars[i] = allvars[i];
    }

    variableorder(vars, sbv);
    roots_post(home, sbv, selview, unionview);

  }

  template <class View0, class View1>
  forceinline void 
  nvalue_post(Space* home, ViewArray<View0>& seq, View1 selview,
              View1 unionview, int usedvalues) {
    std::cout << "nvalue_post\n";
    if (home->failed())  return;
    // WE HAVE TO ORDER ALL BDD VARS AVAILABLE SO FAR
    variableorder(seq);

    bdd d0 = bdd_true();
    int n = seq.size();
    Iter::Ranges::Singleton idx(0, n - 1);
    // select all variables in the sequence
    GECODE_ME_FAIL(home, selview.eqI(home, idx));
    // n values must be used (alldiff uses all |seq| values)
    GECODE_ME_FAIL(home, unionview.cardinality(home, usedvalues, usedvalues));
    // build the bdd for the range constraint
    buildRange(home, seq, selview, unionview, d0);
    if (home->failed())  return;
    GECODE_ES_FAIL(home, (Range<View0, View1>::post(home, seq, selview, unionview, d0)));
  }


  forceinline void 
  nvalue_con(Space* home, const IntVarArgs& x, const CpltSetVar& s, const CpltSetVar& t, 
            int usedvalues, const CpltSetVarArgs& allvars) {
    std::cout << "nvalue con\n";
    int n = x.size();
    CpltSetView selview(s);
    CpltSetView unionview(t);

    ViewArray<Gecode::Int::IntView> iv(home, n);
    for (int i = 0; i < n; i++) {
      iv[i] = x[i];
    }
    ViewArray<SingletonCpltSetView> sbv(home, n);
    for (int i = 0; i < n; i++) {
      int rmin = std::min(unionview.mgr_min(), iv[i].min());
      int rmax = std::max(unionview.mgr_max(), iv[i].max());
      sbv[i].init(rmin, rmax, iv[i]);
    }
    
    // do ordering
    ViewArray<CpltSetView> vars(home, allvars.size());
    for (int i = allvars.size(); i--; ) {
      vars[i] = allvars[i];
    }

    variableorder(vars, sbv);
    nvalue_post(home, sbv, selview, unionview, usedvalues);
  }

  template <class View0, class View1>
  forceinline void 
  uses_post(Space* home, ViewArray<View0>& seq, View1 selview,
            View1 unionview, 
            ViewArray<View0>& seqprime, View1 selviewprime,
            View1 unionviewprime) {
    std::cout << "usespost\n";
    if (home->failed())  return;

    bdd d0 = bdd_true();
    int n = seq.size();
    Iter::Ranges::Singleton idx(0, n - 1);
    // select all variables in the sequence
    GECODE_ME_FAIL(home, selview.eqI(home, idx));

    std::cout << "selection intersected ok\n";
    // build the bdd for the range constraint
    buildRange(home, seq, selview, unionview, d0);
    if (home->failed())  return;
    std::cout << "first range built ok\n";

    int m = seqprime.size();
    Iter::Ranges::Singleton idx2(0, m - 1);
    // select all variables in the sequence
    GECODE_ME_FAIL(home, selviewprime.eqI(home, idx2));

    std::cout << "second selection intersection ok\n";
    // build the bdd for the range constraint

    bdd e0 = bdd_true();
    buildRange(home, seqprime, selviewprime, unionviewprime, e0);
    if (home->failed())  return;

    std::cout << "second range ok\n";
    // unionviewprime is a subset of unionview
    bdd r0 = bdd_true();
    int tab = std::max(unionview.table_width(), unionviewprime.table_width());
    for (int i = 0; i < (int) tab; i++) {
      r0 &= (unionviewprime.getbdd(i)) >>= (unionview.getbdd(i));
    }
    std::cout << "subset ok\n";
    
   GECODE_ES_FAIL(home, (Range<View0, View1>::post(home, seq, selview, unionview, d0)));
   GECODE_ES_FAIL(home, (Range<View0, View1>::post(home, seqprime, selviewprime, unionviewprime, e0)));
   GECODE_ES_FAIL(home, (BinaryCpltSetPropagator<View1,View1>::post(home, unionview, unionviewprime, r0)));
       
  }


  forceinline void 
  uses_con(Space* home, const IntVarArgs& x, const CpltSetVar& s,
           const CpltSetVar& t, 
           const IntVarArgs& y, const CpltSetVar& u, const CpltSetVar& v) {
    int n = x.size();
    CpltSetView selview(s);
    CpltSetView unionview(t);

    ViewArray<Gecode::Int::IntView> iv(home, n);
    for (int i = 0; i < n; i++) {
      iv[i] = x[i];
    }
    ViewArray<SingletonCpltSetView> sbv(home, n);
    for (int i = 0; i < n; i++) {
      int rmin = std::min(unionview.mgr_min(), iv[i].min());
      int rmax = std::max(unionview.mgr_max(), iv[i].max());
      sbv[i].init(rmin, rmax, iv[i]);
    }
    
    CpltSetView selviewprime(u);
    CpltSetView unionviewprime(v);
    int m = y.size();
    ViewArray<Gecode::Int::IntView> ivprime(home, m);
    for (int i = 0; i < m; i++) {
      ivprime[i] = y[i];
    }
    ViewArray<SingletonCpltSetView> sbvprime(home, m);
    for (int i = 0; i < m; i++) {
      int rmin = std::min(unionviewprime.mgr_min(), ivprime[i].min());
      int rmax = std::max(unionviewprime.mgr_max(), ivprime[i].max());
      sbvprime[i].init(rmin, rmax, ivprime[i]);
    }

    uses_post(home, sbv, selview, unionview, 
              sbvprime, selviewprime, unionviewprime);
  }

}}

// STATISTICS: cpltset-prop
