/*
 *  Main authors:
 *     Patrick Pekczynski <pekczynski@ps.uni-sb.de>
 *
 *  Copyright:
 *     Patrick Pekczynski, 2006
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

namespace Gecode { 

  /**
   * \brief Manager for CpltSetVars. 
   *
   * Used for initialization and destruction of the global lookup table for
   * Bdd nodes and for keeping track between CpltSetVars and their corresponding
   * indices in the lookup table. 
   */
  class CuddMgr {
  private:
    Cudd* cmgr;
    CpltSetOutput _level;
    /// Number of registered variables
    int _size;
    /// Number of used nodes
    int _offset;
    //     /// Return the number of registered variables
    //     int registered();
    //     /// Return the smallest free offset in the node table
    //     int free();
    int dummy_offset;
    int dummy_range;
  public:
    /// Default constructor
    CuddMgr(void);
    /// Default constructor
    CuddMgr(Cudd& m);
    /// Constructor manager with initial nodesize \a n and cachesize \a c.
    CuddMgr(int n, int c);
    /// Copy constructor 
    CuddMgr(const CuddMgr& m);
    /// Initialize manager with initial nodesize \a n and cachesize \a c.
    void init(int n, int c);
    /// Test whether bdd \a b is either constant true or constant false
    bool leaf(const GecodeBdd& b) const;
    /// Tests whether bdd \a b is constant false
    bool cfalse(const GecodeBdd& b) const;
    /// Tests whether bdd \a b is constant true
    bool ctrue(const GecodeBdd& b) const;

    /// Sets the variable ordering in the bdd according to the orddering given in \a hls.
    void setorder(int* hls);

    /// Return the size of bdd \a b 
    unsigned int bddsize(const GecodeBdd& b) const;
    /// Return the number of paths of bdd leading to a true node\a b
    unsigned int bddpath(const GecodeBdd& b) const;
    /// Return the total number of paths of bdd \a b
    unsigned int number_of_paths(GecodeBdd& b);
    //     /// Return the number of distinct nodes used in a bdd \a b
    //     unsigned int bdddistnodes(const GecodeBdd& b) const;
    /// Return bdd at position \a i in bdd lookup table
    GecodeBdd bddpos(int i) const;
    /// Return negated bdd at position \a i in bdd lookup table
    GecodeBdd negbddpos(int i) const;

    /// Returns the bdd entry in the table for \a i
    int bdd2var(int i);
    /// Returns the variable entry in the table for bdd \a i
    int var2bdd(int i);
    /// Returns the offset of the first dummy var if there is any
    int dummy(void);
    /// Returns the constant bdd \f$ \top \f$ 
    GecodeBdd top(void) const;
    /// Returns the constant bdd \f$ \bot \f$ 
    GecodeBdd bot(void) const;

    /// Return the true branch of a bdd \a b.
    GecodeBdd iftrue(GecodeBdd& b);
    /// Return the false branch of a bdd \a b.
    GecodeBdd iffalse(GecodeBdd& b);
    /// Returns the index of the corresponding node for \a b in the global table.
    unsigned int bddidx(const GecodeBdd& b) const;
    /// Set the bdd \a dom to \f$ \exists_{V(var)} \left(dom \wedge d\right)\f$    
    void existquant(GecodeBdd& dom, GecodeBdd& d, int* var, int s);
    /// Set the bdd \a dom to \f$ \exists_{V([x_a,\dots,x_b])} \left(dom \wedge d\right)\f$w
    void existquant(GecodeBdd& dom, GecodeBdd& d, int a, int b);
    /// Set the bdd \a dom to \f$ \exists_{V(pr)} \left(dom \wedge d\right)\f$
    void existquant(GecodeBdd& dom, GecodeBdd& d, GecodeBdd& pr);

    /// Set the bdd \a d to \f$ \exists_{V([x_a,\dots,x_b])} d\f$
    GecodeBdd eliminate(GecodeBdd& d, int a, int b);
    /// Set the bdd \a d to \f$ \exists_{V(e)} d\f$
    GecodeBdd eliminate(GecodeBdd& d, GecodeBdd& e);
    /// Set the bdd \a d to \f$ \exists_{V(var)} d\f$
    GecodeBdd eliminate(GecodeBdd& d, int* var, int s);

    /// Marks in the table, whether dummy nodes have been allocated so far.
    void markdummy(int a, int b);

    /// Free the node table
    void dispose(void);
    /// Free variable in the node table
    void dispose(int offset, int range, int freenodes = 0);
    /// Free nodes for bdd \a d in the table
    void dispose(GecodeBdd& d);
    /** 
     * \brief Subscribe a variable to the lookup table
     *  Should return the offset, where the first node starts.
     */
    int allocate(int r);
    void debug(std::ostream&);
    /// Prints a bdd node \a b with its true edge and its false edge.
    void bddntf(std::ostream&, GecodeBdd& b) ;
    /// Prints dot-output of a bdd \a b.
    void bdd2dot(const GecodeBdd& b) const;
    /// Return the number of allocated bdd variables for the set elements in the table
    unsigned int allocated(void);
    /// Set print of a bdd
    void print_set(const GecodeBdd& b);

    /// Set the output level to level \a l.
    void level(CpltSetOutput l);
    /// Return the output level
    CpltSetOutput level(void);
    /// Return the current offset of the manager
    int offset(void) const;

    /// Memory Management
    void setmaxinc(int max);
    /// Retrieve underlying Cudd Wrapper
    Cudd* getCudd(void);
    /// Retrieve underlying DD-Node Manager
    DdManager* getDdMgr(void);
    /// Count references on CuddMgr
    int countref(void);

    void mark(GecodeBdd& b);
    void unmark(GecodeBdd& b);
    bool marked(GecodeBdd& b) const;
	      
  };

  forceinline
  CuddMgr::CuddMgr(void) 
    : _level(CPLTSET_BND),  _size(0), _offset(0), 
      dummy_offset(-1), dummy_range(-1) {
    cmgr = NULL;
    std::cout << "CUDD default constr\n";
  }

  forceinline
  CuddMgr::CuddMgr(Cudd& m) 
    : cmgr(&m), _level(CPLTSET_BND),  _size(0), _offset(0), 
      dummy_offset(-1), dummy_range(-1) {
    std::cout << "CUDD provided \n";
    assert(cmgr != NULL);
  }

  forceinline
  CuddMgr::CuddMgr(int n, int c)
    : _level(CPLTSET_BND),  _size(0), _offset(0), 
      dummy_offset(-1), dummy_range(-1)  {  
    std::cout << "CUDD init  constr\n";
    Cudd mgr(n,0,CUDD_UNIQUE_SLOTS, c, 0);
    cmgr = &mgr;
  }

  
  forceinline
  CuddMgr::CuddMgr(const CuddMgr& m)
    : cmgr(m.cmgr), _level(m._level),  _size(m._size), _offset(m._offset), 
      dummy_offset(m.dummy_offset), dummy_range(m.dummy_range)  {
    std::cout << "CUDD copy  constr\n";
  }

  forceinline void
  CuddMgr::init(int n, int c) {  
        std::cout << "CUDD init for" << cmgr << "\n";

    _size = 0;
    _offset = 0;
    dummy_offset = -1; 
    dummy_range = -1;
    
    cmgr->init(n, 0, CUDD_UNIQUE_SLOTS, c, 0);
    // cmgr->makeVerbose();
    // assert(cmgr->isVerbose());
    // cmgr->info();
    assert(cmgr != NULL);
    //     std::cout << cmgr->getManager()->size << "\n";
    //     std::cout << "doing debug in init\n";
    //     debug(std::cout);
  }

  forceinline bool
  CuddMgr::leaf(const GecodeBdd& b) const{  
    return Cudd_IsConstant(b.getNode());
  }

  forceinline bool
  CuddMgr::ctrue(const GecodeBdd& b) const{  
    return b == top();
  }

  forceinline bool
  CuddMgr::cfalse(const GecodeBdd& b) const {  
    if (b == bot()) {
      assert(b.getNode() == Cudd_Not(DD_ONE(cmgr->getManager())));
    }
    return b == bot();
  }


  forceinline void
  CuddMgr::print_set(const GecodeBdd& b) {
    // NOTHING
  }

  forceinline int 
  CuddMgr::allocate(int r) {
    // std::cout << "CUDD allocate\n";
    _size++;

    if (dummy_offset > - 1) {
      // std::cout << "dummy_offset = " << dummy_offset << "\n";
      if (dummy_range < r) {
	// std::cout << "not enough dummy\n";
	for (int i = dummy_range; i < r; i++) {
	  // GecodeBdd v = bddpos(i);
	  bddpos(i);
	}
      } else {
	// std::cout << "enough dummy\n";
	int initoffset = dummy_offset;
	if (dummy_range > r) {
	  // std::cout << "too much dummy\n";
	  _offset = dummy_offset;
	  _offset += r;
	} else {
	  // std::cout << "exactly dummy\n";
	  dummy_offset = -1;
	}
	// std::cout << "return value=" << initoffset << "\n";
	return initoffset;
      }
    }

    // std::cout << "extvarnum: " <<r <<"\n";

    // std::cout << "start at offset = " << _offset <<"\n";
    
    for (int i = _offset; i < _offset + r; i++) {
      // std::cout << "bddpos(" << i << ")\n";
      bddpos(i);
      // cmgr->info();
      //       std::cout << "\n";
      //       std::cout << v.getNode() << "\n";
    }

    int initoffset = _offset;
    // std::cout << "return value=" << initoffset << "\n";
    _offset += r;
    // std::cout << "**** END ALLOCATE ****\n";
    //     debug(std::cout);

    return initoffset;
  }

  forceinline unsigned int
  CuddMgr::allocated(void) {
    return _offset;
    // return Cudd_ReadSize(cmgr->getManager());
  }

  forceinline GecodeBdd
  CuddMgr::bddpos(int i) const{
    return cmgr->bddVar(i);
  }

  forceinline GecodeBdd
  CuddMgr::negbddpos(int i) const{
    return !(bddpos(i));
  }

  forceinline int
  CuddMgr::bdd2var(int i){
    // NOTHING
    return -13;
  }

  forceinline int
  CuddMgr::var2bdd(int i){
    // NOTHING
    return -14;
  }

  forceinline int
  CuddMgr::dummy(void){
    return dummy_offset;
  }

  forceinline void
  CuddMgr::setorder(int* hls) {
    //     Mtr_PrintTree(Cudd_ReadTree(cmgr->getManager()));
        std::cout << " *********** SETORDER *********** \n";
        for (int i = 0; i < _offset; i++) {
          std::cout << hls[i] << " ";
        }
        std::cout << "\n";
    //     for (int i = 0; i < _offset; i++) {
    //       MtrNode* mtr = Cudd_MakeTreeNode(cmgr->getManager(), hls[i], 1, MTR_FIXED);
    //       Mtr_PrintGroups(Cudd_ReadTree(cmgr->getManager()),0);
    //       // Mtr_PrintTree(Cudd_ReadTree(cmgr->getManager()));
    //     }
    //     // Check how reordering works in here
    //     Mtr_PrintTree(Cudd_ReadTree(cmgr->getManager()));

    //     Cudd_ReduceHeap(cmgr->getManager(), CUDD_REORDER_SIFT_CONVERGE, -12);
    // //     cmgr->info();
    //     // NO PLAN HOW TO SET ORDER
    //     std::cout << " *********** END SETORDER *********** \n";
    //     Mtr_PrintGroups(Cudd_ReadTree(cmgr->getManager()),0);
    //     Mtr_PrintTree(Cudd_ReadTree(cmgr->getManager()));
    //     cmgr->info();
    cmgr->ShuffleHeap(hls);
  }

  // check whether we have to subtract 1 (if constant true is counted)
  forceinline unsigned int
  CuddMgr::bddsize(const GecodeBdd& b) const{
    return b.nodeCount();
  }

  forceinline unsigned int
  CuddMgr::bddpath(const GecodeBdd& b) const{
    // strange only correct is MINTERM

    //     int n = Cudd_DagSize(b.getNode());

    //     std::cout << "check path\n";
    //     std::cout << "p to non zero: " << Cudd_CountPathsToNonZero(b.getNode()) << "\n";

    //     std::cout << "all minterms: " << 
    //       Cudd_CountMinterm(cmgr->getManager(), b.getNode(), n) << "\n";
    //     std::cout << "all paths: " << Cudd_CountPath(b.getNode()) << "\n";
    // seems ok now
    return Cudd_CountPathsToNonZero(b.getNode());

    //     return Cudd_CountMinterm(cmgr->getManager(), b.getNode(), n);

  }

  forceinline unsigned int
  CuddMgr::number_of_paths(GecodeBdd& b) {
    if (leaf(b)) {
      return 1;
    } else {
      GecodeBdd t = iftrue(b);
      GecodeBdd f = iffalse(b);
      return number_of_paths(t) + number_of_paths(f);
    }
  }

  //   forceinline unsigned int
  //   CuddMgr::bdddistnodes(const GecodeBdd& b) const{
  // //     std::cout << "distnodes ? \n";
  // //     std::cout << "dag size: "<<Cudd_DagSize(b.getNode()) << "\n";
  // //     std::cout << "node size: "<<(b.nodeCount()) - 1<< "\n";
  //     return bddsize(b) - 1;
  //   }

  forceinline GecodeBdd
  CuddMgr::top(void) const {
    assert(cmgr != NULL);
    assert( (cmgr->bddOne()).getNode()->type.value == 1);
    return cmgr->bddOne();
  };

  forceinline GecodeBdd
  CuddMgr::bot(void) const {
    return !top();
  };

  forceinline GecodeBdd 
  CuddMgr::iftrue(GecodeBdd& b) {
    // violated by printout ??
    //     assert(!leaf(b));

    //     DdNode* cur = Cudd_Regular(b.getNode());
    //     if (Cudd_IsComplement(b.getNode())) {
    //       b.setNode(cur->type.kids.E);
    //     } else {
    //       b.setNode(cur->type.kids.T);
    //     }  
    //     return b;

    //     std::cout << "if true: " << b.getNode()->type.value << "\n";
    //     std::cout << "if true: " << b.getNode()->type.kids.T->type.value << "\n";
    if (Cudd_IsComplement(b.getNode())) {
      // std::cout << "compl follow -notT\n";
      return BDD(cmgr, Cudd_Not(Cudd_T(b.getNode())));
    } else {
      // std::cout << "follow T\n";
      return BDD(cmgr, Cudd_T(b.getNode()));
    }
  }

  forceinline GecodeBdd
  CuddMgr::iffalse(GecodeBdd& b) {
    // violated by printout ??
    //     assert(!leaf(b));
    //     DdNode* cur = Cudd_Regular(b.getNode());
    //     if (Cudd_IsComplement(b.getNode())) {
    //       b.setNode(cur->type.kids.T);
    //     } else {
    //       b.setNode(cur->type.kids.E);
    //     }
    //     return b;
    //     std::cout << "if false: " << b.getNode()->type.value << "\n";
    //     std::cout << "if false: " << b.getNode()->type.kids.E->type.value << "\n";
    if (Cudd_IsComplement(b.getNode())) {
      // std::cout << "compl follow -not E\n";
      return BDD(cmgr, Cudd_Not(Cudd_E(b.getNode())));
    } else {
      // std::cout << "follow E\n";
      return BDD(cmgr, Cudd_E(b.getNode()));
    }
  }

  forceinline unsigned int
  CuddMgr::bddidx(const GecodeBdd& b) const{
    return b.NodeReadIndex();
  }

  forceinline void
  CuddMgr::bdd2dot(const GecodeBdd& b) const{
    GECODE_AUTOARRAY(DdNode*, bnode, 1);
    bnode[0] = b.getNode();
    BDDvector vec(1, cmgr, &bnode[0]);
    vec.DumpDot();
  }

  forceinline void
  CuddMgr::existquant(GecodeBdd& dom, GecodeBdd& d, int* var, int s) {
    GecodeBdd cur = top();
    for (int i = 0; i < s; i++) {
      cur &= bddpos(var[i]);
    }
    dom     = dom.AndAbstract(d, cur);
  }

  forceinline void
  CuddMgr::existquant(GecodeBdd& dom, GecodeBdd& d, int a, int b) {
    GecodeBdd cur = top();
    for (int i = a; i <= b; i++) {
      cur &= bddpos(i);
    }
    dom     = dom.AndAbstract(d, cur);
  }

  forceinline void
  CuddMgr::existquant(GecodeBdd& dom, GecodeBdd& d, GecodeBdd& pr) {
    dom     = dom.AndAbstract(d, pr);
  }

  forceinline GecodeBdd
  CuddMgr::eliminate(GecodeBdd& d, int a, int b) {
    GecodeBdd cur = top();
    for (int i = a; i <= b; i++) {
      cur &= bddpos(i);
    }
    return d.ExistAbstract(cur);
  }

  forceinline GecodeBdd
  CuddMgr::eliminate(GecodeBdd& d, int* var, int s) {
    GecodeBdd cur = top();
    for (int i = 0; i < s; i++) {
      cur &= bddpos(var[s]);
    }
    return d.ExistAbstract(cur);
  }

  forceinline GecodeBdd
  CuddMgr::eliminate(GecodeBdd& d, GecodeBdd& e) {
    return d.ExistAbstract(e);
  }

  forceinline void
  CuddMgr::markdummy(int a, int b) {
    // std::cout << "markdummy " << a << ".." <<b << "\n";
    dummy_offset = a;
    dummy_range  = b;
    _size--;
  }

  forceinline void
  CuddMgr::dispose(void) {
    std::cout << "CUDD  Dispose for";
    std::cout << cmgr << "\n";
    if (cmgr != NULL) {
      if (cmgr->getManager() != NULL) {
	std::cout << "apply Cudd_Quit\n";
	cmgr->dispose();
	std::cout << "did Cudd_Quit\n";
      } else {
	std::cout << "ddmgr is null\n";
      }
    }

    _size = 0;
    _offset = 0;
    dummy_offset = -1; 
    dummy_range = -1;

  }

  forceinline void
  CuddMgr::dispose(int offset, int range, int freenodes) {
    for (int i = 0; i < range; i++) {
      bddpos(offset + i).dispose();
    }
  }

  forceinline void
  CuddMgr::dispose(GecodeBdd& d) {
    d.dispose();
  }

  forceinline void
  CuddMgr::bddntf(std::ostream& os, GecodeBdd& b) { }

  forceinline void
  CuddMgr::debug(std::ostream& os) {
    if (cmgr == NULL) {
      os << "CUDD not initialized\n";
    } else {
      DdManager* dmgr = cmgr->getManager();
      if (dmgr != NULL) {
	os << "(" << "#libary variables  = " << Cudd_ReadSize(dmgr) << ","
	   <<  "#gecode vars = " << _size << ")\n";
	os << "Next Free offset at = " << _offset << "\n";
	if (dummy_offset > -1) {
	  os << " Dummy from " << dummy_offset << " to "<< dummy_range<<"\n";
	}
	// cmgr->info();
	//       cmgr->makeVerbose();
	//       assert( cmgr != NULL);
	//       DdManager* dmgr = cmgr->getManager();
	//       assert(dmgr != NULL);
	//       if (dmgr == NULL) {
	// 	os << "critical failure NO DdManager\n";
	//       } else {
	// 	os << "Valid? " << (dmgr->size > 0) << "\n";
	//       }

	//     bdd_stats(&info);
	//     os << "(" << "#nodes = " << info.nodenum << ","
	// 	      << "#var = " << info.varnum <<  "," 
	// 	      << "#free nodes = " << info.freenodes << ")\n";
	//     os << "Ouput level = " << _level << "\n";
	//     os << "Registered CpltSetVars = " << _size << "\n";
	//     assert(_level < 4);
	//     // os << "Table: " << bddtable << "\n";
      } else {
	os << "NO CAPSULE with DDManager\n";
      }
    }
  }

  forceinline void
  CuddMgr::level(CpltSetOutput l) {
    _level = l;
  }

  forceinline CpltSetOutput
  CuddMgr::level(void) {
    return _level;
  }

  forceinline int
  CuddMgr::offset(void) const{
    //     assert(_offset <= bdd_varnum());
    return _offset;
  }

  forceinline void
  CuddMgr::setmaxinc(int max) {
    //     int o = bdd_setmaxincrease(max);
    //     std::cout << "set max inc= " << o << "\n";
  }



  forceinline Cudd* 
  CuddMgr::getCudd(void) {
    return cmgr;
  }

  forceinline DdManager* 
  CuddMgr::getDdMgr(void) {
    return cmgr->getManager();
  }

  forceinline int 
  CuddMgr::countref(void) {
    return Cudd_CheckZeroRef(cmgr->getManager());
  }

  forceinline void 
  CuddMgr::mark(GecodeBdd& b) { cudd_mark(b); }

  forceinline void
  CuddMgr::unmark(GecodeBdd& b) { cudd_unmark(b); }

  forceinline bool
  CuddMgr::marked(GecodeBdd& b) const { return cudd_marked(b); }

}
