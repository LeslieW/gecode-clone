/*
 *  Main authors:
 *     Patrick Pekczynski <pekczynski@ps.uni-sb.de>
 *
 *  Copyright:
 *     Patrick Pekczynski, 2006
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  Permission is hereby granted, free of charge, to any person obtaining
 *  a copy of this software and associated documentation files (the
 *  "Software"), to deal in the Software without restriction, including
 *  without limitation the rights to use, copy, modify, merge, publish,
 *  distribute, sublicense, and/or sell copies of the Software, and to
 *  permit persons to whom the Software is furnished to do so, subject to
 *  the following conditions:
 *
 *  The above copyright notice and this permission notice shall be
 *  included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include "gecode/support/buddy/bdd.h"

namespace Gecode {
  
  /// %Exception: Error in the Buddy ROBDD manager
  class BddMgrException : public Exception {
  public:
    /// Initialize with location \a l
    BddMgrException(const char* l);
  };

  inline
  BddMgrException::BddMgrException(const char* l)
    : Exception(l,"Error in ROBDD Manager") {}
  
  namespace CpltSet {

  /**
   * \brief Manager for CpltSetVars. 
   *
   * Used for initialization and destruction of the global lookup table for
   * Bdd nodes and for keeping track between CpltSetVars and their 
   * corresponding indices in the lookup table. 
   */
  class BMI : public SharedHandle::Object {
  private:
    bddStat info;
    /// Number of registered variables
    int _size;
    /// Number of used nodes
    int _offset;
    int dummy_offset;
    int dummy_range;
    bool _debug;
  public:
    /// Default constructor
    BMI(void);
    /// Constructor manager with initial nodesize \a n and cachesize \a c.
    BMI(int n, int c);
    /// Copy constructor 
    BMI(const BMI& m);

    /// Test destructor
    ~BMI(void);
    
    /// Initialize manager with initial nodesize \a n and cachesize \a c.
    void init(int n, int c);
    /// Test whether bdd \a b is either constant true or constant false
    bool leaf(const bdd& b) const;
    /// Tests whether bdd \a b is constant false
    bool cfalse(const bdd& b) const;
    /// Tests whether bdd \a b is constant true
    bool ctrue(const bdd& b) const;
    /// Sets the variable ordering in the bdd according to \a hls.
    void setorder(int* hls);
    /// Return the size of bdd \a b
    unsigned int bddsize(const bdd& b) const;
    /// Return the number of paths of bdd leading to a true node\a b
    unsigned int bddpath(const bdd& b) const;
    /// Return the total number of paths of bdd \a b
    unsigned int number_of_paths(bdd& b);
    /// Return bdd at position \a i in bdd lookup table
    bdd bddpos(int i) const;
    /// Return negated bdd at position \a i in bdd lookup table
    bdd negbddpos(int i) const;

    /// Get lower cardinality bound for breadth-first iteration
    int lbCard(const bdd& b);
    /// Get upper cardinality bound for breadth-first iteration
    int ubCard(const bdd& b);

    /// Set lower cardinality bound for breadth-first iteration
    void lbCard(const bdd& b, int l);
    /// Set upper cardinality bound for breadth-first iteration
    void ubCard(const bdd& b, int r);

    /// Construct the Bdd for \f$ \mbox{if} v \mbox{then} t \mbox{else} f
    bdd ite(const bdd& v, const bdd& t, const bdd& f);
    /// Marks the bdd \a b
    void mark(const bdd& b);
    /// Unmarks the bdd \a b
    void unmark(const bdd& b);
    /// Check whether \a b is marked
    bool marked(const bdd& b) const;

    int node_level(const bdd& b) const;
    /// Returns the position of variable \a i in the current variable order
    int bdd2var(int i);
    /// Returns the variable at position \a i in the current variable order
    int var2bdd(int i);
    /// Returns the offset of the first dummy var if there is any
    int dummy(void);
    /// Return the true branch of a bdd \a b.
    bdd iftrue(bdd& b);
    /// Return the false branch of a bdd \a b.
    bdd iffalse(bdd& b);
    /// Returns the index of the variable labeling the bdd \a b
    const unsigned int bddidx(const bdd& b);
    
    /// Set the bdd \a dom to \f$ \exists_{V(var)} \left(dom \wedge d\right)\f$
    void existquant(bdd& dom, bdd& d, int* var, int s);
    /// Set the bdd \a dom to \f$ \exists_{V([x_a,\dots,x_b])} \left(dom \wedge d\right)\f$
    void existquant(bdd& dom, bdd& d, int a, int b);
    /// Set the bdd \a dom to \f$ \exists_{V(pr)} \left(dom \wedge d\right)\f$
    void existquant(bdd& dom, bdd& d, bdd& pr);
    /// Set the bdd \a d to \f$ \exists_{V([x_a,\dots,x_b])} d\f$
    bdd eliminate(bdd& d, int a, int b);
    /// Set the bdd \a d to \f$ \exists_{V(e)} d\f$
    bdd eliminate(bdd& d, bdd& e);
    /// Set the bdd \a d to \f$ \exists_{V(var)} d\f$
    bdd eliminate(bdd& d, int* var, int s);
    /// Marks in the table, whether dummy nodes have been allocated so far.
    void markdummy(int a, int b);

    /// Free the node table
    void dispose(void);
    /// Free variable in the node table
    void dispose(int offset, int range, int freenodes = 0);
    /// Free nodes for bdd \a d in the table
    void dispose(bdd& d);
    /** 
     * \brief Subscribe a variable to the lookup table
     *  Returns the offset where the first node starts.
     */
    int allocate(int r);
    void debug(std::ostream&);
    // show budd debug output after space has been destroyed
    void debug(void);
    /// return the number of used bdd variables
    int varnum(void);
    /// Prints a bdd node \a b with its true edge and its false edge.
    void bddntf(std::ostream&, bdd& b);
    /// Prints dot-output of a bdd \a b.
    void bdd2dot(const bdd& b) const;
    /// Return the number of allocated bdd variables for the set elements in the table
    unsigned int allocated(void);
    /// Set print of a bdd
    void print_set(const bdd& b);
    /// Return the current offset of the manager
    int offset(void) const;
    /// Memory Management
    void setmaxinc(int max);
    // void operator delete(void* p);
    virtual SharedHandle::Object* copy(void) const;
    /// Check whether the buddy library has already been initialized 
    bool available(void);
  };

  forceinline SharedHandle::Object*
  BMI::copy(void) const {
    throw BddMgrException("Copying not allowed!");
  }

  forceinline bool
  BMI::available(void) { return bdd_isrunning(); }

  forceinline bool 
  BMI::leaf(const bdd& b) const{ return b == bdd_true() || b == bdd_false(); }

  forceinline bool 
  BMI::cfalse(const bdd& b) const{ return b == bdd_false(); }

  forceinline bool 
  BMI::ctrue(const bdd& b) const{ return b == bdd_true(); }

  forceinline
  BMI::BMI(void)
  : _size(0), _offset(0), dummy_offset( -1), dummy_range(-1), _debug(false) {}

  forceinline
  BMI::BMI(int n, int c)
    : _size(0), _offset(0), 
      dummy_offset(-1), dummy_range(-1), _debug(false)  {  
    if (available()) {
      throw BddMgrException("BDD library already initialized. "
      "Only one instance allowed at a time.");
    }
    // intialize the library
    bdd_init(n, c);
    
    info.produced = -1;
    info.nodenum = -1;
    info.maxnodenum = -1;
    info.freenodes= -1;
    info.minfreenodes= -1;
    info.varnum= -1;
    info.cachesize= -1;
    info.gbcnum= -1;
  }

  
  forceinline
  BMI::BMI(const BMI& m)
    : _size(m._size), _offset(m._offset), 
      dummy_offset(m.dummy_offset), dummy_range(m.dummy_range), 
      _debug(m._debug)  {
    info.produced     = m.info.produced;
    info.nodenum      = m.info.produced;
    info.maxnodenum   = m.info.maxnodenum;
    info.freenodes    = m.info.freenodes;
    info.minfreenodes = m.info.minfreenodes;
    info.varnum       = m.info.varnum;
    info.cachesize    = m.info.cachesize;
    info.gbcnum       = m.info.gbcnum;
  }

  forceinline
  BMI::~BMI(void) {
    dispose();
  }
   
  forceinline void
  BMI::init(int n, int c) {  
    _size = 0;
    _offset = 0;
    dummy_offset = -1; 
    dummy_range = -1;
    _debug = false;
    bdd_init(n, c);
  }


  forceinline void
  BMI::print_set(const bdd& b) {
    bdd_printset(b);
  }

  forceinline int 
  BMI::allocate(int r) {
    assert(available());
    _size++;
    bdd_stats(&info);
    if (dummy_offset > - 1) {
      if (dummy_range < r) {
        for (int i = dummy_range; i < r; i++) { bdd v = bddpos(i); }
      } else {
        int initoffset = dummy_offset;
        if (dummy_range > r) {
          _offset = dummy_offset;
          _offset += r;
        } else {
          dummy_offset = -1;
        }
        return initoffset;
      }
    }

    // increase on number of allocated bdd variables
    bdd_extvarnum(r);

    for (int i = _offset; i < _offset + r; i++) { bdd v = bddpos(i); }

    int initoffset = _offset;
    _offset += r;
    return initoffset;
  }

  forceinline unsigned int
  BMI::allocated(void) {
    bdd_stats(&info);
    return info.varnum;
  }

  forceinline bdd
  BMI::bddpos(int i) const{ return bdd_ithvarpp(i); }

  forceinline bdd
  BMI::negbddpos(int i) const{ return bdd_nithvarpp(i); }

  forceinline void 
  BMI::mark(const bdd& b) { bdd_mark_node(b); }

  forceinline void
  BMI::unmark(const bdd& b) { bdd_unmark_node(b); }

  forceinline bool
  BMI::marked(const bdd& b) const { return bdd_marked_node(b); }

  forceinline int
  BMI::node_level(const bdd& b) const{ return bdd_level_node(b); }

  forceinline int
  BMI::lbCard(const bdd& b) { return bdd_card_lo(b); }

  forceinline int
  BMI::ubCard(const bdd& b) { return bdd_card_hi(b); }

  forceinline void
  BMI::lbCard(const bdd& b, int l) {  bdd_set_card_lo(b, l); }

  forceinline void
  BMI::ubCard(const bdd& b, int r) {  bdd_set_card_hi(b, r); }
  
  forceinline bdd
  BMI::ite(const bdd& v, const bdd& t, const bdd& f) {
    return bdd_ite(v, t, f);
  }

  forceinline int
  BMI::bdd2var(int i){ return bdd_level2var(i); }

  forceinline int
  BMI::var2bdd(int i){ return bdd_var2level(i); }

  forceinline int
  BMI::dummy(void){ return dummy_offset; }

  forceinline void
  BMI::setorder(int* hls) {
    bdd_setvarorder(hls);
    bdd_disable_reorder();
  }

  forceinline unsigned int
  BMI::bddsize(const bdd& b) const{ return bdd_nodecount(b); }

  forceinline unsigned int
  BMI::bddpath(const bdd& b) const{
    return static_cast<unsigned int> (bdd_pathcount(b));
  }

  forceinline unsigned int
  BMI::number_of_paths(bdd& b){
    if (leaf(b)) { return 1; }
    bdd t = iftrue(b);
    bdd f = iffalse(b);
    return number_of_paths(t) + number_of_paths(f);
  }

  forceinline bdd 
  BMI::iftrue(bdd& b) { return bdd_high(b); }

  forceinline bdd 
  BMI::iffalse(bdd& b) { return bdd_low(b); }

  forceinline const unsigned int
  BMI::bddidx(const bdd& b) {
    if (marked(b)) {
      unmark(b);
      int i = bdd_var(b);
      mark(b);
      return i;
    } else {
      return bdd_var(b);
    }
  }

  forceinline void
  BMI::bdd2dot(const bdd& b) const{ bdd_printdot(b); }

  forceinline void
  BMI::existquant(bdd& dom, bdd& d, int* var, int s) {
    bdd outvar = bdd_makeset(var, s);
    bdd newdom = bdd_appex(dom, d, bddop_and, outvar);
    dom        = newdom;
  }

  forceinline void
  BMI::existquant(bdd& dom, bdd& d, int a, int b) {
    bdd outvar = bdd_true();
    for (int i = a; i <= b; i++) {
      bdd cur = bddpos(i);
      assert(!marked(cur));
      assert(!leaf(cur));
      outvar &= cur;
    }
    bdd newdom = bdd_appex(dom, d, bddop_and, outvar);
    dom = newdom;
  }

  forceinline void 
  BMI::existquant(bdd& dom, bdd& d, bdd& pr) {
    dom = bdd_appex(dom, d, bddop_and, pr);
  }

  forceinline bdd
  BMI::eliminate(bdd& d, int a, int b) {
    bdd outvar = bdd_true();
    for (int i = a; i <= b; i++) {
      bdd cur = bddpos(i);
      assert(!marked(cur));
      outvar &= cur;
    }
    return bdd_exist(d, outvar);
  }

  forceinline bdd
  BMI::eliminate(bdd& d, bdd& e) {
    return bdd_exist(d, e);
  }

  forceinline bdd
  BMI::eliminate(bdd& d, int* var, int s) {
    bdd outvar = bdd_makeset(var, s);
    return bdd_exist(d, outvar);
  }

  forceinline void
  BMI::markdummy(int a, int b) {
    dummy_offset = a;
    dummy_range  = b;
    _size--;
  }

  forceinline void
  BMI::dispose(void) {
    if (available()) { 
      bdd_done(); 
    }
    _size = 0;
    _offset = 0;
    dummy_offset = -1; 
    dummy_range = -1;
  }

  forceinline void
  BMI::dispose(int offset, int range, int freenodes) {
    if (available()) {
      for (int i = 0; i < range; i++) {  bddpos(offset + i).dispose(); }
      if (_offset == offset + range) { _offset -= range; }
      // this is done in dipose(bdd d)
      info.freenodes += freenodes;
      if (offset == dummy_offset && dummy_offset > -1) {
        dummy_offset = -1;
        dummy_range  = -1;
      }
    }
  }

  forceinline void
  BMI::dispose(bdd& d) {
    if (available()) {
      int freenodes = bddsize(d);
      d = bdd_false();
      info.freenodes += freenodes;
    }
  }

  forceinline void
  BMI::bddntf(std::ostream& os, bdd& b) {
    os << "(N" << b;
    os <<", T"<< iftrue(b);
    os << ", F" << iffalse(b) << ")";
    os << "[" << bddidx(b) << "]\n";
  }

  forceinline int
  BMI::varnum(void) {
    bdd_stats(&info);
    return info.varnum;
  }
  
  forceinline void
  BMI::debug(std::ostream& os) {
    bdd_stats(&info);
    os << "Buddy-Information:\n" 
       << "\tregistered vars: " << _size << "\n"
       << "\tallocated nodes: " << info.nodenum << "\n"
       << "\tused for vars:   " << info.varnum << "\n"
       << "\tfree nodes:      " << info.freenodes << "\n" 
       << "\tused nodes:      " << info.nodenum - info.freenodes << "\n";

    if (dummy_offset > -1) {
      os << " Dummy from " << dummy_offset << " to "<< dummy_range<<"\n";
    }
  }

  forceinline void
  BMI::debug(void) {
    _debug = true;
  }

  forceinline int
  BMI::offset(void) const{
    assert(_offset <= bdd_varnum());
    return _offset;
  }

  forceinline void
  BMI::setmaxinc(int max) {
    int o = -1;
    o = bdd_setmaxincrease(max);
  }

} // end namespace CpltSet

  /**
   * \brief Manager for binary decision diagrams
   */
  class BddMgr : public SharedHandle {
  public:
    
    /// Default constructor
    BddMgr(void);
    /// Construct manager with initial nodesize \a n and cachesize \a c
    BddMgr(int n, int c);
    /// Copy constructor
    BddMgr(const BddMgr& m);
    /// Construct using manager implementation \a i
    BddMgr(CpltSet::BMI* i);

    /// Initialize manager with initial nodesize \a n and cachesize \a c.
    void init(int n, int c);
    /// Free the node table
    void dispose(void);

    /// Memory Management
    void setmaxinc(int max);
    /// Debugging Output
    void debug(std::ostream&);
    /// Checking buddy library status
    bool available(void);

    /// Show debugging output
    void debug(void);
    
    /// Return manager instance
    CpltSet::BMI* manager(void);
    /// Clear manager instance
    void clear(void);
  };
  
  forceinline
  BddMgr::BddMgr(void) {}

  forceinline
  BddMgr::BddMgr(int n, int c) { 
    object(new CpltSet::BMI(n,c));
  }
  
  forceinline
  BddMgr::BddMgr(const BddMgr& m) : SharedHandle(m) {}

  forceinline
  BddMgr::BddMgr(CpltSet::BMI* m) : SharedHandle(m){} 

  forceinline void
  BddMgr::init(int n, int c) { 
    if (object() == NULL) {
      object(new CpltSet::BMI(n, c));
    } else {
      if (!static_cast<CpltSet::BMI*>(object())->available()) {
        static_cast<CpltSet::BMI*>(object())->init(n,c); 
      } 
    }
  }

  forceinline void
  BddMgr::dispose(void) { 
    if (object() == NULL)
      throw BddMgrException("Trying disposal on empty manager");
    static_cast<CpltSet::BMI*>(object())->dispose();
  }

  forceinline void
  BddMgr::setmaxinc(int max) { 
    if (object() == NULL)
      throw BddMgrException("Trying setmaxinc on empty manager");
    static_cast<CpltSet::BMI*>(object())->setmaxinc(max); 
  }

  forceinline void 
  BddMgr::debug(std::ostream& out) {
    if (object() == NULL)
      throw BddMgrException("Trying debug on empty manager");
    static_cast<CpltSet::BMI*>(object())->debug(out);
  }

  forceinline bool
  BddMgr::available(void) {
    if (object() == NULL)
      throw BddMgrException("Trying available on empty manager");
    return static_cast<CpltSet::BMI*>(object())->available();
  }

  forceinline void 
  BddMgr::debug(void) {
    if (object() == NULL)
      throw BddMgrException("Trying to set debug on empty manager");
    static_cast<CpltSet::BMI*>(object())->debug();
  }

  forceinline CpltSet::BMI*
  BddMgr::manager(void) {
    return static_cast<CpltSet::BMI*>(object());
  }

  forceinline void
  BddMgr::clear(void) {
    object(NULL);
  }

}

// STATISTICS: cpltset-var
