/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Patrick Pekczynski <pekczynski@ps.uni-sb.de>
 *
 *  Copyright:
 *     Patrick Pekczynski, 2006
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  Permission is hereby granted, free of charge, to any person obtaining
 *  a copy of this software and associated documentation files (the
 *  "Software"), to deal in the Software without restriction, including
 *  without limitation the rights to use, copy, modify, merge, publish,
 *  distribute, sublicense, and/or sell copies of the Software, and to
 *  permit persons to whom the Software is furnished to do so, subject to
 *  the following conditions:
 *
 *  The above copyright notice and this permission notice shall be
 *  included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

namespace Gecode { 

  namespace CpltSet {

    /**
     * \brief %Bdd view for bdd set variables
     * \ingroup TaskActorSetView
     */

    class CpltSetView : public VariableViewBase<CpltSetVarImp> {
    protected:
      using VariableViewBase<CpltSetVarImp>::var;
    public:
      /// \name Constructors and initialization
      //@{
      /// Default constructor
      CpltSetView(void);
      /// Initialize from set variable \a x
      CpltSetView(const CpltSetVar& x);
      //@}

      /// \name Value access
      //@{
      /// Return minimum cardinality
      unsigned int cardMin(void) const;
      /// Return maximum cardinality
      unsigned int cardMax(void) const;
      /// Return minimum of the least upper bound
      int lubMin(void) const;
      /// Return maximum of the least upper bound
      int lubMax(void) const;
      /// Return n-th smallest element of the least upper bound
      int lubMinN(int n) const;
      /// Return the n-th largest element of the least upper bound
      int lubMaxN(int n) const;
      /// Return minimum of the greatest lower bound
      int glbMin(void) const;
      /// Return maximum of the greatest lower bound
      int glbMax(void) const;
      /// Return the number of elements in the greatest lower bound
      unsigned int glbSize(void) const;
      /// Return the number of elements in the least upper bound
      unsigned int lubSize(void) const;
      /// Return the number of unknown elements
      unsigned int unknownSize(void) const;
      //@}

      /// \name View information
      //@{
      /// Return the offset in the bdd table where bdd nodes for this view start.
      unsigned int offset(void) const;
      /// Return distance between minimum and maximum
      unsigned int table_width(void) const;
      /// Return size (cardinality) of the domain
      int size(void) const;
      /// Return the bdd at position i
      GecodeBdd getbdd(int i) const;    
      /// Return the negated bdd at position i
      GecodeBdd getnegbdd(int i) const;    
      /// Returns the variable placed at position \a i in the current variable order
      int getlevel(int i);    
      /// Returns the position of the variable \a i in the current variable order
      int getvar(int i);    
      /// Build the conjunction of \a d and the current view
      void dom_and(GecodeBdd& d);
      /// Build the disjunction of \a d and the current view
      void dom_or(GecodeBdd& d);
      /// Get a pointer to the current manager
      BMI* manager(void) const;

      /// Return the initial minimum of the variable
      int mgr_min(void) const; 
      /// Return the initial minimum of the variable
      int mgr_max(void) const; 
      /// Return the bdd representing the current domain
      GecodeBdd bdd_domain(void) const;
      /// Return the corresponding bdd table index for set element v in the bdd node representation.
      int valididx(int v) const;
      
      //@}

      /// \name Domain tests
      //@{
      /// Test whether view is assigned
      bool assigned(void) const;
      /// Test whether \a i is in the greatest lower bound
      bool contains(int i) const;
      /// Test whether \a i is not in the least upper bound
      bool notContains(int i) const;
      //@}


      /// \name Domain update by value
      //@{
      /** 
       * \brief Restrict cardinality to be greater than or equal to \a l
       *        and to be less than or equal to \a u.
       */
      ModEvent cardinality(Space* home, int l, int u);
      /// Restrict cardinality to be greater than or equal to \a m
      ModEvent cardMin(Space* home, unsigned int m);
      /// Restrict cardinality to be less than or equal to \a m
      ModEvent cardMax(Space* home, unsigned int m);

      /// Include all elements in range \f$[a..b]\f$ in greatest lower bound
      ModEvent include(Space* home, int i,int j);
      /// Include elements \a i in greatest lower bound
      ModEvent include(Space* home, int i); 

      /// Exclude all elements in range \f$[a..b]\f$ from least upper bound 
      ModEvent exclude(Space* home, int i,int j);
      /// Exclude element \a i from least upper bound 
      ModEvent exclude(Space* home, int i);

      /// Restrict domain values to be different from singleton set \f$ \{v\} \f$
      ModEvent nq(Space* home, int v);
      /// Restrict domain values to be different from set \f$ [a,b] \f$
      ModEvent nq(Space* home, int a, int b);

      /// Restrict domain to be equal to the singleton set \f$ \{v\} \f$
      ModEvent eq(Space* home, int v);
      /// Restrict domain to be equal to the set \f$ [a,b] \f$
      ModEvent eq(Space* home, int a, int b);
       
      /// Restrict least upper bound to contain at most all elements in the range \f$ [a,b] \f$
      ModEvent intersect(Space* home,int i,int j);
      /// Restrict least upper bound to contain at most the element \a i
      ModEvent intersect(Space* home,int i);

      /// Restrict domain values to be a solution to the logical formula described by the bdd \a d
      ModEvent tell_formula(Space* home, GecodeBdd& d);   
      //@}

      /// \name Domain update by range iterator
      //@{

      /// Remove range sequence described by \a i from least upper bound
      template <class I> ModEvent excludeI(Space* home, I& i);
      /// Include set described by range list \a i in greatest lower bound
      template <class I> ModEvent includeI(Space* home, I& i);  
      /// Intersect least upper bound with range sequence described by \a i
      template <class I> ModEvent intersectI(Space* home, I& iter);
      /// Restrict domain to be equal to the set described by the range sequence \a i
      template <class I> ModEvent eqI(Space* home, I& i);
      /// Restrict domain values to be different from set described by the range sequence \a i
      template <class I> ModEvent nqI(Space* home, I& i);
      //@}

      /// \name Cloning
      //@{
      /// Update this view to be a clone of view \a x
      void update(Space* home, bool share, CpltSetView& x);
      //@}

      /// \name Serialization
      //@{
      /// Return specification for this view, using variable map \a m
      Reflection::Arg*  spec(Space* home, Reflection::VarMap& m);
      static Support::Symbol type(void);
      //@}


      /// Debug output
      void viewdot(void) const;
    };

  }
  /**
   * \brief Traits class for views and variable implementations
   *
   * This class specializes the ViewVarTraits for CpltSetView.
   * \ingroup TaskActorCpltSetView
   */
  template<>
  class ViewVarTraits<CpltSet::CpltSetView> {
  public:
    /// The variable type of a CpltSetView
    typedef CpltSet::CpltSetVarImp Var;
  };

  namespace CpltSet {
    /**
     * \brief Singleton Bdd View
     *
     * A bnd bdd view \f$s\f$ for a bdd view \f$x\f$ and
     * a bdd \f$r\f$ provides operations such that 
     * \f$dom(s) = conv(dom(x))\f$.
     * \ingroup TaskActorCpltSetView
     */

    class SingletonCpltSetView : public DerivedViewBase<Gecode::Int::IntView> {
    protected:
      using DerivedViewBase<Gecode::Int::IntView>::view;
      BMI* mgr;
      int min;
      int max;
      unsigned int range;
      unsigned int _offset;     
      GecodeBdd domain;
      /// Convert bdd variable PropCond \a pc to a PropCond for integer variables
      static PropCond pc_bddtoint(PropCond pc);
      /// Convert integer variable ModEvent \a me to a ModEvent for bdd variables
      static ModEvent me_inttobdd(ModEvent me);
    public:
      /// \name Constructors and initialization
      //@{
      /// Default constructor
      SingletonCpltSetView(void);
      /// Initialize from IntView \a x
      SingletonCpltSetView(BMI* manager, int min, int max, const Gecode::Int::IntView& x);
      /// Initialize from IntView \a x
      void init(BMI* manager, int min, int max, const Gecode::Int::IntView& x);
      //@}
      /// \name Destructor
      //@{
      /// Destructor for disposal of temporary domain bdd and boolean vector
      ~SingletonCpltSetView(void);
      //@}

      /// \name Value access
      //@{
      /// Return minimum cardinality
      unsigned int cardMin(void) const;
      /// Return maximum cardinality
      unsigned int cardMax(void) const;
      /// Return minimum of the least upper bound
      int lubMin(void) const;
      /// Return maximum of the least upper bound
      int lubMax(void) const;
      /// Return minimum of the greatest lower bound
      int glbMin(void) const;
      /// Return maximum of the greatest lower bound
      int glbMax(void) const;
      /// Return the number of elements in the greatest lower bound
      unsigned int glbSize(void) const;
      /// Return the number of elements in the least upper bound
      unsigned int lubSize(void) const;
      /// Return the number of unknown elements
      unsigned int unknownSize(void) const;
      //@}

      /// \name View information
      //@{
      /// Return the offset in the bdd table where bdd nodes for this view start.
      unsigned int offset(void) const;
      /// Return distance between minimum and maximum
      unsigned int table_width(void) const;
      /// Return size (cardinality) of the domain
      int size(void) const;
      /// Return the bdd at position i
      GecodeBdd getbdd(int i) const;    
      /// Return the negated bdd at position i
      GecodeBdd getnegbdd(int i) const;    
      /// Returns the variable placed at position \a i in the current variable order
      int getlevel(int i);    
      /// Returns the position of the variable \a i in the current variable order
      int getvar(int i);    
      /// Build the conjunction of \a d and the current view
      void dom_and(GecodeBdd& d);
      /// Build the disjunction of \a d and the current view
      void dom_or(GecodeBdd& d);
      /// Get a pointer to the current manager
      BMI* manager(void) const;
      
      /// Return the initial minimum of the variable
      int mgr_min(void) const; 
      /// Return the initial minimum of the variable
      int mgr_max(void) const; 
      /// Return the corresponding bdd table index for set element v in the bdd node representation.
      int valididx(int v) const;

      /// Return the bdd representing the current domain
      GecodeBdd bdd_domain(void) const;
      /// Return the bdd representing the unfixed part of the variable domain
      GecodeBdd bdd_remain(void) const;
      /// Return the bdd representing the fixed part of the variable domain
      GecodeBdd bdd_bounds(void) const;

      //@}

      /// \name Domain tests
      //@{
      /// Test whether view is assigned
      bool assigned(void) const;
      /// Test whether \a i is in the greatest lower bound
      bool contains(int i) const;
      /// Test whether \a i is not in the least upper bound
      bool notContains(int i) const;

      //@}

      /// \name Domain update by value
      //@{
      /** 
       * \brief Restrict cardinality to be greater than or equal to \a l
       *        and to be less than or equal to \a u.
       */
      ModEvent cardinality(Space* home, unsigned int l, unsigned int u);
      /// Restrict cardinality to be greater than or equal to \a m
      ModEvent cardMin(Space* home, unsigned int m);
      /// Restrict cardinality to be less than or equal to \a m
      ModEvent cardMax(Space* home, unsigned int m);

      /// Include all elements in range \f$[a..b]\f$ in greatest lower bound
      ModEvent include(Space* home, int i,int j);
      /// Include elements \a i in greatest lower bound
      ModEvent include(Space* home, int i); 

      /// Exclude all elements in range \f$[a..b]\f$ from least upper bound 
      ModEvent exclude(Space* home, int i,int j);
      /// Exclude element \a i from least upper bound 
      ModEvent exclude(Space* home, int i);

      /// Restrict domain values to be different from singleton set \f$ \{v\} \f$
      ModEvent nq(Space* home, int v);
      /// Restrict domain values to be different from set \f$ [a,b] \f$
      ModEvent nq(Space* home, int a, int b);

      /// Restrict domain to be equal to the singleton set \f$ \{v\} \f$
      ModEvent eq(Space* home, int v);
      /// Restrict domain to be equal to the set \f$ [a,b] \f$
      ModEvent eq(Space* home, int a, int b);
   
      /// Restrict domain values to be a solution to the logical formula described by the bdd \a d
      ModEvent tell_formula(Space* home, GecodeBdd& d);   

      /// Restrict least upper bound to contain at most all elements in the range \f$ [a,b] \f$
      ModEvent intersect(Space* home,int i,int j);
      /// Restrict least upper bound to contain at most the element \a i
      ModEvent intersect(Space* home,int i);
      //@}

      /// \name Domain update by range iterator
      //@{
      /// Remove range sequence described by \a i from least upper bound
      template <class I> ModEvent excludeI(Space* home, I& i);
      /// Include set described by range list \a i in greatest lower bound
      template <class I> ModEvent includeI(Space* home, I& i);  
      /// Intersect least upper bound with range sequence described by \a i
      template <class I> ModEvent intersectI(Space* home, I& iter);
      /// Restrict domain to be equal to the set described by the range sequence \a i
      template <class I> ModEvent eqI(Space* home, I& i);
      /// Restrict domain values to be different from set described by the range sequence \a i
      template <class I> ModEvent nqI(Space* home, I& i);
      //@}

      /// \name Propagator modification events
      //@{
      /// Return modification event of propagator \a p for view
      static ModEvent     pme(const Propagator* p);
      /// Translate modification event \a me to propagator modification event for view
      static PropModEvent pme(ModEvent);
      //@}

      /// \name Dependencies
      //@{
      /**
       * \brief Subscribe propagator \a p with propagation condition \a pc to variable
       *
       * In case \a process is false, the propagator is just subscribed but
       * not processed for execution (this must be used when creating
       * subscriptions during propagation).
       */
      void subscribe(Space* home, Propagator* p, PropCond pc, bool process=true);
      /// Cancel subscription of propagator \a p with propagation condition \a pc to view
      void cancel(Space* home, Propagator* p, PropCond pc);
      //@}

      /// \name Cloning
      //@{
      /// Update this view to be a clone of view \a x
      void update(Space* home, bool share, SingletonCpltSetView& x);
      //@}

      /// \name Serialization
      //@{
      /// Return specification for this view, using variable map \a m
      Reflection::Arg* spec(Space* home, Reflection::VarMap& m);
      static Support::Symbol type(void);
      //@}

      /// Debug output
      void viewdot(void) const;
    };


  }

  /** \name View comparison
   *  \relates Gecode::CpltSet::SingletonCpltSetView
   */
  //@{
  /// Test whether views \a x and \a y are the same
  bool same(const CpltSet::SingletonCpltSetView& x, const CpltSet::SingletonCpltSetView& y);
  /// Test whether view \a x comes before \a y (arbitrary order)
  bool before(const CpltSet::SingletonCpltSetView& x, const CpltSet::SingletonCpltSetView& y);
  //@}


  /**
   * \brief Traits class for views and variable implementations
   *
   * This class specializes the ViewVarTraits for SingletonCpltSetView.
   * \ingroup TaskActorSingletonCpltSetView
   */
  template<>
  class ViewVarTraits<CpltSet::SingletonCpltSetView> {
  public:
    /// The variable type of a SingletonCpltSetView
    typedef VarBase Var;
  };

}

#include "gecode/cpltset/view/cpltset.icc"
#include "gecode/cpltset/view/singleton.icc"

/**
 * \brief Print set variable view
 * \relates Gecode::CpltSet::CpltSetView
 */
GECODE_CPLTSET_EXPORT std::ostream&
operator<<(std::ostream&, const Gecode::CpltSet::CpltSetView& x);

/**
 * \brief Print set variable view
 * \relates Gecode::CpltSet::SingletonCpltSetView
 */
GECODE_CPLTSET_EXPORT std::ostream&
operator<<(std::ostream&, const Gecode::CpltSet::SingletonCpltSetView& x);


// STATISTICS: cpltset-var
