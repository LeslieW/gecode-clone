/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Patrick Pekczynski <pekczynski@ps.uni-sb.de>
 *
 *  Copyright:
 *     Patrick Pekczynski, 2006
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

using namespace Gecode::CpltSet;

namespace Gecode {


  template <class View>
  void build_partition(ViewArray<View>& x, GecodeBdd& d0) {
    // make it more readable
    typedef Set::LubRanges<View> SetLub;
    namespace IR = Iter::Ranges;

    // disjoint
    int n = x.size();
    for (int i = 0; i < n - 1; i++) {
      for (int j = i + 1; j < n; j++) {
        SetLub lubx(x[i]);
        SetLub luby(x[j]);
        IR::Inter<SetLub, SetLub> inter(lubx, luby);
        IR::ToValues<IR::Inter<SetLub, SetLub> > values(inter);
        IR::ValCache<IR::ToValues<IR::Inter<SetLub, SetLub> > > cache(values);
            
        for (cache.last(); cache(); --cache) {
          int ximin = x[i].mgr_min();
          int xjmin = x[j].mgr_min();
          int v = cache.min();
          d0 &= !(x[i].getbdd(v - ximin) & x[j].getbdd(v - xjmin));
        }
      }
    }

    unsigned int xtab = x[0].table_width();  
    for (int i = n; i--;) {
      if (x[i].table_width() > xtab)
        xtab = x[i].table_width();
    }

    // just state that the union of all sets is us
    // iff all the variables have the same initial minimum and maximum
    for (unsigned int k = 0; k < xtab; k++) {
      GecodeBdd c0 = BDDBOT;
      for (int i = 0; i < n; i++) {
        if (k < x[i].table_width())
          c0 |= x[i].getbdd(k);
      }
      d0 &= (c0  % BDDTOP);
    }
  }

  template <class View>
  void build_partition(ViewArray<View>& x, View& y, GecodeBdd& d0) {
    // make it more readable
    typedef Set::LubRanges<View> SetLub;
    namespace IR = Iter::Ranges;

    // disjoint
    int n = x.size();
    for (int i = 0; i < n - 1; i++) {
      for (int j = i + 1; j < n; j++) {
        SetLub lubx(x[i]);
        SetLub luby(x[j]);
        IR::Inter<SetLub, SetLub> inter(lubx, luby);
        IR::ToValues<IR::Inter<SetLub, SetLub> > values(inter);
        IR::ValCache<IR::ToValues<IR::Inter<SetLub, SetLub> > > cache(values);
            
        for (cache.last(); cache(); --cache) {
          int ximin = x[i].mgr_min();
          int xjmin = x[j].mgr_min();
          int v = cache.min();
          d0 &= !(x[i].getbdd(v - ximin) & x[j].getbdd(v - xjmin));
        }
      }
    }

    unsigned int ytab = y.table_width();
    int ymin = y.mgr_min();
    for (unsigned int k = 0; k < ytab; k++) {
      GecodeBdd c0 = BDDBOT;
      for (int i = 0; i < n; i++) {
        int xmin = x[i].mgr_min();
        int xmax = x[i].mgr_max();
        int shift = std::max(ymin, xmin) - std::min(xmin, ymin);
        if (xmin <= ymin + (int) k && ymin + (int) k <= xmax) {
          c0 |= x[i].getbdd(k - shift);
        }
      }
      d0 &= (c0  % y.getbdd(k));
    }

  }

  template <class View0, class View1>
  void build_partition(ViewArray<View0>& x, View1& y, GecodeBdd& d0) {
    // make it more readable
    typedef Set::LubRanges<View0> SetLub;
    namespace IR = Iter::Ranges;
    // std::cerr << "build partition\n";
    // disjoint
    int n = x.size();
    for (int i = 0; i < n - 1; i++) {
      for (int j = i + 1; j < n; j++) {
        SetLub lubx(x[i]);
        SetLub luby(x[j]);
        IR::Inter<SetLub, SetLub> inter(lubx, luby);
        IR::ToValues<IR::Inter<SetLub, SetLub> > values(inter);
        IR::ValCache<IR::ToValues<IR::Inter<SetLub, SetLub> > > cache(values);
            
        for (cache.last(); cache(); --cache) {
          int ximin = x[i].mgr_min();
          int xjmin = x[j].mgr_min();
          int v = cache.min();
          d0 &= !(x[i].getbdd(v - ximin) & x[j].getbdd(v - xjmin));
        }
      }
    }

    unsigned int ytab = y.table_width();
    int ymin = y.mgr_min();
    // std::cerr << "y:\t"; 
    // std::cerr << y << " " << y.mgr_min() << ".." << y.mgr_max() << "\n";
    // std::cerr << y.offset() << " " <<y.table_width() << "\n";
    // std::cerr << "check union\n";
    for (unsigned int k = 0; k < ytab; k++) {
      // std::cerr << "k=" << k<< " ";
      GecodeBdd c0 = BDDBOT;
      for (int i = 0; i < n; i++) {
        // std::cerr << "i=" << i << " " << x[i];
        // std::cerr << " " << x[i].offset() << " " << x[i].table_width() << "\n";
        int xmin = x[i].mgr_min();
        int xmax = x[i].mgr_max();
        int shift = std::max(ymin, xmin) - std::min(xmin, ymin);
        // std::cerr << " check\t" << xmin << ".." << xmax << " " << ymin << "\n";
        if (xmin <= ymin + (int) k && ymin + (int) k <= xmax) {
          // std::cerr << "in\n";
          c0 |= x[i].getbdd(k - shift);
        }
      }
      // std::cerr << "d0 and\n";
      d0 &= (c0  % y.getbdd(k));
    }
  }

  template <class View>
  void build_lexorder(ViewArray<View>& x, GecodeBdd& d0, CpltSetRelType lex) {

    int n = x.size();
    unsigned int xtab = x[0].table_width();  
    BMI* mgr = x[0].manager();

    for (int i = n; i--;) 
      if (x[i].table_width() > xtab)
        xtab = x[i].table_width();

    // std::cerr << "with lex \n";
    for (int i = 0; i < n - 1; i++) {
      for (int j = i + 1; j < n; j++) {
        unsigned int xai_off = x[i].offset();
        unsigned int xaj_off = x[j].offset();
        switch (lex) {
        case SRT_LE: 
          {
            d0 &= lexlt(mgr, xai_off, xaj_off, xtab, xtab - 1);
            break;
          }
        case SRT_GR: 
          {
            d0 &= lexlt(mgr, xaj_off, xai_off, xtab, xtab - 1);
            break;
          }
        case SRT_LQ: 
          {
            d0 &= lexlq(mgr, xai_off, xaj_off, xtab, xtab - 1);
            break;
          }
        case SRT_GQ: 
          {
            d0 &= lexlq(mgr, xaj_off, xai_off, xtab, xtab - 1);
            break;
          }
        case SRT_LE_REV: 
          {
            d0 &= lexltrev(mgr, xai_off, xaj_off, xtab, 0);
            break;
          }
        case SRT_GR_REV: 
          {
            d0 &= lexltrev(mgr, xaj_off, xai_off, xtab, 0);
            break;
          }
        case SRT_LQ_REV: 
          {
            d0 &= lexlqrev(mgr, xai_off, xaj_off, xtab, 0);
            break;
          }
        case SRT_GQ_REV: 
          {
            d0 &= lexlqrev(mgr, xaj_off, xai_off, xtab, 0);
            break;
          }
        default:
          {
            throw CpltSet::InvalidRelation(" partition rel not yet implemented ");
            break;
          }
        }
      }
    }
  }

  template <class View>
  void partition_post(Space* home, ViewArray<View>& x, bool withlex, 
                      CpltSetRelType lex, bool withcard, int d, 
                      SetConLevel scl) {

    if (home->failed()) return;

    BMI* mgr = x[0].manager();
    int n = x.size();
   
    GecodeBdd d0 = BDDTOP;     
    build_partition(x, d0);

    // forall i: x_{i - 1} \prec_{lex_{bit}} x_i
    if (withlex) 
      build_lexorder(x, d0, lex);

    if (withcard) {
      for (int i = n; i--; ) {
        unsigned int off   = x[i].offset();
        unsigned int range = x[i].table_width();
        d0 &= cardcheck(mgr, range, off, d, d);
      }
    }

    // std::cerr << "start propagation\n";
    GECODE_ES_FAIL(home, NaryBddProp<View>::post(home, x, d0, scl));
  }

  template <class View>
  void partition_post(Space* home, ViewArray<View>& x, View& y, 
                      bool withlex, SetRelType lex, 
                      bool withcard, int d, 
                      SetConLevel scl) {
    if (home->failed()) return;

    int n = x.size();
   
    GecodeBdd d0 = BDDTOP;     
    build_partition(x, y, d0);

    ViewArray<View> naryone(home, x.size() + 1);
    for (int i = 0; i < n; i++) 
      naryone[i] = x[i]; 
    naryone[n] = y;

    GECODE_ES_FAIL(home, NaryBddProp<View>::post(home, naryone, d0, scl));
  }

  template <class View0, class View1>
  void partition_post(Space* home, ViewArray<View0>& x, View1& y, 
                      bool withlex, SetRelType lex, 
                      bool withcard, int d, 
                      SetConLevel scl) {
    if (home->failed()) return;

    GecodeBdd d0 = BDDTOP;     
    build_partition(x, y, d0);

    GECODE_ES_FAIL(home, (NaryOneBdd<View0, View1>::post(home, x, y, d0)));
  }

  template <class View>
  void partition_post(Space* home, ViewArray<View>& x, bool withlex, 
                      SetRelType lex, bool withcard, int d, 
                      SetConLevel scl) {
    // std::cerr << "partition_post()" << "\n";
    if (home->failed()) return;

    int n = x.size();
    BMI* mgr = x[0].manager();

    int minx = x[0].mgr_min();
    int maxx = x[0].mgr_max(); 
    unsigned int xtab = x[0].table_width();  
    for (int i = n; i--;) {
      if (x[i].mgr_min() < minx) {
        minx = x[i].mgr_min();
      }
      if (x[i].mgr_max() > maxx) {
        maxx = x[i].mgr_max();
      }
      if (x[i].table_width() > xtab) {
        xtab = x[i].table_width();
      }
    }
    
    // build partition
    GecodeBdd d0 = BDDTOP;     

    // Guidos formula of disjointness does not need
    // dummy variables quite nice

    // NOTE do only & over variables in the intersection !!

    // std::cerr << "start disjointness" << "\n";
    // std::cerr << "k=" << k << " ";
      for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
          // std::cerr << "x["<< i <<"]=" << x[i] << "\n";
          // std::cerr << "y["<< j <<"]=" << x[j] << "\n";
          Set::LubRanges<View> lubx(x[i]);
          Set::LubRanges<View> luby(x[j]);
          Gecode::Iter::Ranges::Inter<Set::LubRanges<View>, Set::LubRanges<View> >
            inter(lubx, luby);
          Gecode::Iter::Ranges::ToValues<
            Gecode::Iter::Ranges::Inter<Set::LubRanges<View>, Set::LubRanges<View> >
            > values(inter);
          Gecode::Iter::Ranges::ValCache<
            Gecode::Iter::Ranges::ToValues<
                Gecode::Iter::Ranges::Inter<Set::LubRanges<View>, Set::LubRanges<View> >
            >
            > cache(values);
            
          cache.last();
          for (; cache(); --cache) {
            int ximin = x[i].mgr_min();
            int xjmin = x[j].mgr_min();
            int v = cache.min();
            d0 &= !(x[i].getbdd(v - ximin) & x[j].getbdd(v - xjmin));
          }
          
        }
        //std::cerr << "\n";
      }
      
      // no lex ordering

      // just state that the union of all sets is us
      // std::cerr << "union of all ";
      for (unsigned int k = 0; k < xtab; k++) {
      // std::cerr << "k=" << k << " ";
        GecodeBdd c0 = BDDBOT;
        for (int i = 0; i < n; i++) {
          if (k < x[i].table_width()) {
            c0 |= x[i].getbdd(k);
          }
        }
        d0 &= (c0  % BDDTOP);
      }
      // std::cerr << "\n";
      
      if (withcard) {
        // std::cerr << "with card";
        for (int i = n; i--; ) {
          // std::cerr << "card= " << i << "\n";
          unsigned int off   = x[i].offset();
          unsigned int range = x[i].table_width();
          d0 &= cardcheck(mgr, range, off, d, d);
        }
      }
      
      // std::cerr << "start propagation\n";
      GECODE_ES_FAIL(home, NaryBddProp<View>::post(home, x, d0, scl));
  }

  template <class Rel>
  forceinline void 
  partition_con(Space* home, const CpltSetVarArgs& x, bool withlex, Rel lex, 
                bool withcard, int d, SetConLevel scl) {
    ViewArray<CpltSetView> bv(home, x);
    switch(scl) {
    case SCL_SPL:
      {
        int n = bv.size();
        ViewArray<SplitCpltSetView> sv(home, n);
        for (int i = n; i--; ) {
          sv[i].init(bv[i]);
        }
        partition_post(home, sv, withlex, lex, withcard, d, scl);
        break;
      }
    case SCL_BND_BDD:
      {
        int n = bv.size();
        ViewArray<BndCpltSetView> bndv(home, n);
        for (int i = n; i--; ) {
          bndv[i].init(bv[i]);
        }
        partition_post(home, bndv, withlex, lex, withcard, d, scl);
        break;
      }
    case SCL_CRD:
      {
        int n = bv.size();
        ViewArray<CrdCpltSetView> crdv(home, n);
        for (int i = n; i--; ) {
          crdv[i].init(bv[i]);
        }
        partition_post(home, crdv, withlex, lex, withcard, d, scl);
        break;
      }
    case SCL_LEX:
      {
        int n = bv.size();
        ViewArray<LexCpltSetView> lexv(home, n);
        for (int i = n; i--; ) {
          lexv[i].init(bv[i]);
        }
        partition_post(home, lexv, withlex, lex, withcard, d, scl);
        break;
      }
    default:
      {
        partition_post(home, bv, withlex, lex, withcard, d, scl);
      }
    }
  }

  // For testing purposes only supported for bddviews
  template <class Rel>
  forceinline void 
  partition_con(Space* home, const CpltSetVarArgs& x, const CpltSetVar& y, 
                bool withlex, Rel lex, bool withcard, int d, 
                SetConLevel scl) {

    ViewArray<CpltSetView> bv(home, x);
    CpltSetView yv(y);
    partition_post(home, bv, yv, withlex, lex, withcard, d, scl);
  }

  // For testing purposes only supported for bddviews
  template <class Rel>
  forceinline void 
  partition_con(Space* home, const IntVarArgs& x, const CpltSetVar& y, 
                bool withlex, Rel lex, bool withcard, int d, 
                SetConLevel scl) {

    BMI* mgr = y.manager();
    ViewArray<Int::IntView> bv(home, x);
    int n = x.size();
    ViewArray<SingletonCpltSetView> sv(home, n);
    for (int i = 0; i < n; i++) {
      sv[i].init(mgr, bv[i].min(), bv[i].max(), bv[i]);
    }
//     std::cerr << "partition_con with intvars\n";
//     // add first shot on ordering the intvars
//     for (int i = 0; i < n; i++) 
//       std::cerr << x[i] << " ";
//     std::cerr << "\n";
//     variableorder(sv);

    CpltSetView yv(y);
    // this wont work as there is no post function for different views
    // i.e. bddsingleton + bddview
    
    partition_post(home, sv, yv, withlex, lex, withcard, d, scl);
  }

}

// STATISTICS: bdd-post
