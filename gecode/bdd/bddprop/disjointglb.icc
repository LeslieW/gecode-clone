/*
 *  Main authors:
 *     Patrick Pekczynski <pekczynski@ps.uni-sb.de>
 *
 *  Copyright:
 *     Patrick Pekczynski, 2006
 *
 *  Last modified:
 *     $Date: 2006-09-04 19:25:19 +0000 (Mon, 04 Sep 2006) $ by $Author: pekczynski $
 *     $Revision: 3585 $
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

namespace Gecode { namespace Bdd {

  template <class View>
  forceinline
  DisjointGlb<View>::DisjointGlb(Space* home, ViewArray<View>& x0, int& index) 
    : Propagator(home), x(x0), idx(index) {
    force(home);
    int n = x.size();
    for (int i = n; i--; ) 
      x[i].subscribe(home, this, PC_BDD_DOM);
  }
  
  template <class View>
  forceinline
  DisjointGlb<View>::DisjointGlb(Space* home, bool share, DisjointGlb& p)
    : Propagator(home,share,p), idx(p.idx) {
    x.update(home, share, p.x);
  }
  
  template <class View>
  forceinline PropCost
  DisjointGlb<View>::cost(void) const {
    return PC_LINEAR_HI;
  }

  template <class View>
  const char*
  DisjointGlb<View>::name(void) const {
    return "bdd.bddprop.DisjointGlb";
  }
  
  template <class View>
  size_t
  DisjointGlb<View>::dispose(Space* home) {
    unforce(home);
    if (!home->failed()) {
      int n = x.size();
      for (int i = n; i--; ) 
	x[i].cancel(home, this, PC_BDD_DOM);
    }
    Propagator::dispose(home);
    return sizeof(*this);
  }

  template <class View>
  forceinline ExecStatus
  DisjointGlb<View>::post(Space* home, ViewArray<View>& x0, int& index) {
    (void) new (home) DisjointGlb(home, x0, index);
    return ES_OK;
  }

  template <class View>
  forceinline Actor*
  DisjointGlb<View>::copy(Space* home, bool share) {
    return new (home) DisjointGlb(home, share, *this);
  }

  template <class View>
  forceinline ExecStatus 
  DisjointGlb<View>::propagate(Space* home) {

    // std::cerr << "propagate: disjoint GLB\t";
    // std::cerr << x[idx] << "\n";
    int n = x.size();
    bool subsumed = true;
    int c = n - 1;
    // std::cerr << "p: " << idx <<": ";
    for (int i = n; i--; c--) {
      if (i != idx) {
	// std::cerr << i << ",";

// 	Set::GlbRanges<View> glbtest(x[i]);

// 	std::cerr << "testglb: ";
// 	while (glbtest()) {
// 	  std::cerr << glbtest.min() << ".." << glbtest.max() << ",";
// 	  ++glbtest;
// 	}
// 	std::cerr << "\n";
	
	Set::LubRanges<View> lub(x[i]);
	Set::LubRanges<View> lubidx(x[idx]);
	Gecode::Iter::Ranges::Inter<Set::LubRanges<View>, Set::LubRanges<View> > interlub(lub, lubidx);
	subsumed &= !interlub();

	Set::GlbRanges<View> glb(x[i]);
	if (glb()) {
	  // std::cerr << "GLB: ";
	  Set::LubRanges<View> lubx(x[idx]);
	  Gecode::Iter::Ranges::Inter<Set::GlbRanges<View>, Set::LubRanges<View> > inter(glb, lubx);
	  ModEvent me = x[idx].excludeI(home, inter);
	  GECODE_ME_CHECK(me);
	  // std::cerr << "ME=" << me << " ";
	  subsumed &= (me == ME_BDD_NONE);
	} // else {
// 	  std::cerr << "NOGLB: ";
// 	}
      }
      // std::cerr << "SUBS ?" <<  subsumed << " c=" << c << "\n";
    }

    //std::cerr << x[idx] << " end propagation\n";
    // std::cerr <<" end propagation\n";
    if (subsumed && (c == 0)) {
      // std::cerr << "SUBS!\n";
      return ES_SUBSUMED(this, home);
    }
    return ES_FIX;
  }


  template <class View>
  forceinline
  DisjointSudoku<View>::DisjointSudoku(Space* home, View& x0, int& ord) 
    : Propagator(home), x(x0), order(ord) {
    force(home);
    x.subscribe(home, this, PC_BDD_DOM);
  }
  
  template <class View>
  forceinline
  DisjointSudoku<View>::DisjointSudoku(Space* home, bool share, DisjointSudoku& p)
    : Propagator(home,share,p), order(p.order) {
    x.update(home, share, p.x);
  }
  
  template <class View>
  forceinline PropCost
  DisjointSudoku<View>::cost(void) const {
    return PC_UNARY_HI;
  }

  template <class View>
  const char*
  DisjointSudoku<View>::name(void) const {
    return "bdd.bddprop.DisjointSudoku";
  }
  
  template <class View>
  size_t
  DisjointSudoku<View>::dispose(Space* home) {
    unforce(home);
    if (!home->failed()) {
      x.cancel(home, this, PC_BDD_DOM);
    }
    Propagator::dispose(home);
    return sizeof(*this);
  }

  template <class View>
  forceinline ExecStatus
  DisjointSudoku<View>::post(Space* home, View& x0, int& ord) {
    (void) new (home) DisjointSudoku(home, x0, ord);
    return ES_OK;
  }

  template <class View>
  forceinline Actor*
  DisjointSudoku<View>::copy(Space* home, bool share) {
    return new (home) DisjointSudoku(home, share, *this);
  }

  template <class View>
  forceinline ExecStatus 
  DisjointSudoku<View>::propagate(Space* home) {
    // std::cerr << "propagate DISJOINT GLB\t";
    if (x.assigned()) {
      // intended to be used in sudoku
      // so just return subsumption
      // std::cerr << "SUBSUMED-ASSIGNED\t";
      return ES_SUBSUMED(this, home);
    } else {

      int s = order * order;
      // IntSet exclude = IntSet::empty;

      // the number of values to exclude equals 
      // |glb| * 3 * (s - 1) - | overlapping elements |

      Support::DynamicArray<int> da(x.glbSize() * 3 * s);
      int cda = 0;

      GlbValues<View> glb(x);
      while (glb()) {
	int v = glb.val();
	// row shall denote the number of complete rows before the current entry
	int row = v / s;
	int col = v % s;

	// value falls in the last column
	if (col == 0) {
	  row--;
	  col = s;
	}
	
	// std::cerr << "v=" << v << " at " << row << "," << col << "\n";
	
	// clear row
	// std::cerr << "clear row exclude: ";
	for (int k = 0; k < s; k++) {
	  if (k + 1 != col) {
	    int val = (row * s) + k + 1;
	    // std::cerr << val << ",";

	    // 	    IntSetRanges ir(exclude);
	    // 	    Iter::Ranges::Singleton vr(val, val);
	    // 	    Iter::Ranges::Union<IntSetRanges, Iter::Ranges::Singleton> u(ir, vr);
	    // 	    IntSet newset(u);
	    // 	    exclude.update(false, newset);

 	    da[cda] = val;
 	    cda++;

	    // 	    ModEvent me = x.exclude(home, val);
	    // 	    GECODE_ME_CHECK(me);
	  }
	}
	
// 	std::cerr << "exclude row....";
// 	IntSet isexrow(exrow, crow);
// 	IntSetRanges irr(isexrow);
// 	ModEvent merow = x.excludeI(home, irr);
// 	GECODE_ME_CHECK(merow);
// 	std::cerr << "done!\n";
// 	std::cerr << "\n";

	//	std::cerr << "results in " << x << "\n";

	// clear col

	// std::cerr << "clear col exclude: ";
	for (int k = 0; k < s; k++) {
	  if (k != row) {
	    int val = (k * s) + col;
	    // std::cerr << val << ",";

	    da[cda] = val;
	    cda++;

	    // 	    IntSetRanges ir(exclude);
	    // 	    Iter::Ranges::Singleton vr(val, val);
	    // 	    Iter::Ranges::Union<IntSetRanges, Iter::Ranges::Singleton> u(ir, vr);
	    // 	    IntSet newset(u);
	    // 	    exclude.update(false, newset);

	    // 	    ModEvent me = x.exclude(home, val);
	    // 	    GECODE_ME_CHECK(me);
	  }
	}
	// std::cerr << "\n";

// 	std::cerr << "exclude col....";
// 	IntSet isexcol(excol, ccol);
// 	IntSetRanges irc(isexcol);
// 	ModEvent mecol = x.excludeI(home, irc);
// 	GECODE_ME_CHECK(mecol);
// 	std::cerr << "done!\n";
// 	std::cerr << "\n";

	//	std::cerr << "results in " << x << "\n";

	// clear block
	// std::cerr << "clear block\n";
// 	GECODE_AUTOARRAY(int, exblock, s - 1);
// 	int cblock = 0;
	int lob = row / order; // counted lines of  order * order blocks
	int cob = col / order; // counted columns of order * order  blocks
	// std::cerr << "lob= " << lob << " and cob = " << cob << "\n";

	if ( (col % order) == 0) cob--;
	// std::cerr << "lob= " << lob << " and cob = " << cob << "\n";

	// std::cerr << "exclude: ";
	for (int i = 0; i < order; i++) {
	  for (int j = 0; j < order; j++) {
	    int val =  (lob * order + i)  * s + cob * order + j + 1;
	    int cur = row * s + col;
	    if (val != cur) {
	      // std::cerr << val<< ",";

// 	      exblock[cblock] = val;
// 	      cblock++;
	      
 	      da[cda] = val;
 	      cda++;

	      // 	      IntSetRanges ir(exclude);
	      // 	      Iter::Ranges::Singleton vr(val, val);
	      // 	      Iter::Ranges::Union<IntSetRanges, Iter::Ranges::Singleton> u(ir, vr);
	      // 	      IntSet newset(u);
	      // 	      exclude.update(false, newset);

	      // 	      ModEvent me = x.exclude(home, val);
	      // 	      GECODE_ME_CHECK(me);
	    }
	  }
	}
	// std::cerr << "\n";
	//	std::cerr << "results in " << x << "\n";
	++glb;


// 	std::cerr << "exclude block....";
// 	IntSet isexblock(exblock, cblock);
// 	IntSetRanges irb(isexblock);
// 	ModEvent meblock = x.excludeI(home, irb);
// 	GECODE_ME_CHECK(meblock);
// 	std::cerr << "done!\n";
// 	std::cerr << "\n";
      }

      IntSet exclude(da, cda);
      
      // std::cerr << "exclude " << exclude << "\n";
      // std::cerr << "from: " << x << "\n";
      Set::UnknownRanges<BddView> delta(x);
      IntSetRanges ir(exclude);
      Iter::Ranges::Inter<Set::UnknownRanges<BddView>, IntSetRanges> exclr(delta, ir);

//       Iter::Ranges::Cache<Iter::Ranges::Inter<Set::UnknownRanges<BddView>, IntSetRanges> > ca(exclr);
//       std::cerr << "cache excl: ";
//       if (!ca()) std::cerr << "empty\n";
//       for (; ca(); ++ca) {
// 	std::cerr << ca.min() << ".." << ca.max() << ",";
//       }
//       std::cerr << "\n";
//       ca.reset();

      if (!exclr()) {
	// std::cerr << "is SUBSUMED\n";
 	return ES_SUBSUMED(this, home);
      } else {
 	ModEvent me = x.excludeI(home, exclr);
 	GECODE_ME_CHECK(me);
      }
      
//       std::cerr << "\n";
//       std::cerr << "results in " << x << "\n";
   
      return ES_FIX;
    }
  }


}}

  // STATISTICS: bdd-prop
