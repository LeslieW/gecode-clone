/*
 *  Main authors:
 *     Guido Tack <tack@gecode.org>
 *
 *  Contributing authors:
 *     Christian Schulte <schulte@gecode.org>
 *
 *  Copyright:
 *     Guido Tack, 2004
 *     Christian Schulte, 2004
 *
 *  Last modified:
 *     $Date: 2006-08-31 15:10:50 +0000 (Thu, 31 Aug 2006) $ by $Author: pekczynski $
 *     $Revision: 3578 $
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

namespace Gecode { 

  namespace Bdd {

    // Unfortunately using an IntView as BddView
    // requires us to allocate boolean bdd nodes in the manager
    // note that these nodes are NOT ordered
    forceinline
    SingletonBddView::SingletonBddView(void) {}

    forceinline
    SingletonBddView::SingletonBddView(BMI* manager, int a, int b, const Gecode::Int::IntView& i0)
      : DerivedViewBase<Gecode::Int::IntView>(i0) {
      mgr     = manager;
      min     = a;
      max     = b;
      range   = max - min + 1;
      _offset = mgr->allocate(range);
      domain.init();
      domain  = BDDTOP;

      // exclude values not in dom(i0)
      GecodeBdd bndvars = BDDTOP;
      Gecode::Int::ViewRanges<Gecode::Int::IntView> values(view);
      Iter::Ranges::Singleton s(min, max);
      Iter::Ranges::Diff<Iter::Ranges::Singleton, 
	Gecode::Int::ViewRanges<Gecode::Int::IntView> > diff(s, values);
      
      while (diff()) {
	int mi = diff.min();
	int ma = diff.max();
	int idx = 0;
	for (int i = mi; i <= ma; i++) {
	  idx = i - min;
	  domain  &= getnegbdd(idx);
	  bndvars &= getbdd(idx);
	}
	++diff;
      }
      // enforce singleton view
      GecodeBdd card = cardrec(mgr, bndvars, 0, _offset, range, 1, 1);
      domain &= card;
    }


    forceinline void
    SingletonBddView::init(BMI* manager, int a, int b, const Gecode::Int::IntView& i0) {
      view = i0;
      mgr     = manager;
      min     = a;
      max     = b;
      // range   = view.width();
      range   = max - min + 1;
      _offset = mgr->allocate(range);
      domain.init();
      domain  = BDDTOP;

      // exclude values not in dom(i0)
      GecodeBdd bndvars = BDDTOP;
      Gecode::Int::ViewRanges<Gecode::Int::IntView> values(view);
      Iter::Ranges::Singleton s(min, max);
      Iter::Ranges::Diff<Iter::Ranges::Singleton, 
	Gecode::Int::ViewRanges<Gecode::Int::IntView> > diff(s, values);
      
      while (diff()) {
	int mi = diff.min();
	int ma = diff.max();
	int idx = 0;
	for (int i = mi; i <= ma; i++) {
	  idx = i - min;
	  domain  &= getnegbdd(idx);
	  bndvars &= getbdd(idx);
	}
	++diff;
      }
      // enforce singleton view
      GecodeBdd card = cardrec(mgr, bndvars, 0, _offset, range, 1, 1);
      domain &= card;
    }

    forceinline
    SingletonBddView::~SingletonBddView(void) {
      mgr->dispose(domain);
      mgr->dispose(_offset, (int) range);
    }

    forceinline PropCond
    SingletonBddView::pc_bddtoint(PropCond pc) {
      switch(pc) {
      case PC_BDD_DOM:
	return Gecode::Int::PC_INT_DOM;
      case PC_BDD_VAL:
	return Gecode::Int::PC_INT_VAL;
      default:
	return Gecode::Int::PC_INT_DOM;
      }
    }

    forceinline ModEvent
    SingletonBddView::me_inttobdd(ModEvent me) {
      switch(me) {
      case Gecode::Int::ME_INT_FAILED: 
	return ME_BDD_FAILED;
      case Gecode::Int::ME_INT_NONE: 
	return ME_BDD_NONE;
      case Gecode::Int::ME_INT_VAL: 
	return ME_BDD_VAL;
      case Gecode::Int::ME_INT_DOM: 
	return ME_BDD_DOM;
      default:
	return ME_BDD_DOM;
      }
    }

    /*
     * Domain Tests
     *
     */ 
    forceinline bool
    SingletonBddView::assigned(void) const { return view.assigned(); }


    forceinline bool
    SingletonBddView::contains(int n) const { return view.assigned() ?
					     (view.val()==n) : false; }

    forceinline bool
    SingletonBddView::notContains(int n) const { return !view.in(n); }

    /*
     * Variable information
     *
     */

    forceinline unsigned int
    SingletonBddView::glbSize(void) const { return view.assigned() ? 1 : 0; }

    forceinline unsigned int
    SingletonBddView::lubSize(void) const { return view.size(); }

    forceinline unsigned int
    SingletonBddView::unknownSize(void) const {
      return lubSize() - glbSize();
    }

    forceinline unsigned int
    SingletonBddView::cardMin() const { return 1; }

    forceinline unsigned int
    SingletonBddView::cardMax() const { return 1; }

    forceinline int
    SingletonBddView::lubMin() const { return view.min(); }

    forceinline int
    SingletonBddView::lubMax() const { return view.max(); }

    forceinline int
    SingletonBddView::glbMin() const { return view.assigned() ?
				      view.val() : BddVarImp::MIN_OF_EMPTY; }

    forceinline int
    SingletonBddView::glbMax() const { return view.assigned() ?
				      view.val() : BddVarImp::MAX_OF_EMPTY; }

    /*
     * Bdd information
     *
     */

    forceinline unsigned int
    SingletonBddView::offset(void)  const { return _offset; }

    forceinline unsigned int
    SingletonBddView::table_width(void)  const { return range; }

    forceinline GecodeBdd
    SingletonBddView::getbdd(int i)  const { return mgr->bddpos(_offset + i); }

    forceinline GecodeBdd
    SingletonBddView::getnegbdd(int i)  const { 
      return mgr->negbddpos(_offset + i); 
    }

    forceinline int
    SingletonBddView::getlevel(int i) { return mgr->var2bdd(_offset + i); }
    
    forceinline int
    SingletonBddView::getvar(int i) { return mgr->bdd2var(_offset + i); }

    forceinline void
    SingletonBddView::dom_and(GecodeBdd& d) { d &= bdd_domain(); }
    
    forceinline void
    SingletonBddView::dom_or(GecodeBdd& d) { d |= bdd_domain(); }
    
    forceinline BMI*
    SingletonBddView::manager(void) const { return mgr; }
    
    forceinline int
    SingletonBddView::mgr_min(void)  const { return min; }
    
    forceinline int
    SingletonBddView::mgr_max(void)  const { return max; }

    forceinline int
    SingletonBddView::valididx(int v)  const { 
      if (v < min || v > max) return -1 ;
      return offset() +v - min;
    }

    forceinline GecodeBdd 
    SingletonBddView::bdd_domain(void) const { return domain; };

    forceinline ModEvent
    SingletonBddView::cardinality(Space* home,unsigned int l, unsigned int u) {
      return u <=1 ? ME_BDD_NONE : ME_BDD_FAILED;
    }
    
    forceinline ModEvent
    SingletonBddView::cardMin(Space* home,unsigned int c) {
      return c<=1 ? ME_BDD_NONE : ME_BDD_FAILED;
    }

    forceinline ModEvent
    SingletonBddView::cardMax(Space* home,unsigned int c) {
      return c<1 ? ME_BDD_FAILED : ME_BDD_NONE;
    }

    forceinline ModEvent
    SingletonBddView::include(Space* home,int c) { 
      return me_inttobdd(view.eq(home,c)); 
    }

    forceinline ModEvent
    SingletonBddView::intersect(Space* home,int c) { 
      return me_inttobdd(view.eq(home,c)); 
    }

    forceinline ModEvent
    SingletonBddView::intersect(Space* home,int i, int j) { 
      for (int m = min; m < i; m++) { domain &= getnegbdd(m - min); }
      for (int m = j + 1; m <= max; m++) { domain &= getnegbdd(m - min); }
      
      ModEvent me1 = me_inttobdd(view.gq(home,i));
      ModEvent me2 = me_inttobdd(view.lq(home,j));
      if (me_failed(me1) || me_failed(me2))
	return ME_BDD_FAILED;
      switch (me1) {
      case ME_BDD_NONE:
      case ME_BDD_DOM:
	return me2;
      case ME_BDD_VAL:
	return ME_BDD_VAL;
      default:
	GECODE_NEVER;
	return ME_BDD_VAL;
      }
    }

    forceinline ModEvent
    SingletonBddView::exclude(Space* home,int c) { 
      domain &= getnegbdd(c - min);
      return me_inttobdd(view.nq(home,c)); 
    }

    forceinline ModEvent
    SingletonBddView::include(Space* home, int j, int k) {
      return j==k ? me_inttobdd(view.eq(home,j)) : ME_BDD_FAILED ;
    }

    forceinline ModEvent
    SingletonBddView::exclude(Space* home, int j, int k) {
      for (int i = j; i <= k; i++) {
	domain &= getnegbdd(i - min);
      }
      ModEvent me1 = me_inttobdd(view.gr(home,j));
      ModEvent me2 = me_inttobdd(view.le(home,k));
      if (me_failed(me1) || me_failed(me2))
	return ME_BDD_FAILED;
      switch (me1) {
      case ME_BDD_NONE:
      case ME_BDD_DOM:
	return me2;
      case ME_BDD_VAL:
	return ME_BDD_VAL;
      default:
	GECODE_NEVER;
	return ME_BDD_VAL;
      }
    }

    template <class I> ModEvent
    SingletonBddView::excludeI(Space* home, I& iter) {
      Iter::Ranges::Cache<I> ci(iter);
      while (ci()) {
	for (int i = ci.min(); i <= ci.max(); i++) {
	  domain &= getnegbdd(i - min);
	  ++ci;
	}
      }
      ci.reset();
      return me_inttobdd(view.minus_r(home,ci));
    }

    template <class I> ModEvent
    SingletonBddView::includeI(Space* home, I& iter) {
      if (!iter())
	return ME_BDD_NONE;

      if (iter.min()!=iter.max())
	return ME_BDD_FAILED;

      int val = iter.min();
      ++iter;
      if ( iter() )
	return ME_BDD_FAILED;

      return me_inttobdd(view.eq(home, val));
    }

    template <class I> ModEvent
    SingletonBddView::intersectI(Space* home, I& iter) {
      Gecode::Int::ViewRanges<Gecode::Int::IntView> domx(view);
      Iter::Ranges::Cache<I> ci(iter);
      Iter::Ranges::Diff<
	Gecode::Int::ViewRanges<Gecode::Int::IntView>,
	Iter::Ranges::Cache<I> > diff(domx, ci);
      while (ci()) {
	for (int i = ci.min(); i <= ci.max(); i++) {
	  domain &= getnegbdd(i - min);
	}
	++ci;
      }
      ci.reset();
      return me_inttobdd(view.inter_r(home, ci));
    }

    forceinline ModEvent
    SingletonBddView::nq(Space* home, int a, int b) { 
      return exclude(home, a, b); 
    }

    template <class I>
    forceinline ModEvent
    SingletonBddView::nqI(Space* home, I& i) { return excludeI(home, i); }

    forceinline ModEvent
    SingletonBddView::eq(Space* home, int v) { return include(home, v); }
    
    forceinline ModEvent
    SingletonBddView::eq(Space* home, int a, int b) { 
      return include(home, a, b); 
    }

    template <class I>
    forceinline ModEvent
    SingletonBddView::eqI(Space* home, I& i) { return includeI(home, i); }

    forceinline ModEvent 
    SingletonBddView::tell_formula(Space* home, GecodeBdd& d) {
      if (assigned()) {
	int v = view.val();
	for (int i = min; i <= max; i++) {
	  if (i != v) {
	    domain &= getnegbdd(i - min);
	  } else {
	    domain &= getbdd(i - min);
	  }
	}
	return ME_BDD_VAL;
      }
      d &= domain;
      if (mgr->cfalse(d)) {
	return ME_BDD_FAILED;
      }

      ModEvent me = Gecode::Int::ME_INT_NONE;
      GecodeBdd conv = BDDTOP;
      conv_hull(mgr, d, conv);
      if (!mgr->ctrue(conv)) {
	BddIterator iter(mgr, conv);
	while (iter()) {
	  if (iter.status() == FIX_NOT_LUB) {
	    int idx = iter.label() - _offset;
	    me = view.nq(home, min + idx);
	    if (me_failed(me)) {
	      break;
	    }
	  }
	  if (iter.status() == FIX_GLB) {
	    int idx = iter.label() - _offset;
	    me = view.eq(home, min + idx);
	    break;
	  }
	  ++iter;
	}
      }
      return me_inttobdd(me);
    }

    forceinline void
    SingletonBddView::subscribe(Space* home, Propagator* p, PropCond pc,
			     bool process) {
      view.subscribe(home,p,pc_bddtoint(pc),process);
    }
    forceinline void
    SingletonBddView::cancel(Space* home, Propagator* p, PropCond pc) {
      view.cancel(home, p,pc_bddtoint(pc));
    }

    forceinline ModEvent
    SingletonBddView::pme(const Propagator* p) {     
      return me_inttobdd(Gecode::Int::IntView::pme(p));
    }

    forceinline PropModEvent
    SingletonBddView::pme(ModEvent me) { return BddView::pme(me); }

    forceinline void
    SingletonBddView::update(Space* home, bool share, SingletonBddView& y) {
      view.update(home,share,y.view);
      mgr = y.mgr;
      min = y.min;
      max = y.max;
      range = y.range;
      _offset = y._offset;
      domain.init();
      domain = y.domain;
    }

    /*
     * Iterators
     *
     */

  }
  namespace Set {
    /**
     * \brief %Range iterator for least upper bound of singleton set view
     * \ingroup TaskActorSetView
     */
    template <>
    class LubRanges<Bdd::SingletonBddView> : public Gecode::Int::IntVarImpFwd {
    public:
      /// \name Constructors and initialization
      //@{
      /// Default constructor
      LubRanges(void);
      /// Initialize with ranges for view \a x
      LubRanges(const Bdd::SingletonBddView& x);
      /// Initialize with ranges for view \a x
      void init(const Bdd::SingletonBddView& x);
      //@}
    };

    forceinline
    LubRanges<Bdd::SingletonBddView>::LubRanges(void) {}

    forceinline
    LubRanges<Bdd::SingletonBddView>::LubRanges(const Bdd::SingletonBddView& s) :
      Gecode::Int::IntVarImpFwd(s.base().variable()) {}

    forceinline void
    LubRanges<Bdd::SingletonBddView>::init(const Bdd::SingletonBddView& s) {
      Gecode::Int::IntVarImpFwd::init(s.base().variable());
    }
  }
  namespace Bdd {

    /**
     * \brief %Value iterator for least upper bound of singleton set view
     * \ingroup TaskActorSetView
     */
    template <>
    class LubValues<SingletonBddView> : 
      public Iter::Ranges::ToValues<Set::LubRanges<SingletonBddView> > {
    public:
      /// \name Constructors and initialization
      //@{
      /// Default constructor
      LubValues(void);
      /// Initialize with ranges for view \a x
      LubValues(const SingletonBddView& x);
      /// Initialize with ranges for view \a x
      void init(const SingletonBddView& x);
      //@}
    };

    forceinline
    LubValues<SingletonBddView>::LubValues(void) {}

    forceinline
    LubValues<SingletonBddView>::LubValues(const SingletonBddView& s) {
      Set::LubRanges<SingletonBddView> lub(s);
      Iter::Ranges::ToValues<Set::LubRanges<SingletonBddView> >::init(lub);
    }

    forceinline void
    LubValues<SingletonBddView>::init(const SingletonBddView& s) {
      Set::LubRanges<SingletonBddView> lub(s);
      Iter::Ranges::ToValues<Set::LubRanges<SingletonBddView> >::init(lub);
    }
  }
  namespace Set {
    /**
     * \brief %Range iterator for greatest lower bound of singleton set view
     * \ingroup TaskActorSetView
     */
    template <>
    class GlbRanges<Bdd::SingletonBddView> {
    private:
      int  val;
      bool flag;
    public:
      /// \name Constructors and initialization
      //@{
      /// Default constructor
      GlbRanges(void);
      /// Initialize with ranges for view \a x
      GlbRanges(const Bdd::SingletonBddView& x);
      /// Initialize with ranges for view \a x
      void init(const Bdd::SingletonBddView& x);

      /// \name Iteration control
      //@{
      /// Test whether iterator is still at a range or done
      bool operator()(void) const;
      /// Move iterator to next range (if possible)
      void operator++(void);
      //@}

      /// \name Range access
      //@{
      /// Return smallest value of range
      int min(void) const;
      /// Return largest value of range
      int max(void) const;
      /// Return width of ranges (distance between minimum and maximum)
      unsigned int width(void) const;
      //@}
    };

    forceinline
    GlbRanges<Bdd::SingletonBddView>::GlbRanges(void) {}

    forceinline void
    GlbRanges<Bdd::SingletonBddView>::init(const Bdd::SingletonBddView& s) {
      if (s.base().assigned()) {
	val = s.base().val();
	flag = true;
      } else {
	val = 0;
	flag = false;
      }
    }

    forceinline
    GlbRanges<Bdd::SingletonBddView>::GlbRanges(const Bdd::SingletonBddView& s) {
      init(s);
    }

    forceinline bool
    GlbRanges<Bdd::SingletonBddView>::operator()(void) const { return flag; }

    forceinline void
    GlbRanges<Bdd::SingletonBddView>::operator++(void) { flag=false; }

    forceinline int
    GlbRanges<Bdd::SingletonBddView>::min(void) const { return val; }
    forceinline int
    GlbRanges<Bdd::SingletonBddView>::max(void) const { return val; }
    forceinline unsigned int
    GlbRanges<Bdd::SingletonBddView>::width(void) const { return 1; }

  }

  /*
   * Testing
   *
   */
  forceinline bool
  same(const Bdd::SingletonBddView& x, const Bdd::SingletonBddView& y) {
    return same(x.base(),y.base());
  }
  forceinline bool
  before(const Bdd::SingletonBddView& x, const Bdd::SingletonBddView& y) {
    return before(x.base(),y.base());
  }


}

// STATISTICS: set-var

