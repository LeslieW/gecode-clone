/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Christian Schulte <schulte@gecode.org>
 *
 *  Copyright:
 *     Christian Schulte, 2006
 *
 *  Last modified:
 *     $Date: 2006-10-26 22:15:50 +0200 (Thu, 26 Oct 2006) $ by $Author: schulte $
 *     $Revision: 3806 $
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

#include "gecode/support/sort.hh"

namespace Gecode { namespace Int { namespace Linear {

  /*
   * Array of scale Boolean views
   *
   */
  forceinline
  ScaleBoolArray::ScaleBoolArray(void) {}
  forceinline
  ScaleBoolArray::ScaleBoolArray(Space* home, int n) {
    if (n > 0) {
      _fst = reinterpret_cast<ScaleBool*>(home->alloc(n*sizeof(ScaleBool)));
      _lst = _fst+n;
    } else {
      _fst = _lst = NULL;
    }
  }
  forceinline void 
  ScaleBoolArray::subscribe(Space* home, Propagator* p) {
    for (ScaleBool* f = _fst; f < _lst; f++)
      f->x.subscribe(home,p,PC_BOOL_VAL);
  }
  forceinline void 
  ScaleBoolArray::cancel(Space* home, Propagator* p) {
    for (ScaleBool* f = _fst; f < _lst; f++)
      f->x.cancel(home,p,PC_BOOL_VAL);
  }
  forceinline void 
  ScaleBoolArray::update(Space* home, bool share, ScaleBoolArray& sba) {
    int n = sba._lst - sba._fst;
    if (n > 0) {
      _fst = reinterpret_cast<ScaleBool*>(home->alloc(n*sizeof(ScaleBool)));
      _lst = _fst+n;
      for (int i=n; i--; ) {
        _fst[i].a = sba._fst[i].a;
        _fst[i].x.update(home,share,sba._fst[i].x);
      }
    } else {
      _fst = _lst = NULL;
    }
  }
  forceinline ScaleBool* 
  ScaleBoolArray::fst(void) const {
    return _fst;
  }
  forceinline ScaleBool* 
  ScaleBoolArray::lst(void) const {
    return _lst;
  }
  forceinline void 
  ScaleBoolArray::fst(ScaleBool* f) {
    _fst = f;
  }
  forceinline void 
  ScaleBoolArray::lst(ScaleBool* l) {
    _lst = l;
  }
  forceinline bool 
  ScaleBoolArray::empty(void) const {
    return _fst == _lst;
  }
  forceinline int 
  ScaleBoolArray::size(void) const {
    return static_cast<int>(_lst - _fst);
  }
  forceinline bool
  ScaleBoolArray::ScaleInc::operator()(const ScaleBool& x, 
                                       const ScaleBool& y) {
    return x.a < y.a;
  }

  inline void 
  ScaleBoolArray::sort(void) {
    ScaleInc scale_inc;
    Support::quicksort<ScaleBool,ScaleInc>(fst(), size(), scale_inc);
  }


  /*
   * Empty array of scale Boolean views
   *
   */
  forceinline
  EmptyScaleBoolArray::EmptyScaleBoolArray(void) {}
  forceinline
  EmptyScaleBoolArray::EmptyScaleBoolArray(Space*, int) {}
  forceinline void 
  EmptyScaleBoolArray::subscribe(Space*, Propagator*) {}
  forceinline void 
  EmptyScaleBoolArray::cancel(Space*, Propagator*) {}
  forceinline void 
  EmptyScaleBoolArray::update(Space*, bool, EmptyScaleBoolArray&) {}
  forceinline ScaleBool* 
  EmptyScaleBoolArray::fst(void) const { return NULL; }
  forceinline ScaleBool* 
  EmptyScaleBoolArray::lst(void) const { return NULL; }
  forceinline void 
  EmptyScaleBoolArray::fst(ScaleBool*) {}
  forceinline void 
  EmptyScaleBoolArray::lst(ScaleBool*) {}
  forceinline bool 
  EmptyScaleBoolArray::empty(void) const { return true; }
  forceinline int 
  EmptyScaleBoolArray::size(void) const { return 0; }
  forceinline void 
  EmptyScaleBoolArray::sort(void) {}


  /*
   * Base-class for Boolean constraints with coefficients
   *
   */

  template<class SBAP, class SBAN, class VX>
  forceinline
  LinBoolScale<SBAP,SBAN,VX>::LinBoolScale(Space* home, 
                                           SBAP& p0, SBAN& n0,
                                           VX x0, int c0)
    : Propagator(home), p(p0), n(n0), x(x0), c(c0) {
    x.subscribe(home,this,PC_INT_BND);
    p.subscribe(home,this);
    n.subscribe(home,this);
  }

  template<class SBAP, class SBAN, class VX>
  PropCost
  LinBoolScale<SBAP,SBAN,VX>::cost(void) const {
    return cost_lo(p.size() + n.size(), PC_LINEAR_LO);
  }

  template<class SBAP, class SBAN, class VX>
  size_t
  LinBoolScale<SBAP,SBAN,VX>::dispose(Space* home) {
    assert(!home->failed());
    x.cancel(home,this,PC_INT_BND);
    p.cancel(home,this);
    n.cancel(home,this);
    (void) Propagator::dispose(home);
    return sizeof(*this);
  }

  template<class SBAP, class SBAN, class VX>
  forceinline
  LinBoolScale<SBAP,SBAN,VX>::LinBoolScale(Space* home, bool share, 
                                           LinBoolScale<SBAP,SBAN,VX>& pr)
    : Propagator(home,share,pr), c(pr.c) {
    x.update(home,share,pr.x);
    p.update(home,share,pr.p);
    n.update(home,share,pr.n);
  }

  template<class SBAP, class SBAN, class VX>
  forceinline
  LinBoolScale<SBAP,SBAN,VX>::LinBoolScale(Space* home, bool share, 
                                           Propagator& pr,
                                           SBAP& p0, SBAN& n0,
                                           VX x0, int c0)
    : Propagator(home,share,pr), c(c0) {
    x.update(home,share,x0);
    p.update(home,share,p0);
    n.update(home,share,n0);
  }


  /*
   * Boolean equality with coefficients
   *
   */

  template<class SBAP, class SBAN, class VX>
  forceinline
  EqBoolScale<SBAP,SBAN,VX>::EqBoolScale(Space* home, 
                                         SBAP& p, SBAN& n,
                                         VX x, int c)
    : LinBoolScale<SBAP,SBAN,VX>(home,p,n,x,c) {}

  template<class SBAP, class SBAN, class VX>
  forceinline
  EqBoolScale<SBAP,SBAN,VX>::EqBoolScale(Space* home, bool share, 
                                         EqBoolScale<SBAP,SBAN,VX>& pr)
    : LinBoolScale<SBAP,SBAN,VX>(home,share,pr) {}

  template<class SBAP, class SBAN, class VX>
  forceinline
  EqBoolScale<SBAP,SBAN,VX>::EqBoolScale(Space* home, bool share, 
                                         Propagator& pr,
                                         SBAP& p, SBAN& n,
                                         VX x, int c)
    : LinBoolScale<SBAP,SBAN,VX>(home,share,pr,p,n,x,c) {}

  template<class SBAP, class SBAN, class VX>
  Actor*
  EqBoolScale<SBAP,SBAN,VX>::copy(Space* home, bool share) {
    if (p.empty()) {
      EmptyScaleBoolArray ep;
      return new (home) EqBoolScale<EmptyScaleBoolArray,SBAN,VX>
        (home,share,*this,ep,n,x,c);
    }
    if (n.empty()) {
      EmptyScaleBoolArray en;
      return new (home) EqBoolScale<SBAP,EmptyScaleBoolArray,VX>
        (home,share,*this,p,en,x,c);
    }
    return new (home) EqBoolScale<SBAP,SBAN,VX>(home,share,*this);
  }

  template<class SBAP, class SBAN, class VX>
  ExecStatus
  EqBoolScale<SBAP,SBAN,VX>::propagate(Space* home) {
    int sl = 0;
    int su = 0;
    if (BoolView::pme(this) == ME_BOOL_VAL) {
      // Eliminate assigned positive views while keeping order
      {
        // Skip not assigned views
        ScaleBool* f = p.fst();
        ScaleBool* l = p.lst();
        while ((f < l) && f->x.none()) {
          su -= f->a; f++;
        }
        // Copy unassigned views to t
        ScaleBool* t = f;
        while (f < l) {
          if (f->x.one()) {
            c -= f->a;
          } else if (f->x.none()) {
            su -= f->a; *t = *f; t++;
          }
          f++;
        }
        p.lst(t);
      }
      // Eliminate assigned negative views while keeping order
      {
        // Skip not assigned views
        ScaleBool* f = n.fst();
        ScaleBool* l = n.lst();
        while ((f < l) && f->x.none()) {
          sl += f->a; f++;
        }
        // Copy unassigned views to t
        ScaleBool* t = f;
        while (f < l) {
          if (f->x.one()) {
            c += f->a;
          } else if (f->x.none()) {
            sl += f->a; *t = *f; t++;
          }
          f++;
        }
        n.lst(t);
      }
    } else {
      for (ScaleBool* f=p.fst(); f<p.lst(); f++)
        su -= f->a;
      for (ScaleBool* f=n.fst(); f<n.lst(); f++)
        sl += f->a;
    }
    
    if (p.empty() && n.empty()) {
      GECODE_ME_CHECK(x.eq(home,-c)); 
      return ES_SUBSUMED;
    }

    sl += x.max() + c;
    su += x.min() + c;

    bool mod = false;

    do {
      mod = false;

      // Propagate upper bound for positive Boolean views
      {
        ScaleBool* f = p.fst();
        ScaleBool* l = p.lst();
        while ((f < l) && ((l-1)->a > sl)) {
          l--;
          su += l->a;
          l->x.zero_none(home);
        }
        if (l < p.lst()) {
          p.lst(l); mod=true;
        }
      }
      // Propagate lower bound for negative Boolean views
      {
        ScaleBool* f = n.fst();
        ScaleBool* l = n.lst();
        while ((f < l) && (f->a < -sl)) {
          c += f->a; su += f->a;
          f->x.one_none(home);
          f++;
        }
        if (f > n.fst()) {
          n.fst(f); mod=true;
        }
      }
      // Propagate lower bound for integer view
      {
        const int x_min = x.min();
        ModEvent me = x.gq(home,x.max() - sl);
        if (me_failed(me))
          return ES_FAILED;
        if (me_modified(me)) {
          su += x.min() - x_min;
          mod = true;
        }
      }
      // Propagate lower bound for positive Boolean views
      {
        ScaleBool* f = p.fst();
        ScaleBool* l = p.lst();
        while ((f < l) && ((l-1)->a > -su)) {
          l--;
          c -= l->a; sl -= l->a;
          l->x.one_none(home);
        }
        if (l < p.lst()) {
          p.lst(l); mod=true;
        }
      }
      // Propagate upper bound for negative Boolean views
      {
        ScaleBool* f = n.fst();
        ScaleBool* l = n.lst();
        while ((f < l) && ((l-1)->a > -su)) {
          l--;
          sl -= l->a;
          l->x.zero_none(home);
        }
        if (l < n.lst()) {
          n.lst(l); mod=true;
        }
      }
      // Propagate upper bound for integer view
      {
        const int x_max = x.max();
        ModEvent me = x.lq(home,x.min() - su);
        if (me_failed(me))
          return ES_FAILED;
        if (me_modified(me)) {
          sl += x.max() - x_max;
          mod = true;
        }
      }
    } while (mod);

    return (sl == su) ? ES_SUBSUMED : ES_FIX;
  }



  template<class SBAP, class SBAN, class VX>
  ExecStatus
  EqBoolScale<SBAP,SBAN,VX>::post(Space* home,
                                  SBAP& p, SBAN& n, VX x, int c) {
    p.sort(); n.sort();
    (void) new (home) EqBoolScale<ScaleBoolArray,ScaleBoolArray,VX>
      (home,p,n,x,c);
    return ES_OK;
  }


  /*
   * Boolean inequality with coefficients
   *
   */

  template<class SBAP, class SBAN, class VX>
  forceinline
  LqBoolScale<SBAP,SBAN,VX>::LqBoolScale(Space* home, 
                                         SBAP& p, SBAN& n,
                                         VX x, int c)
    : LinBoolScale<SBAP,SBAN,VX>(home,p,n,x,c) {}

  template<class SBAP, class SBAN, class VX>
  forceinline
  LqBoolScale<SBAP,SBAN,VX>::LqBoolScale(Space* home, bool share, 
                                         LqBoolScale<SBAP,SBAN,VX>& pr)
    : LinBoolScale<SBAP,SBAN,VX>(home,share,pr) {}

  template<class SBAP, class SBAN, class VX>
  forceinline
  LqBoolScale<SBAP,SBAN,VX>::LqBoolScale(Space* home, bool share, 
                                         Propagator& pr,
                                         SBAP& p, SBAN& n,
                                         VX x, int c)
    : LinBoolScale<SBAP,SBAN,VX>(home,share,pr,p,n,x,c) {}

  template<class SBAP, class SBAN, class VX>
  Actor*
  LqBoolScale<SBAP,SBAN,VX>::copy(Space* home, bool share) {
    if (p.empty()) {
      EmptyScaleBoolArray ep;
      return new (home) LqBoolScale<EmptyScaleBoolArray,SBAN,VX>
        (home,share,*this,ep,n,x,c);
    }
    if (n.empty()) {
      EmptyScaleBoolArray en;
      return new (home) LqBoolScale<SBAP,EmptyScaleBoolArray,VX>
        (home,share,*this,p,en,x,c);
    }
    return new (home) LqBoolScale<SBAP,SBAN,VX>(home,share,*this);
  }

  template<class SBAP, class SBAN, class VX>
  ExecStatus
  LqBoolScale<SBAP,SBAN,VX>::propagate(Space* home) {
    int sl = 0;
    if (BoolView::pme(this) == ME_BOOL_VAL) {
      // Eliminate assigned positive views while keeping order
      {
        // Skip not assigned views
        ScaleBool* f = p.fst();
        ScaleBool* l = p.lst();
        while ((f < l) && f->x.none())
          f++;
        // Copy unassigned views to t
        ScaleBool* t = f;
        while (f < l) {
          if (f->x.one()) {
            c -= f->a;
          } else if (f->x.none()) {
            *t = *f; t++;
          }
          f++;
        }
        p.lst(t);
      }
      // Eliminate assigned negative views while keeping order
      {
        // Skip not assigned views
        ScaleBool* f = n.fst();
        ScaleBool* l = n.lst();
        while ((f < l) && f->x.none()) {
          sl += f->a; f++;
        }
        // Copy unassigned views to t
        ScaleBool* t = f;
        while (f < l) {
          if (f->x.one()) {
            c += f->a;
          } else if (f->x.none()) {
            sl += f->a; *t = *f; t++;
          }
          f++;
        }
        n.lst(t);
      }
    } else {
      for (ScaleBool* f=n.fst(); f<n.lst(); f++)
        sl += f->a;
    }
    
    sl += x.max() + c;

    // Propagate upper bound for positive Boolean views
    {
      ScaleBool* f = p.fst();
      ScaleBool* l = p.lst();
      while ((f < l) && ((l-1)->a > sl)) {
        l--; l->x.zero_none(home);
      }
      p.lst(l);
    }
    // Propagate lower bound for negative Boolean views
    {
      ScaleBool* f = n.fst();
      ScaleBool* l = n.lst();
      while ((f < l) && (f->a < -sl)) {
        c += f->a; f->x.one_none(home); f++;
      }
      n.fst(f);
    }
    ExecStatus es = ES_FIX;
    // Propagate lower bound for integer view
    {
      const int slx = x.max() - sl;
      ModEvent me = x.gq(home,slx);
      if (me_failed(me))
        return ES_FAILED;
      if (me_modified(me) && (slx != x.min()))
        es = ES_NOFIX;
    }

    if (p.empty() && n.empty())
      return ES_SUBSUMED;

    return es;
  }



  template<class SBAP, class SBAN, class VX>
  ExecStatus
  LqBoolScale<SBAP,SBAN,VX>::post(Space* home,
                                  SBAP& p, SBAN& n, VX x, int c) {
    p.sort(); n.sort();
    (void) new (home) LqBoolScale<ScaleBoolArray,ScaleBoolArray,VX>
      (home,p,n,x,c);
    return ES_OK;
  }

  /*
   * Boolean disequality with coefficients
   *
   */

  template<class SBAP, class SBAN, class VX>
  forceinline
  NqBoolScale<SBAP,SBAN,VX>::NqBoolScale(Space* home, 
                                         SBAP& p, SBAN& n,
                                         VX x, int c)
    : LinBoolScale<SBAP,SBAN,VX>(home,p,n,x,c) {}

  template<class SBAP, class SBAN, class VX>
  forceinline
  NqBoolScale<SBAP,SBAN,VX>::NqBoolScale(Space* home, bool share, 
                                         NqBoolScale<SBAP,SBAN,VX>& pr)
    : LinBoolScale<SBAP,SBAN,VX>(home,share,pr) {}

  template<class SBAP, class SBAN, class VX>
  forceinline
  NqBoolScale<SBAP,SBAN,VX>::NqBoolScale(Space* home, bool share, 
                                         Propagator& pr,
                                         SBAP& p, SBAN& n,
                                         VX x, int c)
    : LinBoolScale<SBAP,SBAN,VX>(home,share,pr,p,n,x,c) {}

  template<class SBAP, class SBAN, class VX>
  Actor*
  NqBoolScale<SBAP,SBAN,VX>::copy(Space* home, bool share) {
    if (p.empty()) {
      EmptyScaleBoolArray ep;
      return new (home) NqBoolScale<EmptyScaleBoolArray,SBAN,VX>
        (home,share,*this,ep,n,x,c);
    }
    if (n.empty()) {
      EmptyScaleBoolArray en;
      return new (home) NqBoolScale<SBAP,EmptyScaleBoolArray,VX>
        (home,share,*this,p,en,x,c);
    }
    return new (home) NqBoolScale<SBAP,SBAN,VX>(home,share,*this);
  }

  template<class SBAP, class SBAN, class VX>
  ExecStatus
  NqBoolScale<SBAP,SBAN,VX>::propagate(Space* home) {
    if (BoolView::pme(this) == ME_BOOL_VAL) {
      // Eliminate assigned positive views
      {
        ScaleBool* f = p.fst();
        ScaleBool* t = f;
        ScaleBool* l = p.lst();
        while (f < l) {
          if (f->x.one()) {
            c -= f->a; *f = *(t++);
          } else if (f->x.zero()) {
            *f = *(t++);
          } 
          f++;
        }
        p.fst(t);
      }
      // Eliminate assigned negative views
      {
        ScaleBool* f = n.fst();
        ScaleBool* t = f;
        ScaleBool* l = n.lst();
        while (f < l) {
          if (f->x.one()) {
            c += f->a; *f = *(t++);
          } else if (f->x.zero()) {
            *f = *(t++);
          } 
          f++;
        }
        n.fst(t);
      }
    }
    
    if (p.empty() && n.empty()) {
      GECODE_ME_CHECK(x.nq(home,-c)); 
      return ES_SUBSUMED;
    }

    if (x.assigned()) {
      int r = x.val()+c;
      if (p.empty() && (n.size() == 1)) {
        if (r == -n.fst()->a) {
          n.fst()->x.zero_none(home);
        } else if (r == 0) {
          n.fst()->x.one_none(home);
        }
        return ES_SUBSUMED;
      }
      if ((p.size() == 1) && n.empty()) {
        if (r == p.fst()->a) {
          p.fst()->x.zero_none(home);
        } else if (r == 0) {
          p.fst()->x.one_none(home);
        }
        return ES_SUBSUMED;
      }
    }
    return ES_FIX;
  }



  template<class SBAP, class SBAN, class VX>
  ExecStatus
  NqBoolScale<SBAP,SBAN,VX>::post(Space* home,
                                  SBAP& p, SBAN& n, VX x, int c) {
    (void) new (home) NqBoolScale<ScaleBoolArray,ScaleBoolArray,VX>
      (home,p,n,x,c);
    return ES_OK;
  }

}}}

// STATISTICS: int-prop

