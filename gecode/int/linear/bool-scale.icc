/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Christian Schulte <schulte@gecode.org>
 *
 *  Copyright:
 *     Christian Schulte, 2003
 *
 *  Last modified:
 *     $Date: 2006-10-26 22:15:50 +0200 (Thu, 26 Oct 2006) $ by $Author: schulte $
 *     $Revision: 3806 $
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

namespace Gecode { namespace Int { namespace Linear {

  template<class SBAP, class SBAN, class VX>
  forceinline
  EqBoolScale<SBAP,SBAN,VX>::EqBoolScale(Space* home, 
                               SBAP& p0, SBAN& n0,
                               VX x0, int c0)
    : Propagator(home), p(p0), n(n0), x(x0), c(c0) {
    x.subscribe(home,this,PC_INT_BND);
    p.subscribe(home,this);
    n.subscribe(home,this);
  }

  template<class SBAP, class SBAN, class VX>
  forceinline
  EqBoolScale<SBAP,SBAN,VX>::EqBoolScale(Space* home, bool share, 
                               EqBoolScale<SBAP,SBAN,VX>& pr)
    : Propagator(home,share,pr), c(pr.c) {
    x.update(home,share,pr.x);
    p.update(home,share,pr.p);
    n.update(home,share,pr.n);
  }

  template<class SBAP, class SBAN, class VX>
  PropCost
  EqBoolScale<SBAP,SBAN,VX>::cost(void) const {
    return cost_lo(p.size() + n.size(), PC_LINEAR_LO);
  }

  template<class SBAP, class SBAN, class VX>
  forceinline size_t
  EqBoolScale<SBAP,SBAN,VX>::dispose(Space* home) {
#ifdef DBG_PRINT
    std::cout << "DISPOSE" << std::endl;
#endif
    assert(!home->failed());
    x.cancel(home,this,PC_INT_BND);
    p.cancel(home,this);
    n.cancel(home,this);
    (void) Propagator::dispose(home);
    return sizeof(*this);
  }

  template<class SBAP, class SBAN, class VX>
  Actor*
  EqBoolScale<SBAP,SBAN,VX>::copy(Space* home, bool share) {
    return new (home) EqBoolScale<SBAP,SBAN,VX>(home,share,*this);
  }

  template<class SBAP, class SBAN, class VX>
  ExecStatus
  EqBoolScale<SBAP,SBAN,VX>::propagate(Space* home) {
    // #define DBG_PRINT 1
#ifdef DBG_PRINT
    std::cout << "PROPAGATE" << std::endl;
    std::cout << "\t";
    for (ScaleBool* f=p.fst(); f<p.lst(); f++)
      std::cout << " + " << f->a << "*" << f->x;
    for (ScaleBool* f=n.fst(); f<n.lst(); f++)
      std::cout << " - " << f->a << "*" << f->x;
    std::cout << " = " << x << " + " << c << std::endl;
#endif
    int sl = 0;
    int su = 0;
    if (BoolView::pme(this) == ME_BOOL_VAL) {
      {
        ScaleBool* f = p.fst();
        ScaleBool* l = p.lst();
        while ((f < l) && f->x.none()) {
          su -= f->a; f++;
        }
        ScaleBool* t = f;
        while (f < l) {
          if (f->x.one()) {
            c -= f->a;
          } else if (f->x.none()) {
            su -= f->a; *t = *f; t++;
          }
          f++;
        }
        p.lst(t);
      }
      {
        ScaleBool* f = n.fst();
        ScaleBool* l = n.lst();
        while ((f < l) && f->x.none()) {
          sl += f->a; f++;
        }
        ScaleBool* t = f;
        while (f < l) {
          if (f->x.one()) {
            c += f->a;
          } else if (f->x.none()) {
            sl += f->a; *t = *f; t++;
          }
          f++;
        }
        n.lst(t);
      }
    } else {
      for (ScaleBool* f=p.fst(); f<p.lst(); f++)
        su -= f->a;
      for (ScaleBool* f=n.fst(); f<n.lst(); f++)
        sl += f->a;
    }
    
    if (p.empty() && n.empty()) {
      GECODE_ME_CHECK(x.eq(home,-c)); 
      return ES_SUBSUMED;
    }
    /*
    if (x.assigned() && ((n_p + n_n) == 1)) {
      int r = x.val() + c;
      if (n_p == 1) {
        if (p[0].a == r) {
          p[0].x.one_none(home); 
          return ES_SUBSUMED;
        } else if (r == 0) {
          p[0].x.zero_none(home); 
          return ES_SUBSUMED;
        }
      } else {
        assert(n_n == 1);
        if (-n[0].a == r) {
          n[0].x.one_none(home); 
          return ES_SUBSUMED;
        } else if (r == 0) {
          n[0].x.zero_none(home); 
          return ES_SUBSUMED;
        }
      }
      return ES_FAILED;
    }
    */
    sl += x.max() + c;
    su += x.min() + c;

#ifdef DBG_PRINT
    std::cout << "ELIMINATE (sl: "
              << sl << ", su: " << su << ")"
              << std::endl;
    std::cout << "\t";
    for (ScaleBool* f=p.fst(); f<p.lst(); f++)
      std::cout << " + " << f->a << "*" << f->x;
    for (ScaleBool* f=n.fst(); f<n.lst(); f++)
      std::cout << " - " << f->a << "*" << f->x;
    std::cout << " = " << x << " + " << c << std::endl;
#endif

    bool mod = false;

    do {
      mod = false;
#ifdef DBG_PRINT
      std::cout << "ITERATE (sl: "
                << sl << ", su: " << su << ")"
                << std::endl;
      std::cout << "\t";
      for (ScaleBool* f=p.fst(); f<p.lst(); f++)
        std::cout << " + " << f->a << "*" << f->x;
      for (ScaleBool* f=n.fst(); f<n.lst(); f++)
        std::cout << " - " << f->a << "*" << f->x;
      std::cout << " = " << x << " + " << c << std::endl;
#endif

      // Propagate upper bound for positive Boolean views
      {
        ScaleBool* f = p.fst();
        ScaleBool* l = p.lst();
        while ((f < l) && ((l-1)->a > sl)) {
          l--;
          su += l->a;
          l->x.zero_none(home);
        }
        if (l < p.lst()) {
          p.lst(l); mod=true;
        }
      }
      /*
      for (int i = n_p; i--; )
        if (p[i].a > sl) {
          su += p[i].a;
          p[i].x.zero_none(home);
          p[i]=p[--n_p];
          mod = true;
        }
      */
      // Propagate lower bound for negative Boolean views
      {
        ScaleBool* f = n.fst();
        ScaleBool* l = n.lst();
        while ((f < l) && (f->a < -sl)) {
          c += f->a; su += f->a;
          f->x.one_none(home);
          f++;
        }
        if (f > n.fst()) {
          n.fst(f); mod=true;
        }
      }
      /*
      for (int i = n_n; i--; )
        if (n[i].a < -sl) {
          c  += n[i].a;
          su += n[i].a;
          n[i].x.one_none(home);
          n[i]=n[--n_n];
          mod = true;
        }
      */
      // Propagate lower bound for integer view
      {
        const int x_min = x.min();
        const int ngq = x.max() - sl;
        ModEvent me = x.gq(home,x.max() - sl);
        if (me_failed(me)) {
#ifdef DBG_PRINT
          std::cout << "FAILED on x.gq ("
                    << ngq << ") (sl: "
                    << sl << ", su: " << su << ")"
                    << " p.size()=" << p.size()
                    << " n.size()=" << n.size()
                    << std::endl;
          std::cout << "\t";
          for (ScaleBool* f=p.fst(); f<p.lst(); f++)
            std::cout << " + " << f->a << "*" << f->x;
          for (ScaleBool* f=n.fst(); f<n.lst(); f++)
            std::cout << " - " << f->a << "*" << f->x;
          std::cout << " = " << x << " + " << c << std::endl;
#endif
          return ES_FAILED;
        }
        if (me_modified(me)) {
          su += x.min() - x_min;
          mod = true;
        }
      }
      // Propagate lower bound for positive Boolean views
      {
        ScaleBool* f = p.fst();
        ScaleBool* l = p.lst();
        while ((f < l) && ((l-1)->a > -su)) {
          l--;
          c -= l->a; sl -= l->a;
          l->x.one_none(home);
        }
        if (l < p.lst()) {
          p.lst(l); mod=true;
        }
      }
      /*
      for (int i = n_p; i--; )
        if (p[i].a > -su) {
          c  -= p[i].a;
          sl -= p[i].a;
          p[i].x.one_none(home);
          p[i] = p[--n_p];
          mod = true;
        }
      */
      // Propagate upper bound for negative Boolean views
      {
        ScaleBool* f = n.fst();
        ScaleBool* l = n.lst();
        while ((f < l) && ((l-1)->a > -su)) {
          l--;
          sl -= l->a;
          l->x.zero_none(home);
        }
        if (l < n.lst()) {
          n.lst(l); mod=true;
        }
      }
      /*
      for (int i = n_n; i--; )
        if (n[i].a > -su) {
          sl -= n[i].a;
          n[i].x.zero_none(home);
          n[i]=n[--n_n];
          mod = true;
        }
      */
      // Propagate upper bound for integer view
      {
        const int x_max = x.max();
        const int nlq = x.min() - su;
        ModEvent me = x.lq(home,x.min() - su);
        if (me_failed(me)) {
#ifdef DBG_PRINT
          std::cout << "FAILED on x.lq(" << nlq
                    << ") (sl: " 
                    << sl << ", su: " << su << ")"
                    << " p.size()=" << p.size()
                    << " n.size()=" << n.size()
                    << std::endl;
          std::cout << "\t";
          for (ScaleBool* f=p.fst(); f<p.lst(); f++)
            std::cout << " + " << f->a << "*" << f->x;
          for (ScaleBool* f=n.fst(); f<n.lst(); f++)
            std::cout << " - " << f->a << "*" << f->x;
          std::cout << " = " << x << " + " << c << std::endl;
#endif
          return ES_FAILED;
        }
        if (me_modified(me)) {
          sl += x.max() - x_max;
          mod = true;
        }
      }
    } while (mod);

#ifdef DBG_PRINT
    std::cout << "AFTER PROPAGATION (sl: "
              << sl << ", su: " << su << ")"
              << std::endl;
    std::cout << "\t";
    for (ScaleBool* f=p.fst(); f<p.lst(); f++)
      std::cout << " + " << f->a << "*" << f->x;
    for (ScaleBool* f=n.fst(); f<n.lst(); f++)
      std::cout << " - " << f->a << "*" << f->x;
    std::cout << " = " << x << " + " << c << std::endl;
#endif

    return (sl == su) ? ES_SUBSUMED : ES_FIX;
  }



  template<class SBAP, class SBAN, class VX>
  ExecStatus
  EqBoolScale<SBAP,SBAN,VX>::post(Space* home,
                        const IntArgs& a, const BoolVarArgs& b,
                        VX x, int c) {
    int n_p = 0;
    int n_n = 0;
    for (int i=a.size(); i--; )
      if (a[i] > 0) n_p++; else n_n++;
    ScaleBoolArray p(home,n_p);
    ScaleBoolArray n(home,n_n);
    ScaleBool* f_p = p.fst();
    ScaleBool* f_n = n.fst();
    for (int i=a.size(); i--; )
      if (a[i] > 0) {
        f_p->a=a[i]; f_p->x=b[i]; f_p++;
      } else {
        f_n->a=-a[i]; f_n->x=b[i]; f_n++;
      }
    p.sort(); n.sort();
    (void) new (home) EqBoolScale<ScaleBoolArray,ScaleBoolArray,VX>
      (home,p,n,x,c);
    return ES_OK;
  }

}}}

// STATISTICS: int-prop

