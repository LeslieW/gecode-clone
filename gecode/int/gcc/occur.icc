/*
 *  Main authors:
 *     Patrick Pekczynski <pekczynski@ps.uni-sb.de>
 *
 *  Copyright:
 *     Patrick Pekczynski, 2004
 *
 *  Last modified: $Date$ by $Author$
 *  $Revision$
 *
 *  This file is part of Gecode, the generic constrain
 *  development environment:
 *     http://www.gecode.org
 *
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 */

#include "gecode/iter.hh"

namespace Gecode { namespace Int { namespace GCC {
  /**
   * \brief Tuple conataining the lower and upper cardinality bounds
   * 
   */
  template <class T, unsigned int n>
  class OccurBnds {
  private:
    // The views 
    // not supposed to have an array with size n larger 2
    T x[n];
    int c;
    int count;
  public:
    OccurBnds(void);
    T& operator[](unsigned int i);
    const T& operator[](unsigned int i) const;
     T& min(void);
     T& max(void);
    void init(Space* home, T min, T max, int c);
    ModEvent lq(Space* home, int n); 
    ModEvent gq(Space* home, int n); 
    ModEvent eq(Space* home, int n); 
    bool assigned(void);
    bool modified(void);
    bool range(void);
    T& operator=(const T& o);
    int card(void);
    void card(int c);
    ModEvent inc(void);
    void counter(int c);
    int counter(void);
  };

  template <class T, unsigned int n>
  forceinline
  OccurBnds<T,n>::OccurBnds(void) {}

  template <class T, unsigned int n>
  forceinline const T&
  OccurBnds<T,n>::operator[](unsigned int i) const {
    assert((i >= 0) && (i < n));
    return x[i];
  }

  template <class T, unsigned int n>
  forceinline T&
  OccurBnds<T,n>::operator[](unsigned int i) {
    assert((i >= 0) && (i < n));
    return x[i];
  }

  template <class T, unsigned int n>
  forceinline T&
  OccurBnds<T,n>::min(void) {
    return x[0];
  }

  template <class T, unsigned int n>
  forceinline void
  OccurBnds<T,n>::init(Space* home, T min, T max, int val) {
    x[0] = min; x[n - 1] = max;
    c = val;
    count = 0;
  }

  template <class T, unsigned int n>
  forceinline int
  OccurBnds<T,n>::card(void) {
    return c;
  }

  template <class T, unsigned int n>
  forceinline void
  OccurBnds<T,n>::card(int ca) {
    c = ca;
  }

  template <class T, unsigned int n>
  forceinline ModEvent
  OccurBnds<T,n>::inc(void) {
    count++;
    if (count > this->max()) {
      return ME_GEN_FAILED;
    } else {
      return ME_GEN_NONE;
    }
  }

  template <class T, unsigned int n>
  forceinline void
  OccurBnds<T,n>::counter(int c) {
    count = c;
  }

  template <class T, unsigned int n>
  forceinline int
  OccurBnds<T,n>::counter(void) {
    return count;
  }

  template <class T, unsigned int n>
  forceinline bool
  OccurBnds<T,n>::assigned(void) {
    return x[0] == x[1];
  }

  template <class T, unsigned int n>
  forceinline bool
  OccurBnds<T,n>::modified(void) {
    return false;
  }

  template <class T, unsigned int n>
  forceinline bool
  OccurBnds<T,n>::range(void) {
    return true;
  }


  template <class T, unsigned int n> // template <class I>
  forceinline ModEvent 
  OccurBnds<T,n>::lq(Space* home, int i){
    // the maximum can be made consistent
    if (x[0] > i) {
      return ME_GEN_FAILED;
    } else {
      return ME_GEN_NONE;
    }
  }

  template <class T, unsigned int n> // template <class I>
  forceinline ModEvent 
  OccurBnds<T,n>::gq(Space* home, int i){
    // this bound is fix
    if (x[1] < i) {
      return ME_GEN_FAILED;
    }
    return ME_GEN_NONE;
  }

  template <class T, unsigned int n> // template <class I>
  forceinline ModEvent 
  OccurBnds<T,n>::eq(Space* home, int i){
    if (x[0] > i || x[1] < i) {
      return ME_GEN_FAILED;
    } else {
      return ME_GEN_NONE;
    }
  }




  template <class T, unsigned int n>
  forceinline T& 
  OccurBnds<T,n>::operator=(const T& o){
    (*this)[0]  = o[0];
    (*this)[1]  = o[1];
    this->c     = o.c;
    this->count = o.count;
  }

  template <class T, unsigned int n>
  forceinline  T&
  OccurBnds<T,n>::max(void) {
    return x[n - 1];
  }

  /// \brief Debugging: print a fixed cardinality
  template <class T, unsigned int n>
  forceinline std::ostream&
  operator<<(std::ostream& os, OccurBnds<T,n>& xs) {
    os << xs.card() << "("<< xs.counter() <<")[";
    for (unsigned int i=0; i<n-1; i++) {
      os << xs[i] << ",";
    }
    os << xs[n-1] << "]";
    return os;
  }

  /**
   * \brief Array of %OccurBnds mimicking cardinality variables
   *
   */
  template <class T>
  class OccurArray :public PrimArgArray<T>{
  private: 
    int l;
  public:
    OccurArray(int n);
    OccurArray(Space* home, int n);
    OccurArray(const OccurArray<T>& o);
    OccurArray(Space* home, const OccurArray<T>& o);
    template <class View>
    OccurArray(const IntArgs&, const ViewArray<View>&, 
	       int, int, int, int, int, int, int);
    int  size(void);
    void size(int n);
    void update(Space*, bool, OccurArray<T>&);
    void cancel(Space* home, Propagator* , PropCond );
    void subscribe(Space*, Propagator* , PropCond);
    int  lookup(int v);
  };


  template <class T>
  OccurArray<T>::OccurArray(int n) : PrimArgArray<T>(n), l(n){}

  template <class T>
  OccurArray<T>::OccurArray(Space* home, int n) : PrimArgArray<T>(n), l(n){}

  /**
   * \brief Construct an array with fix cardinalities
   *
   * \param ia array of triples \f$ (v,l_v,u_v) \f$
   * \param iasize provides the size of the given IntArgs
   * \param nov is the number of all values in the domains of the views
   * \param min is the minimum possible value
   * \param max is the maximum possible value
   * \param unspec_low lower bound for unspecified values
   * \param unspec_up  upper bound for unspecified values
   * \param all checks whether all possible values are used or not
   */
  template <class T> template <class View>
  OccurArray<T>::OccurArray(const IntArgs& ia, const ViewArray<View>& x,
			    int iasize, int val, int nov,
			    int min, int max, 
			    int unspec_low, int unspec_up) : 
    PrimArgArray<T>(std::max(nov, val)), l(std::max(nov, val)) {
    
    int n = x.size();

    GECODE_AUTOARRAY(ViewRanges<View>, xrange, n);
    for (int i = n; i--; ){
      ViewRanges<View> iter(x[i]);
      xrange[i] = iter;
    }

    Gecode::Iter::Ranges::NaryUnion<ViewRanges<View> >     
      drl(&xrange[0], x.size());
    Gecode::Iter::Ranges::Cache<
      Gecode::Iter::Ranges::
      NaryUnion<ViewRanges<View> > > crl(drl);
       
    int c = 0; 
    int r = 0;
    
    GECODE_AUTOARRAY(bool, indom, (max - (min - 1)));
    for (int i = max - (min - 1); i--; ) {
      indom[i] = false;
    }
    for ( ; crl(); ++crl) {
      for (int v = crl.min(); v <= crl.max(); v++) {
	indom[v - min] = true;
      }
    }

    int xmin = min;
    int xmax = max;
    // mark those values that are specified
    min = std::min(xmin, ia[0]);
    max = std::max(xmax, ia[(val - 1) * 3]);

    for (int v = min; v <= max; v++) {
      if (c > l - 1) {
	break;
      }
      // value is in a variable domain
      if (v >= xmin && indom[v - xmin]) {
	if (r < iasize) {
	  if (v == ia[r]) {
	    // value is specified with cardinalities
	    // checking should be outsourced to gcc.cc
	    if (ia[r + 1] > ia[r + 2]) {
	      throw ArgumentSizeMismatch("Int::gcc");
	    }
	    
	    (*this)[c].card(v);
	    (*this)[c].counter(0);
	    (*this)[c][0] = ia[r + 1];
	    (*this)[c][1] = ia[r + 2];
	    c++;
	    r += 3;
	  } else {
	    // value is not specified with cardinalities
	    // the value is unspecified
	    (*this)[c].card(v);
	    (*this)[c].counter(0);
	    (*this)[c][0] = unspec_low;
	    (*this)[c][1] = unspec_up;
	    c++;
	  }
	} else {
	  // there are more values in the variable domains
	  // than specified 
	    (*this)[c].card(v);
	    (*this)[c].counter(0);
	    (*this)[c][0] = unspec_low;
	    (*this)[c][1] = unspec_up;
	    c++;
	}
      } else {
	// the value is not in a variable domain of the current assignment
	if (r < iasize) {
	  // but it is specified
	  if (v == ia[r]) {
	    // checking should be outsourced to gcc.cc
	    if (ia[r + 1] > ia[r + 2]) {
	      throw ArgumentSizeMismatch("Int::gcc");
	    }
	    
	    (*this)[c].card(v);
	    (*this)[c].counter(0);
	    (*this)[c][0] = ia[r + 1];
	    (*this)[c][1] = ia[r + 2];
	    c++;
	    r += 3;
	  } else {
	    // the value is unspecified
	    (*this)[c].card(v);
	    (*this)[c].counter(0);
	    (*this)[c][0] = unspec_low;
	    (*this)[c][1] = unspec_up;
	    c++;
	  }
	} else {
	  // there are more values in the variable domains
	  // than specified 
	    (*this)[c].card(v);
	    (*this)[c].counter(0);
	    (*this)[c][0] = unspec_low;
	    (*this)[c][1] = unspec_up;
	    c++;
	}
      }
    }
    
    if (c < l) {
      for ( ; r < iasize; r+=3) {
	assert(0 <= c && c < l);
	(*this)[c].card(ia[r]);
	(*this)[c].counter(0);
	(*this)[c][0] = unspec_low;
	(*this)[c][1] = unspec_up;
	c++;
	r+=3;
      }
    }
      
  }

  template <class T>
  OccurArray<T>::OccurArray(const OccurArray<T>& o) 
    : PrimArgArray<T>(o), l(o.l) {}

  template <class T>
  OccurArray<T>::OccurArray(Space* home, const OccurArray<T>& o) 
    : PrimArgArray<T>(o), l(o.l) {}

  template <class T>
  forceinline int
  OccurArray<T>::size(void){
    return l;
  }

  template <class T>
  forceinline void
  OccurArray<T>::size(int n){
    l = n;
  }

  template <class T>
  forceinline void
  OccurArray<T>::update(Space* home, bool share, OccurArray<T>& o) {
    
    for (int i = this->size(); i--; ) {
      (*this)[i] = o[i];
    }
    assert(this->size() == o.size());
  }

  template <class T>
  forceinline void
  OccurArray<T>::cancel(Space* home, Propagator* p, PropCond pc ) {}

  template <class T>
  forceinline void
  OccurArray<T>::subscribe(Space* home, Propagator* p, PropCond pc ) {}

  /**
   * \brief Return the index of v in the array
   *
   *  Complexity is \f$O(log(|k|))\f$
   */
  
  template <class T>
  forceinline int 
  OccurArray<T>::lookup(int v){
    int idx = -1;
    
    int l  = 0;
    int r  = this->size() - 1;

    if (r == 0) {
      if ((*this)[0].card() == v) {
	return 0;
      } else {
	return -1;
      }
    }

    while ( l < r ) {
      if ( (*this)[l].card() == v) {
	idx = l;
	break;
      }
      if ( (*this)[r].card() == v) {
	idx = r;
	break;
      }
      int p  = (l + r) / 2;
      if ( v == (*this)[p].card()) {
	idx = p;
	break;
      } else {
	if ( v < (*this)[p].card()) {
	  r = p;
	} else {
	  l = p;
	}
      }
      if (l == r - 1) {
	break;
      }
    }

    

    return idx;
  }



  /**
   * \brief Card integer view
   *
   */
  class CardView : public DerivedViewBase<IntView> {
  protected:
    /// Card
    int c;
    /// Counter
    int count;
    using DerivedViewBase<IntView>::view;
  public:
    CardView(void);
    /// Initialize with integer view \a x and value \a c
    CardView(const IntView& x, int c);
    /// Initialize with integer view \a x and value \a c
    void init(const IntView& x, int c);
    void init(Space* home, int mi, int ma , int c);

    /// Return value 
    int card(void) const;
    void card(int ca);

    /// Increment counter
    ModEvent inc(void);
    /// Set the counter to the number of times value \a c occurs
    void counter(int);
    /// Return the number of times value \a c occurs
    int counter(void);
    
    /// \name Value access
    //@{
    void operator=(const IntView& x);
    void operator=(const Gecode::Int::GCC::CardView& x);
    /// Return minimum of domain
    int min(void) const;
    /// Return maximum of domain
    int max(void) const;
    /// Return median of domain
    int med(void) const;
    /// Return assigned value (only if assigned)
    int val(void) const;
    /// Return used IntView
    IntView intview(void);
    /// Return size (cardinality) of domain
    unsigned int size(void) const;
    /// Return width of domain (distance between maximum and minimum)
    unsigned int width(void) const;
    /// Return regret of domain minimum (distance to next larger value)
    unsigned int regret_min(void) const;
    /// Return regret of domain maximum (distance to next smaller value)
    unsigned int regret_max(void) const;
    ///@}

    /// \name Domain tests
    ///@{
    /// Test whether domain is a range
    bool range(void) const;
    /// Test whether view is assigned
    bool assigned(void) const;

    /// Test whether \a n is contained in domain
    bool in(int n) const;
    /// Test whether \a n is contained in domain
    bool in(double n) const;
    ///@}

    /// \name Domain update by value
    ///@{
    /// Restrict domain values to be less or equal than \a n
    ModEvent lq(Space* home, int n); 
    /// Restrict domain values to be less or equal than \a n
    ModEvent lq(Space* home, double n);
    /// Restrict domain values to be less than \a n
    ModEvent le(Space* home, int n); 
    /// Restrict domain values to be less than \a n
    ModEvent le(Space* home, double n);
    /// Restrict domain values to be greater or equal than \a n
    ModEvent gq(Space* home, int n); 
    /// Restrict domain values to be greater or equal than \a n
    ModEvent gq(Space* home, double n);
    /// Restrict domain values to be greater than \a n
    ModEvent gr(Space* home, int n); 
    /// Restrict domain values to be greater than \a n
    ModEvent gr(Space* home, double n);
    /// Restrict domain values to be different from \a n
    ModEvent nq(Space* home, int n); 
    /// Restrict domain values to be different from \a n
    ModEvent nq(Space* home, double n);
    /// Restrict domain values to be equal to \a n
    ModEvent eq(Space* home, int n); 
    /// Restrict domain values to be equal to \a n
    ModEvent eq(Space* home, double n);
    ///@}

    /// \name Domain update by range iterator
    ///@{
    /// Replace domain by range sequence described by \a i
    /// Intersect domain with range sequence described by \a i
    template <class I> ModEvent inter(Space* home, I& i);
    /// Remove from domain the range sequence described by \a i
    template <class I> ModEvent minus(Space* home, I& i);
    ///@}

    /// \name Propagator modification events
    ///@{
    /// Return modification event of propagator \a p for view
    static ModEvent     pme(const Propagator* p);
    /// Translate modification event \a me to propagator modification event for view
    static PropModEvent pme(ModEvent me);
    ///@}

    /// \name Dependencies
    ///@{
    /// Subscribe propagator \a p with propagation condition \a pc to view
    void subscribe(Space* home, Propagator* p, PropCond pc);
    /// Cancel subscription of propagator \a p with propagation condition \a pc to view
    void cancel(Space* home, Propagator* p, PropCond pc);
    ///@}

    /// \name Cloning
    ///@{
    /// Update this view to be a clone of view \a x
    void update(Space* home, bool share, CardView& x);
    ///@}

    /// \name View comparison
    ///@{
    /// Test whether this view is the same as \a x
    bool operator ==(const CardView& x) const;
    /// Test whether this view is not the same as \a x
    bool operator !=(const CardView& x) const;
    /// Test whether this view is smaller than \a x (arbitrary order)
    bool operator < (const CardView& x) const;
    /// Test whether this view is larger than \a x (arbitrary order)
    bool operator > (const CardView& x) const;
    ///@}
  };

  /*
   * Constructors and initialization
   *
   */
  forceinline
  CardView::CardView(void) {}

  forceinline
  CardView::CardView(const IntView& x, int d)
    : DerivedViewBase<IntView>(x), c(d), count(0) {}

  forceinline void
  CardView::init(const IntView& x, int d) {
    view  = x; 
    c     = d; 
    count = 0;
  }


  forceinline void
  CardView::init(Space* home, int mi, int ma, int d) {
    IntVar ivar(home, mi, ma);
    IntView iview(ivar);
    view  = iview; 
    c     = d;
    count = 0;
  }

  forceinline void 
  CardView::card(int ca) {
    c = ca;
  }

  forceinline int
  CardView::card(void) const {
    return c;
  }

  forceinline ModEvent
  CardView::inc(void) {
    count++;
    if (count > this->max()) {
      return ME_GEN_FAILED;
    } else {
      return ME_GEN_NONE;
    }
  }

  forceinline void
  CardView::counter(int c) {
    count = c;
  }

  forceinline int
  CardView::counter(void) {
    return count;
  }

  /*
   * Value access
   *
   */

  forceinline void 
  CardView::operator=(const IntView& x) { 
    view  = x; 
    c     = 0; 
    count = 0;
  }

  forceinline void 
  CardView::operator=(const CardView& x) { 
    view  = x.view; 
    c     = x.c; 
    count = x.count;
  }


  forceinline int
  CardView::min(void) const { 
    return view.min(); 
  }
  forceinline int
  CardView::max(void) const { 
    return view.max(); 
  }
  forceinline int
  CardView::med(void) const { 
    return view.med(); 
  }

  forceinline int
  CardView::val(void) const { 
    return view.val(); 
  }

  forceinline IntView
  CardView::intview(void){ 
    return view;
  }


  forceinline unsigned int
  CardView::width(void) const { 
    return view.width(); 
  }
  forceinline unsigned int
  CardView::size(void) const { 
    return view.size(); 
  }
  forceinline unsigned int
  CardView::regret_min(void) const { 
    return view.regret_min(); 
  }
  forceinline unsigned int
  CardView::regret_max(void) const { 
    return view.regret_max(); 
  }

  /*
   * Domain tests
   *
   */
  forceinline bool
  CardView::range(void) const { 
    return view.range(); 
  }
  forceinline bool
  CardView::assigned(void) const { 
    return view.assigned(); 
  }

  forceinline bool
  CardView::in(int n) const { 
    return view.in(n); 
  }
  forceinline bool
  CardView::in(double n) const { 
    return view.in(n); 
  }


  /*
   * Domain update by value
   *
   */
  forceinline ModEvent
  CardView::lq(Space* home, int n) { 
    return view.lq(home,n); 
  }
  forceinline ModEvent
  CardView::lq(Space* home, double n) { 
    return view.lq(home,n); 
  }
  forceinline ModEvent
  CardView::le(Space* home, int n) { 
    return view.le(home,n); 
  }
  forceinline ModEvent
  CardView::le(Space* home, double n) { 
    return view.le(home,n); 
  }
  forceinline ModEvent
  CardView::gq(Space* home, int n) { 
    return view.gq(home,n); 
  }
  forceinline ModEvent
  CardView::gq(Space* home, double n) { 
    return view.gq(home,n); 
  }
  forceinline ModEvent
  CardView::gr(Space* home, int n) { 
    return view.gr(home,n); 
  }
  forceinline ModEvent
  CardView::gr(Space* home, double n) { 
    return view.gr(home,n); 
  }
  forceinline ModEvent
  CardView::nq(Space* home, int n) { 
    return view.nq(home,n); 
  }
  forceinline ModEvent
  CardView::nq(Space* home, double n) { 
    return view.nq(home,n); 
  }
  forceinline ModEvent
  CardView::eq(Space* home, int n) { 
    return view.eq(home,n); 
  }
  forceinline ModEvent
  CardView::eq(Space* home, double n) { 
    return view.eq(home,n); 
  }


  /*
   * Domain update by range iterator
   *
   */
  template <class I>
  ModEvent
  CardView::inter(Space* home, I& i) {
    return view.inter(home,i);
  }
  template <class I>
  ModEvent
  CardView::minus(Space* home, I& i) {
    return view.minus(home,i);
  }



  /*
   * Propagator modification events
   *
   */
  forceinline ModEvent
  CardView::pme(const Propagator* p) {
    return IntView::pme(p);
  }
  forceinline PropModEvent
  CardView::pme(ModEvent me) {
    return IntView::pme(me);
  }


  /*
   * Dependencies
   *
   */
  forceinline void
  CardView::subscribe(Space* home, Propagator* p, PropCond pc) {
    view.subscribe(home, p, pc);
  }
  forceinline void
  CardView::cancel(Space* home, Propagator* p, PropCond pc) {
    view.cancel(home,p, pc);
  }


  /*
   * Cloning
   *
   */
  forceinline void
  CardView::update(Space* home, bool share, CardView& x) {
    c     = x.c; 
    count = x.count;
    view.update(home,share,x.view);
  }



  /*
   * View comparison
   *
   */
//   forceinline bool
//   CardView::operator ==(const CardView& x) const {
//     return (view == x.view) && (c == x.c) && (count == x.count);
//   }
//   forceinline bool
//   CardView::operator !=(const CardView& x) const {
//     return (view != x.view) || (c != x.c) ;
//   }
//   forceinline bool
//   CardView::operator < (const CardView& x) const {
//     return (view < x.view) || ((view == x.view) && (c < x.c));
//   }
//   forceinline bool
//   CardView::operator > (const CardView& x) const {
//     return (view > x.view) || ((view == x.view) && (c > x.c));
//   }






  /// Array containing CardView and supporting lookup operation
  template <class T>
  class CardArray : public ViewArray<T>{
  public:
    int  lookup(int v);
    CardArray(void);
    CardArray(Space* home, int n);
    CardArray(Space* home, const ViewArray<T>& v);
    template <class Var>
    CardArray(Space* home, const VarArgArray<Var>&);
  };

  template <class T>
  forceinline 
  CardArray<T>::CardArray(void) : ViewArray<T>() {};

  template <class T>
  forceinline 
  CardArray<T>::CardArray(Space* home, int n) : ViewArray<T>(home, n) {};

  template <class T>
  forceinline 
  CardArray<T>::CardArray(Space* home, const ViewArray<T>& v) : ViewArray<T>(home, v) {};

  template <class T> template <class Var>
  forceinline 
  CardArray<T>::CardArray(Space* home, const VarArgArray<Var>& v) : ViewArray<T>(home, v) {};

  /**
   * \brief Return the index of v in the array
   *
   *  Complexity is \f$O(log(|k|))\f$
   */
  
  template <class T>
  forceinline int 
  CardArray<T>::lookup(int v){
    int idx = -1;

    int l  = 0;
    int r  = this->size() - 1;

    if (r == 0) {
      if ((*this)[0].card() == v) {
	return 0;
      } else {
	return -1;
      }
    }

    while ( l < r ) {

      if ( (*this)[l].card() == v) {
	idx = l;
	break;
      }
      if ( (*this)[r].card() == v) {
	idx = r;
	break;
      }
      int p  = (l + r) / 2;
      if ( v == (*this)[p].card()) {
	idx = p;
	break;
      } else {
	if ( v < (*this)[p].card()) {
	  r = p;
	} else {
	  l = p;
	}
      }
      if (l == r - 1) {
	break;
      }
    }
    return idx;
  }



  // Index the problem variables for staged propagation

  /**
   * \brief Card integer view
   *
   */
  class IdxView : public DerivedViewBase<IntView> {
  protected:
    /// Index in the original problem specification
    int newidx;
    int oldidx;
    using DerivedViewBase<IntView>::view;
  public:
    /// \name Constructors and initialization
    ///@{
    /// Default constructor
    IdxView(void);
    /// Initialize with integer view \a x and offset \a c
    IdxView(const IntView& x, int index);
    /// Initialize with integer view \a x and offset \a c
    void init(const IntView& x, int c);
    /// Return the current variable index
    int index(void) const;
    /// Set the current variable index to \a i
    void index(int i);
    /// Return the initial variable index (before propagation)
    int oldindex(void) const;
    /// Set the initial variable index (before propagation)
    void oldindex(int i);
    ///@}


    /// \name Value access
    ///@{
    void operator=(const IntView& x);
    /// Return minimum of domain
    int min(void) const;
    /// Return maximum of domain
    int max(void) const;
    /// Return median of domain
    int med(void) const;
    /// Return assigned value (only if assigned)
    int val(void) const;
    /// Return used IntView
    IntView intview(void);
    /// Return size (cardinality) of domain
    unsigned int size(void) const;
    /// Return width of domain (distance between maximum and minimum)
    unsigned int width(void) const;
    /// Return regret of domain minimum (distance to next larger value)
    unsigned int regret_min(void) const;
    /// Return regret of domain maximum (distance to next smaller value)
    unsigned int regret_max(void) const;
    ///@}

    /// \name Domain tests
    ///@{
    /// Test whether domain is a range
    bool range(void) const;
    /// Test whether view is assigned
    bool assigned(void) const;

    /// Test whether \a n is contained in domain
    bool in(int n) const;
    /// Test whether \a n is contained in domain
    bool in(double n) const;
    ///@}

    /// \name Domain update by value
    ///@{
    /// Restrict domain values to be less or equal than \a n
    ModEvent lq(Space* home, int n); 
    /// Restrict domain values to be less or equal than \a n
    ModEvent lq(Space* home, double n);
    /// Restrict domain values to be less than \a n
    ModEvent le(Space* home, int n); 
    /// Restrict domain values to be less than \a n
    ModEvent le(Space* home, double n);
    /// Restrict domain values to be greater or equal than \a n
    ModEvent gq(Space* home, int n); 
    /// Restrict domain values to be greater or equal than \a n
    ModEvent gq(Space* home, double n);
    /// Restrict domain values to be greater than \a n
    ModEvent gr(Space* home, int n); 
    /// Restrict domain values to be greater than \a n
    ModEvent gr(Space* home, double n);
    /// Restrict domain values to be different from \a n
    ModEvent nq(Space* home, int n); 
    /// Restrict domain values to be different from \a n
    ModEvent nq(Space* home, double n);
    /// Restrict domain values to be equal to \a n
    ModEvent eq(Space* home, int n); 
    /// Restrict domain values to be equal to \a n
    ModEvent eq(Space* home, double n);
    ///@}

    /// \name Domain update by range iterator
    ///@{
    /// Replace domain by range sequence described by \a i
    template <class I> ModEvent narrow(Space* home, I& i);
    /// Intersect domain with range sequence described by \a i
    template <class I> ModEvent inter(Space* home, I& i);
    /// Remove from domain the range sequence described by \a i
    template <class I> ModEvent minus(Space* home, I& i);
    ///@}

    /// \name Propagator modification events
    ///@{
    /// Return modification event of propagator \a p for view
    static ModEvent     pme(const Propagator* p);
    /// Translate modification event \a me to propagator modification event for view
    static PropModEvent pme(ModEvent me);
    ///@}

    /// \name Dependencies
    ///@{
    /// Subscribe propagator \a p with propagation condition \a pc to view
    void subscribe(Space* home, Propagator* p, PropCond pc);
    /// Cancel subscription of propagator \a p with propagation condition \a pc to view
    void cancel(Space* home, Propagator* p, PropCond pc);
    ///@}

    /// \name Cloning
    ///@{
    /// Update this view to be a clone of view \a x
    void update(Space* home, bool share, IdxView& x);
    ///@}

    /// \name View comparison
    ///@{
    /// Test whether this view is the same as \a x
    bool operator ==(const IdxView& x) const;
    /// Test whether this view is not the same as \a x
    bool operator !=(const IdxView& x) const;
    /// Test whether this view is smaller than \a x (arbitrary order)
    bool operator < (const IdxView& x) const;
    /// Test whether this view is larger than \a x (arbitrary order)
    bool operator > (const IdxView& x) const;
    ///@}
  };

  /*
   * Constructors and initialization
   *
   */
  forceinline
  IdxView::IdxView(void) {}

  forceinline
  IdxView::IdxView(const IntView& x, int i)
    : DerivedViewBase<IntView>(x), newidx(i), oldidx(i) {}

  forceinline void
  IdxView::init(const IntView& x, int i) {
    view = x; 
    newidx = i;
    oldidx = i;
  }
  forceinline int
  IdxView::index(void) const {
    return newidx;
  }
  forceinline void
  IdxView::index(int i) {
    newidx = i;
  }

  forceinline int
  IdxView::oldindex(void) const {
    return oldidx;
  }
  forceinline void
  IdxView::oldindex(int i) {
    oldidx = i;
  }


  /*
   * Value access
   *
   */
  forceinline void 
  IdxView::operator=(const IntView& x) { 
    view = x; 
    newidx = 0;
    oldidx = 0;
  }

  forceinline int
  IdxView::min(void) const { 
    return view.min(); 
  }
  forceinline int
  IdxView::max(void) const { 
    return view.max(); 
  }
  forceinline int
  IdxView::med(void) const { 
    return view.med(); 
  }

  forceinline int
  IdxView::val(void) const { 
    return view.val(); 
  }

  forceinline IntView
  IdxView::intview(void){ 
    return view;
  }

  forceinline unsigned int
  IdxView::width(void) const { 
    return view.width(); 
  }
  forceinline unsigned int
  IdxView::size(void) const { 
    return view.size(); 
  }
  forceinline unsigned int
  IdxView::regret_min(void) const { 
    return view.regret_min(); 
  }
  forceinline unsigned int
  IdxView::regret_max(void) const { 
    return view.regret_max(); 
  }

  /*
   * Domain tests
   *
   */
  forceinline bool
  IdxView::range(void) const { 
    return view.range(); 
  }
  forceinline bool
  IdxView::assigned(void) const { 
    return view.assigned(); 
  }

  forceinline bool
  IdxView::in(int n) const { 
    return view.in(n); 
  }
  forceinline bool
  IdxView::in(double n) const { 
    return view.in(n); 
  }


  /*
   * Domain update by value
   *
   */
  forceinline ModEvent
  IdxView::lq(Space* home, int n) { 
    return view.lq(home,n); 
  }
  forceinline ModEvent
  IdxView::lq(Space* home, double n) { 
    return view.lq(home,n); 
  }
  forceinline ModEvent
  IdxView::le(Space* home, int n) { 
    return view.le(home,n); 
  }
  forceinline ModEvent
  IdxView::le(Space* home, double n) { 
    return view.le(home,n); 
  }
  forceinline ModEvent
  IdxView::gq(Space* home, int n) { 
    return view.gq(home,n); 
  }
  forceinline ModEvent
  IdxView::gq(Space* home, double n) { 
    return view.gq(home,n); 
  }
  forceinline ModEvent
  IdxView::gr(Space* home, int n) { 
    return view.gr(home,n); 
  }
  forceinline ModEvent
  IdxView::gr(Space* home, double n) { 
    return view.gr(home,n); 
  }
  forceinline ModEvent
  IdxView::nq(Space* home, int n) { 
    return view.nq(home,n); 
  }
  forceinline ModEvent
  IdxView::nq(Space* home, double n) { 
    return view.nq(home,n); 
  }
  forceinline ModEvent
  IdxView::eq(Space* home, int n) { 
    return view.eq(home,n); 
  }
  forceinline ModEvent
  IdxView::eq(Space* home, double n) { 
    return view.eq(home,n); 
  }



  /*
   * Domain update by range iterator
   *
   */
  template <class I>
  ModEvent
  IdxView::narrow(Space* home, I& i) {
    return view.narrow(home, i);
  }

  template <class I>
  ModEvent
  IdxView::inter(Space* home, I& i) {
    return view.inter(home,i);
  }
  template <class I>
  ModEvent
  IdxView::minus(Space* home, I& i) {
    return view.minus(home,i);
  }



  /*
   * Propagator modification events
   *
   */
  forceinline ModEvent
  IdxView::pme(const Propagator* p) {
    return IntView::pme(p);
  }
  forceinline PropModEvent
  IdxView::pme(ModEvent me) {
    return IntView::pme(me);
  }


  /*
   * Dependencies
   *
   */
  forceinline void
  IdxView::subscribe(Space* home, Propagator* p, PropCond pc) {
    view.subscribe(home,p,pc);
  }
  forceinline void
  IdxView::cancel(Space* home, Propagator* p, PropCond pc) {
    view.cancel(home,p,pc);
  }


  /*
   * Cloning
   *
   */
  forceinline void
  IdxView::update(Space* home, bool share, IdxView& x) {
    newidx = x.newidx; 
    oldidx = x.oldidx;
    view.update(home,share,x.view);
  }

  /*
   * View comparison
   *
   */
//   forceinline bool
//   IdxView::operator ==(const IdxView& x) const {
//     return (view == x.view) 
//       && (newidx == x.newidx) 
//       && (oldidx == x.oldidx);
//   }
//   forceinline bool
//   IdxView::operator !=(const IdxView& x) const {
//     return (view != x.view) || (newidx != x.newidx) || (oldidx != x.oldidx);
//   }
//   forceinline bool
//   IdxView::operator < (const IdxView& x) const {
//     return (view < x.view) || 
//       ((view == x.view) && (newidx < x.newidx) && (oldidx < x.oldidx));
//   }
//   forceinline bool
//   IdxView::operator > (const IdxView& x) const {
//     return (view > x.view) || 
//       ((view == x.view) && (newidx > x.newidx) && (oldidx > x.oldidx));
//   }

}

  /**
   * \brief %Range iterator for indexed problem variables
   */
  template <>
  class ViewRanges<GCC::IdxView>
    : public Gecode::Int::ViewRanges<IntView> {
  public:
    /// \name Constructors and initialization
    ///@{
    /// Default constructor
    ViewRanges(void);
    /// Initialize with ranges for view \a x
    ViewRanges(const GCC::IdxView& x);
    /// Initialize with ranges for view \a x
    void init(const GCC::IdxView& x);
    ///@}
  };

  /// \brief Debugging: print an index view
  forceinline std::ostream&
  operator<<(std::ostream& os, GCC::IdxView& v) {
    if (v.min() == v.max()) {
      os << v.min() <<" ";
    } else {
      if (v.range()){
	os << "["<<v.min() <<".."<<v.max()<<"] ";
      } else {
	os << "{";
	ViewValues<GCC::IdxView> iter(v);
	while(iter()){
	  os << iter.val() <<",";
	  ++iter;
	}     
	os << "} ";
      }
    }
    return os;
  }


  forceinline
  ViewRanges<GCC::IdxView>::ViewRanges(void) : 
    Gecode::Int::ViewRanges<IntView>()  {}

  forceinline
  ViewRanges<GCC::IdxView>::ViewRanges (const GCC::IdxView& x) 
    : Gecode::Int::ViewRanges<IntView>(x.base())  {}

  forceinline void
  ViewRanges<GCC::IdxView>::init(const GCC::IdxView& x) {
    Gecode::Int::ViewRanges<IntView> xi(x.base());
  }

  /*
   * View comparison
   *
   */
  forceinline bool
  same(const GCC::IdxView& x, const GCC::IdxView& y) {
    return same(x.base(),y.base()) && (x.index() == y.index());
  }
  forceinline bool
  before(const GCC::IdxView& x, const GCC::IdxView& y) {
    return before(x.base(),y.base())
      || (same(x.base(),y.base()) && (x.index() < y.index()));
  }




  /**
   * \brief %Range iterator for indexed problem variables
   */
  template <>
  class ViewRanges<GCC::CardView>
    : public Gecode::Int::ViewRanges<IntView> {
  public:
    /// \name Constructors and initialization
    ///@{
    /// Default constructor
    ViewRanges(void);
    /// Initialize with ranges for view \a x
    ViewRanges(const GCC::CardView& x);
    /// Initialize with ranges for view \a x
    void init(const GCC::CardView& x);
    ///@}
  };


  /// \brief Debugging: print a cardinality variable
  forceinline std::ostream&
  operator<<(std::ostream& os, GCC::CardView& v) {
    os << "("<<v.card() << ","<< v.counter() <<",";
    if (v.min() == v.max()) {
      os << v.min() <<" ";
    } else {
      if (v.range()){
	os << "["<<v.min() <<".."<<v.max()<<"] ";
      } else {
	os << "{";
	ViewValues<GCC::CardView> iter(v);
	while(iter()){
	  os << iter.val() <<",";
	  ++iter;
	}     
	os << "}";
      }
    }
    os << ")";
    return os;
  }


  forceinline
  ViewRanges<GCC::CardView>::ViewRanges(void) : 
    Gecode::Int::ViewRanges<IntView>()  {}

  forceinline
  ViewRanges<GCC::CardView>::ViewRanges (const GCC::CardView& x) 
    : Gecode::Int::ViewRanges<IntView>(x.base())  {}

  forceinline void
  ViewRanges<GCC::CardView>::init(const GCC::CardView& x) {
    Gecode::Int::ViewRanges<IntView> xi(x.base());
  }

}}



// STATISTICS: int-prop
