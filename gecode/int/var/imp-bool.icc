/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Christian Schulte <schulte@gecode.org>
 *
 *  Copyright:
 *     Christian Schulte, 2006
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

namespace Gecode { namespace Int {

  /*
   * Creation of new variable implementations
   *
   */
  forceinline
  BoolVarImp::BoolVarImp(int n)
    : dom((n << 1) | n) {}
  forceinline
  BoolVarImp::BoolVarImp(Space* home, int min, int max)
    : BoolVarImpBase(home), dom((max << 1) | min) {}


  /*
   * Operations on integer variable implementations
   *
   */
  forceinline BoolStatus
  BoolVarImp::status(void) const {
    GECODE_ASSUME(dom >= 0); GECODE_ASSUME(dom <= 3);
    return dom;
  }
  forceinline int
  BoolVarImp::min(void) const {
    int n = static_cast<int>(dom & 1);
    GECODE_ASSUME(n >= 0); GECODE_ASSUME(n <= 1);
    return n;
  }
  forceinline int
  BoolVarImp::max(void) const {
    int n = static_cast<int>(dom >> 1);
    GECODE_ASSUME(n >= 0); GECODE_ASSUME(n <= 1);
    return n;
  }
  forceinline int
  BoolVarImp::med(void) const {
    return min();
  }

  forceinline int
  BoolVarImp::val(void) const {
    assert(dom != NONE);    
    return min();
  }

  forceinline bool
  BoolVarImp::range(void) const {
    return true;
  }
  forceinline bool
  BoolVarImp::assigned(void) const {
    return dom != NONE;
  }


  forceinline unsigned int
  BoolVarImp::width(void) const {
    return (dom != NONE) ? 1 : 2;
  }

  forceinline unsigned int
  BoolVarImp::size(void) const {
    return (dom != NONE) ? 1 : 2;
  }

  forceinline unsigned int
  BoolVarImp::regret_min(void) const {
    return (dom != NONE) ? 1 : 0;
  }
  forceinline unsigned int
  BoolVarImp::regret_max(void) const {
    return (dom != NONE) ? 1 : 0;
  }



  /*
   * Tests
   *
   */

  forceinline bool
  BoolVarImp::in(int n) const {
    return (n >= min()) && (n <= max());
  }
  forceinline bool
  BoolVarImp::in(double n) const {
    return (n >= min()) && (n <= max());
  }


  /*
   * Boolean domain tests
   *
   */
  forceinline bool
  BoolVarImp::zero(void) const {
    return dom < NONE;
  }
  forceinline bool
  BoolVarImp::one(void) const {
    return dom > NONE;
  }
  forceinline bool
  BoolVarImp::none(void) const {
    return dom == NONE;
  }

  
  /*
   * Specialized notification
   *
   */
  forceinline bool
  BoolVarImp::notify(Space* home, ModEvent me) {
    int n = 1 - val();
    IntDelta d(n,n);
    return BoolVarImpBase::notify(home,me,&d);
  }


  /*
   * Support for delta information
   *
   */
  forceinline ModEvent
  BoolVarImp::modevent(const Delta* d) {
    return d->modevent();
  }
  forceinline int 
  BoolVarImp::min(const Delta* d) const {
    return static_cast<const IntDelta*>(d)->min();
  }
  forceinline int 
  BoolVarImp::max(const Delta* d) const {
    return static_cast<const IntDelta*>(d)->max();
  }
  forceinline bool 
  BoolVarImp::any(const Delta* d) const {
    return static_cast<const IntDelta*>(d)->any();
  }


  /*
   * Boolean tell operations (assume not yet assigned 0/1 variable)
   *
   */
  forceinline ModEvent
  BoolVarImp::zero_none(Space* home) {
    assert(none());
    dom = ZERO;
    if (!notify(home,ME_BOOL_VAL))
      return ME_INT_FAILED;
    return ME_BOOL_VAL;
  }
  forceinline ModEvent
  BoolVarImp::zero(Space* home) {
    if (one())  return ME_BOOL_FAILED;
    if (zero()) return ME_BOOL_NONE;
    return zero_none(home);
  }

  forceinline ModEvent
  BoolVarImp::one_none(Space* home) {
    assert(none());
    dom = ONE;
    if (!notify(home,ME_BOOL_VAL))
      return ME_INT_FAILED;
    return ME_BOOL_VAL;
  }
  forceinline ModEvent
  BoolVarImp::one(Space* home) {
    if (one())  return ME_BOOL_NONE;
    if (zero()) return ME_BOOL_FAILED;
    return one_none(home);
  }


  /*
   * Tell operations
   *
   */
  forceinline ModEvent
  BoolVarImp::gq(Space* home, int n) {
    if (n <= 0) return ME_INT_NONE;
    if (n > 1)  return ME_INT_FAILED;
    if (zero())
      return (n == 0) ? ME_INT_NONE : ME_INT_FAILED;
    if (one())
      return ME_INT_NONE;
    assert(none());
    if (n != 0) {
      assert(n == 1);
      dom = ONE;
      if (!notify(home,ME_BOOL_VAL))
        return ME_INT_FAILED;
      return ME_INT_VAL;
    } else {
      return ME_INT_NONE;
    }
  }
  forceinline ModEvent
  BoolVarImp::gq(Space* home, double n) {
    if (n <= 0) return ME_INT_NONE;
    if (n > 1)  return ME_INT_FAILED;
    if (zero())
      return (n == 0) ? ME_INT_NONE : ME_INT_FAILED;
    if (one())
      return ME_INT_NONE;
    assert(none());
    if (n != 0) {
      assert(n == 1);
      dom = ONE;
      if (!notify(home,ME_BOOL_VAL))
        return ME_INT_FAILED;
      return ME_INT_VAL;
    } else {
      return ME_INT_NONE;
    }
  }


  forceinline ModEvent
  BoolVarImp::lq(Space* home, int n) {
    if (n < 0)  return ME_INT_FAILED;
    if (n >= 1) return ME_INT_NONE;
    if (zero())
      return ME_INT_NONE;
    if (one())
      return (n == 1) ? ME_INT_NONE : ME_INT_FAILED;
    assert(none());
    if (n == 0) {
      dom = ZERO;
      if (!notify(home,ME_BOOL_VAL))
        return ME_INT_FAILED;
      return ME_INT_VAL;
    } else {
      return ME_INT_NONE;
    }
  }
  forceinline ModEvent
  BoolVarImp::lq(Space* home, double n) {
    if (n < 0)  return ME_INT_FAILED;
    if (n >= 1) return ME_INT_NONE;
    if (zero())
      return ME_INT_NONE;
    if (one())
      return (n == 1) ? ME_INT_NONE : ME_INT_FAILED;
    assert(none());
    if (n == 0) {
      dom = ZERO;
      if (!notify(home,ME_BOOL_VAL))
        return ME_INT_FAILED;
      return ME_INT_VAL;
    } else {
      return ME_INT_NONE;
    }
  }


  forceinline ModEvent
  BoolVarImp::eq(Space* home, int n) {
    if ((n < 0) || (n > 1)) return ME_INT_FAILED;
    if (n == 0) {
      if (zero()) return ME_INT_NONE;
      if (one())  return ME_INT_FAILED;
      assert(none());
      dom = ZERO;
    } else {
      assert(n == 1);
      if (zero()) return ME_INT_FAILED;
      if (one())  return ME_INT_NONE;
      assert(none());
      dom = ONE;
    }
    if (!notify(home,ME_BOOL_VAL))
      return ME_INT_FAILED;
    return ME_INT_VAL;
  }
  forceinline ModEvent
  BoolVarImp::eq(Space* home, double n) {
    if ((n < 0) || (n > 1)) return ME_INT_FAILED;
    if (n == 0) {
      if (zero()) return ME_INT_NONE;
      if (one())  return ME_INT_FAILED;
      assert(none());
      dom = ZERO;
    } else {
      assert(n == 1);
      if (zero()) return ME_INT_FAILED;
      if (one())  return ME_INT_NONE;
      assert(none());
      dom = ONE;
    }
    if (!notify(home,ME_BOOL_VAL))
      return ME_INT_FAILED;
    return ME_INT_VAL;
  }


  forceinline ModEvent
  BoolVarImp::nq(Space* home, int n) {
    if ((n < 0) || (n > 1)) return ME_INT_NONE;
    if (n == 0) {
      if (zero()) return ME_INT_FAILED;
      if (one())  return ME_INT_NONE;
      assert(none());
      dom = ONE;
    } else {
      assert(n == 1);
      if (zero()) return ME_INT_NONE;
      if (one())  return ME_INT_FAILED;
      assert(none());
      dom = ZERO;
    }
    if (!notify(home,ME_BOOL_VAL))
      return ME_INT_FAILED;
    return ME_INT_VAL;
  }
  forceinline ModEvent
  BoolVarImp::nq(Space* home, double n) {
    if ((n < 0) || (n > 1)) return ME_INT_NONE;
    if (n == 0) {
      if (zero()) return ME_INT_FAILED;
      if (one())  return ME_INT_NONE;
      assert(none());
      dom = ONE;
    } else {
      assert(n == 1);
      if (zero()) return ME_INT_NONE;
      if (one())  return ME_INT_FAILED;
      assert(none());
      dom = ZERO;
    }
    if (!notify(home,ME_BOOL_VAL))
      return ME_INT_FAILED;
    return ME_INT_VAL;
  }


  /*
   * Copying a variable
   *
   */

  forceinline
  BoolVarImp::BoolVarImp(Space* home, bool share, BoolVarImp& x)
    : BoolVarImpBase(home,share,x), dom(x.dom) {}
  forceinline BoolVarImp*
  BoolVarImp::copy(Space* home, bool share) {
    if (copied())
      return static_cast<BoolVarImp*>(forward());
    else if (zero())
      return &s_zero;
    else if (one())
      return &s_one;
    else
      return new (home) BoolVarImp(home,share,*this);
  }


  /*
   * More domain operations
   *
   */
  template <class I>
  forceinline ModEvent
  BoolVarImp::narrow(Space* home, I& i) {
    // Is new domain empty?
    if (!i())
      return ME_INT_FAILED;
    assert((i.min() == 0) || (i.min() == 1)); 
    assert((i.max() == 0) || (i.max() == 1)); 
    if (i.max() == 0) {
      assert(!one());
      // Assign domain to be zero (domain cannot be one)
      return zero(home);
    }
    if (i.min() == 1) {
      // Assign domain to be one (domain cannot be zero)
      assert(!zero());
      return one(home);
    }
    assert(none());
    return ME_INT_NONE;
  }
  template <class I>
  forceinline ModEvent
  BoolVarImp::inter(Space* home, I& i) {
    // Skip all ranges that are too small
    while (i() && (i.max() < 0))
      ++i;
    // Is new domain empty?
    if (!i() || (i.min() > 1))
      return ME_INT_FAILED;
    assert(i.min() <= 1);
    if (i.min() == 1)
      return one(home);
    if (i.max() == 0)
      return zero(home);
    assert((i.min() <= 0) && (i.max() >= 1));
    return ME_INT_NONE;
  }
  template <class I>
  forceinline ModEvent
  BoolVarImp::minus(Space* home, I& i) {
    // Skip all ranges that are too small
    while (i() && (i.max() < 0))
      ++i;
    // Is new domain empty?
    if (!i() || (i.min() > 1))
      return ME_INT_NONE;
    assert(i.min() <= 1);
    if (i.min() == 1)
      return zero(home);
    if (i.max() == 0)
      return one(home);
    assert((i.min() <= 0) && (i.max() >= 1));
    return ME_INT_FAILED;
  }

  /*
   * Dependencies
   *
   */
  forceinline void
  BoolVarImp::subscribe(Space* home, Propagator* p, PropCond pc, 
                        bool process) {
    // Subscription can be used with integer propagation conditions,
    // which must be remapped to the single Boolean propagation condition.
    BoolVarImpBase::subscribe(home,p,PC_BOOL_VAL,assigned(),process);
  }
  forceinline void
  BoolVarImp::cancel(Space* home, Propagator* p, PropCond pc) {
    BoolVarImpBase::cancel(home,p,PC_BOOL_VAL,assigned());
  }

  forceinline void
  BoolVarImp::subscribe(Space* home, Advisor* a) {
    BoolVarImpBase::subscribe(home,a,assigned());
  }
  forceinline void
  BoolVarImp::cancel(Space* home, Advisor* a) {
    BoolVarImpBase::cancel(home,a,assigned());
  }

}}

// STATISTICS: int-var
