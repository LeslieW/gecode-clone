/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Christian Schulte <schulte@gecode.org>
 *
 *  Contributing authors:
 *     Guido Tack <tack@gecode.org>
 *
 *  Copyright:
 *     Christian Schulte, 2003
 *     Guido Tack, 2004
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

namespace Gecode { namespace Int {

  /*
   * Range lists
   *
   */

#define GECODE_INT_RL2PD(r) reinterpret_cast<ptrdiff_t>(r)
#define GECODE_INT_PD2RL(p) reinterpret_cast<RangeList*>(p)

  forceinline
  IntVarImp::RangeList::RangeList(void) {}

  forceinline
  IntVarImp::RangeList::RangeList(int min, int max)
    : _min(min), _max(max) {}

  forceinline
  IntVarImp::RangeList::RangeList(int min, int max, RangeList* p, RangeList* n)
    : _min(min), _max(max) {
    _next = GECODE_INT_PD2RL(GECODE_INT_RL2PD(p)^GECODE_INT_RL2PD(n));
  }

  forceinline IntVarImp::RangeList*
  IntVarImp::RangeList::next(const RangeList* p) const {
    return GECODE_INT_PD2RL(GECODE_INT_RL2PD(_next)^GECODE_INT_RL2PD(p));
  }
  forceinline IntVarImp::RangeList*
  IntVarImp::RangeList::prev(const RangeList* n) const {
    return GECODE_INT_PD2RL(GECODE_INT_RL2PD(_next)^GECODE_INT_RL2PD(n));
  }
  forceinline void
  IntVarImp::RangeList::prevnext(RangeList* p, RangeList* n) {
    _next = GECODE_INT_PD2RL(GECODE_INT_RL2PD(p)^GECODE_INT_RL2PD(n));
  }
  forceinline void
  IntVarImp::RangeList::next(RangeList* o, RangeList* n) {
    _next = GECODE_INT_PD2RL(GECODE_INT_RL2PD(_next)^
                             (GECODE_INT_RL2PD(o)^GECODE_INT_RL2PD(n)));
  }
  forceinline void
  IntVarImp::RangeList::prev(RangeList* o, RangeList* n) {
    _next = GECODE_INT_PD2RL(GECODE_INT_RL2PD(_next)^
                             (GECODE_INT_RL2PD(o)^GECODE_INT_RL2PD(n)));
  }
  forceinline void
  IntVarImp::RangeList::fix(RangeList* n) {
    _next = n;
  }

  forceinline void
  IntVarImp::RangeList::min(int n) {
    _min = n;
  }
  forceinline void
  IntVarImp::RangeList::max(int n) {
    _max = n;
  }

  forceinline int
  IntVarImp::RangeList::min(void) const {
    return _min;
  }
  forceinline int
  IntVarImp::RangeList::max(void) const {
    return _max;
  }
  forceinline unsigned int
  IntVarImp::RangeList::width(void) const {
    return _max - _min + 1;
  }


  forceinline void
  IntVarImp::RangeList::operator delete(void*) {}

  forceinline void
  IntVarImp::RangeList::operator delete(void*, Space*) {
    GECODE_NEVER;
  }

  forceinline void*
  IntVarImp::RangeList::operator new(size_t, Space* home) {
    return home->fl_alloc<sizeof(RangeList)>();
  }

  forceinline void
  IntVarImp::RangeList::dispose(Space* home, RangeList* p, RangeList* l) {
    RangeList* c = this;
    while (c != l) {
      RangeList* n = c->next(p);
      c->fix(n);
      p=c; c=n;
    }
    home->fl_dispose<sizeof(RangeList)>(this,l);
  }

  forceinline void
  IntVarImp::RangeList::dispose(Space* home, RangeList* l) {
    home->fl_dispose<sizeof(RangeList)>(this,l);
  }

  forceinline void
  IntVarImp::RangeList::dispose(Space* home) {
    home->fl_dispose<sizeof(RangeList)>(this,this);
  }

#undef GECODE_INT_RL2PD
#undef GECODE_INT_PD2RL

  /*
   * Mainitaining range lists for variable domain
   *
   */

  forceinline IntVarImp::RangeList*
  IntVarImp::fst(void) const {
    return dom.next(NULL);
  }

  forceinline void
  IntVarImp::fst(IntVarImp::RangeList* f) {
    dom.prevnext(NULL,f);
  }

  forceinline IntVarImp::RangeList*
  IntVarImp::lst(void) const {
    return _lst;
  }

  forceinline void
  IntVarImp::lst(IntVarImp::RangeList* l) {
    _lst = l;
  }

  /*
   * Creation of new variable implementations
   *
   */

  forceinline
  IntVarImp::IntVarImp(Space* home, int min, int max)
    : IntVarImpBase(home), dom(min,max,NULL,NULL), holes(0) {}

  forceinline
  IntVarImp::IntVarImp(Space* home, const IntSet& d)
    : IntVarImpBase(home), dom(d.min(),d.max()) {
    if (d.size() > 1) {
      int n = d.size();
      RangeList* r = reinterpret_cast<RangeList*>
        (home->alloc(sizeof(RangeList)*n));
      fst(r); lst(r+n-1);
      unsigned int h = d.max()-d.min()+1;
      for (int i = n; i--; ) {
        h -= d.width(i);
        r[i].min(d.min(i)); r[i].max(d.max(i));
        r[i].prevnext(&r[i-1],&r[i+1]);
      }
      r[0].prev(&r[-1],NULL);
      r[n-1].next(&r[n],NULL);
      holes = h;
    } else {
      fst(NULL); holes = 0;
    }
  }


  /*
   * Operations on integer variable implementations
   *
   */

  forceinline int
  IntVarImp::min(void) const {
    return dom.min();
  }
  forceinline int
  IntVarImp::max(void) const {
    return dom.max();
  }
  forceinline int
  IntVarImp::val(void) const {
    assert(dom.min() == dom.max());
    return dom.min();
  }

  forceinline bool
  IntVarImp::range(void) const {
    return fst() == NULL;
  }
  forceinline bool
  IntVarImp::assigned(void) const {
    return dom.min() == dom.max();
  }


  forceinline unsigned int
  IntVarImp::width(void) const {
    return dom.width();
  }

  forceinline unsigned int
  IntVarImp::size(void) const {
    return dom.width() - holes;
  }

  forceinline unsigned int
  IntVarImp::regret_min(void) const {
    if (fst() == NULL) {
      return (dom.min() == dom.max()) ? 0 : 1;
    } else if (dom.min() == fst()->max()) {
      return fst()->next(NULL)->min()-dom.min();
    } else {
      return 1;
    }
  }
  forceinline unsigned int
  IntVarImp::regret_max(void) const {
    if (fst() == NULL) {
      return (dom.min() == dom.max()) ? 0 : 1;
    } else if (dom.max() == lst()->min()) {
      return dom.max()-lst()->prev(NULL)->max();
    } else {
      return 1;
    }
  }



  /*
   * Tests
   *
   */

  forceinline bool
  IntVarImp::in(int n) const {
    if ((n < dom.min()) || (n > dom.max()))
      return false;
    return (fst() == NULL) || in_full(n);
  }
  forceinline bool
  IntVarImp::in(double n) const {
    if ((n < dom.min()) || (n > dom.max()))
      return false;
    return (fst() == NULL) || in_full(static_cast<int>(n));
  }


  /*
   * Accessing rangelists for iteration
   *
   */

  forceinline const IntVarImp::RangeList*
  IntVarImp::ranges_fwd(void) const {
    return (fst() == NULL) ? &dom : fst();
  }

  forceinline const IntVarImp::RangeList*
  IntVarImp::ranges_bwd(void) const {
    return (fst() == NULL) ? &dom : lst();
  }



  /*
   * Support for delta information
   *
   */
  forceinline ModEvent
  IntVarImp::modevent(const Delta* d) {
    return d->modevent();
  }
  forceinline int 
  IntVarImp::min(const Delta* d) const {
    return static_cast<const IntDelta*>(d)->min();
  }
  forceinline int 
  IntVarImp::max(const Delta* d) const {
    return static_cast<const IntDelta*>(d)->max();
  }
  forceinline bool 
  IntVarImp::any(const Delta* d) const {
    return static_cast<const IntDelta*>(d)->any(); 
  }


  /*
   * Tell operations (to be inlined: performing bounds checks first)
   *
   */

  forceinline ModEvent
  IntVarImp::gq(Space* home, int n) {
    if (n <= dom.min()) return ME_INT_NONE;
    if (n > dom.max())  return ME_INT_FAILED;
    return gq_full(home,n);
  }
  forceinline ModEvent
  IntVarImp::gq(Space* home, double n) {
    if (n <= dom.min()) return ME_INT_NONE;
    if (n > dom.max())  return ME_INT_FAILED;
    return gq_full(home,static_cast<int>(n));
  }


  forceinline ModEvent
  IntVarImp::lq(Space* home, int n) {
    if (n >= dom.max()) return ME_INT_NONE;
    if (n < dom.min())  return ME_INT_FAILED;
    return lq_full(home,n);
  }
  forceinline ModEvent
  IntVarImp::lq(Space* home, double n) {
    if (n >= dom.max()) return ME_INT_NONE;
    if (n < dom.min())  return ME_INT_FAILED;
    return lq_full(home,static_cast<int>(n));
  }


  forceinline ModEvent
  IntVarImp::eq(Space* home, int n) {
    if ((n < dom.min()) || (n > dom.max()))
      return ME_INT_FAILED;
    if ((n == dom.min()) && (n == dom.max()))
      return ME_INT_NONE;
    dom.min(n); dom.max(n);
    if (!range() && eq_full(home))
      return ME_INT_FAILED;
    IntDelta d;
    if (!notify(home,ME_INT_VAL,&d))
      return ME_INT_FAILED;
    return ME_INT_VAL;
  }
  forceinline ModEvent
  IntVarImp::eq(Space* home, double m) {
    if ((m < dom.min()) || (m > dom.max()))
      return ME_INT_FAILED;
    int n = static_cast<int>(m);
    if ((n == dom.min()) && (n == dom.max()))
      return ME_INT_NONE;
    dom.min(n); dom.max(n);
    IntDelta d;
    if (!notify(home,ME_INT_VAL,&d))
      return ME_INT_FAILED;
    if (!range() && eq_full(home))
      return ME_INT_FAILED;
    return ME_INT_VAL;
  }


  forceinline ModEvent
  IntVarImp::nq(Space* home, int n) {
    if ((n < dom.min()) || (n > dom.max())) 
      return ME_INT_NONE;
    return nq_full(home,n);
  }
  forceinline ModEvent
  IntVarImp::nq(Space* home, double d) {
    if ((d < dom.min()) || (d > dom.max())) 
      return ME_INT_NONE;
    return nq_full(home,static_cast<int>(d));
  }


  /*
   * Tell operations with respect to value iterators
   *
   */

  template <class I>
  forceinline ModEvent
  IntVarImp::prune(Space* home, I& i) {
    // Skip all values that are too small
    while (i() && (i.val() < dom.min())) 
      ++i;

    // Is there no value left or all are too large?
    if (!i() || (i.val() > dom.max()))
      return ME_INT_NONE;

    int v = i.val(); ++i;
    // Is there only a single value to be pruned?
    if (!i() || (i.val() > dom.max()))
      return nq_full(home,v);

    // Set up two sentinel elements
    RangeList f, l;
    // Put all ranges between sentinels
    if (range()) {
      // Create a new rangelist just for simplicity
      RangeList* n = new (home) RangeList(min(),max(),&f,&l);
      f.prevnext(NULL,n); l.prevnext(n,NULL);
    } else {
      // Link the two sentinel elements
      f.prevnext(NULL,fst()); l.prevnext(lst(),NULL);
      fst()->prev(NULL,&f);   lst()->next(NULL,&l);
    }

    // Number of values removed (potential holes)
    unsigned int h = 0;
    // The previous range
    RangeList* p = &f;
    // The current range
    RangeList* r = f.next(NULL);

    while (true) {
      assert((r != &f) && (r != &l));
      if (v > r->max()) {
        // Move to next range
        RangeList* n=r->next(p); p=r; r=n;
        if (r == &l)
          break;
      } else {
        if ((v == r->min()) && (v == r->max())) {
          // Remove range
          h++;
          RangeList* n=r->next(p);
          p->next(r,n); n->prev(r,p);
          r->dispose(home);
          r=n;
          if (r == &l)
            break;
        } else if (v == r->min()) {
          h++; r->min(v+1);
        } else if (v == r->max()) {
          h++; r->max(v-1);
        } else if (v > r->min()) {
          // Create new range before the current one
          assert(v < r->max());
          h++; 
          RangeList* n = new (home) RangeList(r->min(),v-1,p,r);
          r->min(v+1);
          p->next(r,n); r->prev(p,n);
          p=n;
        }
        if (!i())
          break;
        // Move to next value
        v = i.val(); ++i;
      }
    }
    assert((r == &l) || !i());

    // New first and last ranges
    RangeList* fn = f.next(NULL);
    RangeList* ln = l.prev(NULL);
    // All ranges pruned?
    if (fn == &l) {
      fst(NULL); lst(NULL); holes=0;
      return ME_INT_FAILED;
    }

    IntDelta d;

    // Only a single range left?
    if (fn == ln) {
      assert(h > 0);
      dom.min(fn->min()); dom.max(fn->max());
      fn->dispose(home);
      fst(NULL); lst(NULL);
      holes = 0;
      if (assigned()) {
        if (!notify(home,ME_INT_VAL,&d))
          return ME_INT_FAILED;
        return ME_INT_VAL;
      } else {
        if (!notify(home,ME_INT_BND,&d))
          return ME_INT_FAILED;
        return ME_INT_BND;
      }
    }

    // The number of removed values
    holes += h;
    // Unlink sentinel ranges
    fn->prev(&f,NULL); ln->next(&l,NULL);
    // How many values where removed at the bounds
    unsigned int b = ((fn->min()-dom.min()) +
                      (dom.max()-ln->max()));
    // Set new first and last ranges
    fst(fn); lst(ln);

    if (b > 0) {
      assert((dom.min() != fn->min()) || (dom.max() != ln->max()));
      dom.min(fn->min()); dom.max(ln->max());
      holes -= b;
      if (!notify(home,ME_INT_BND,&d))
        return ME_INT_FAILED;
      return ME_INT_BND;
    }

    if (h > 0) {
      assert((dom.min() == fn->min()) && (dom.max() == ln->max()));
      if (!notify(home,ME_INT_DOM,&d))
        return ME_INT_FAILED;
      return ME_INT_DOM;
    }

    return ME_INT_NONE;
  }

  /*
   * Tell operations with respect to range iterators
   *
   */

  template <class I>
  forceinline ModEvent
  IntVarImp::narrow(Space* home, I& ri) {
    // Is new domain empty?
    if (!ri())
      return ME_INT_FAILED;
    int min0 = ri.min();
    int max0 = ri.max();
    ++ri;
    // Is new domain range?
    if (!ri()) {
      // Remove possible rangelist (if it was not a range, the domain
      // must have been narrowed!)
      if (fst()) {
        fst()->dispose(home,NULL,lst());
        fst(NULL); holes = 0;
      }
      const int min1 = dom.min(); dom.min(min0);
      const int max1 = dom.max(); dom.max(max0);
      if ((min0 == min1) && (max0 == max1))
        return ME_INT_NONE;
      if (min0 == max0) {
        IntDelta d;
        if (!notify(home,ME_INT_VAL,&d))
          return ME_INT_FAILED;
        return ME_INT_VAL;
      }
    } else {
      // Construct new rangelist
      RangeList*   f = new (home) RangeList(min0,max0,NULL,NULL);
      RangeList*   l = f;
      unsigned int s = max0-min0+1;
      do {
        RangeList* n = new (home) RangeList(ri.min(),ri.max(),l,NULL);
        l->next(NULL,n);
        l = n;
        s += ri.width();
        ++ri;
      } while (ri());
      if (fst() != NULL)
        fst()->dispose(home,NULL,lst());
      fst(f); lst(l);
      // Check for modification
      if (size() == s)
        return ME_INT_NONE;
      const int min1 = dom.min(); min0 = f->min(); dom.min(min0);
      const int max1 = dom.max(); max0 = l->max(); dom.max(max0);
      holes = width() - s;
      if ((min0 == min1) && (max0 == max1)) {
        IntDelta d;
        if (!notify(home,ME_INT_DOM,&d))
          return ME_INT_FAILED;
        return ME_INT_DOM;
      }
    }
    {
      IntDelta d;
      if (!notify(home,ME_INT_BND,&d))
        return ME_INT_FAILED;
    }
    return ME_INT_BND;
  }

  /*
   * Copying a variable
   *
   */

  forceinline IntVarImp*
  IntVarImp::copy(Space* home, bool share) {
    return copied() ? static_cast<IntVarImp*>(forward())
      : perform_copy(home,share);
  }


  /*
   * Forward range iterator for rangelists
   *
   */

  forceinline
  IntVarImpFwd::IntVarImpFwd(void) {}
  forceinline
  IntVarImpFwd::IntVarImpFwd(const IntVarImp* x)
    : p(NULL), c(x->ranges_fwd()) {}
  forceinline void
  IntVarImpFwd::init(const IntVarImp* x) {
    p=NULL; c=x->ranges_fwd();
  }

  forceinline bool
  IntVarImpFwd::operator()(void) const {
    return c != NULL;
  }
  forceinline void
  IntVarImpFwd::operator++(void) {
    const IntVarImp::RangeList* n=c->next(p); p=c; c=n;
  }

  forceinline int
  IntVarImpFwd::min(void) const {
    return c->min();
  }
  forceinline int
  IntVarImpFwd::max(void) const {
    return c->max();
  }
  forceinline unsigned int
  IntVarImpFwd::width(void) const {
    return c->width();
  }


  /*
   * Backward range iterator for rangelists
   *
   */

  forceinline
  IntVarImpBwd::IntVarImpBwd(void) {}
  forceinline
  IntVarImpBwd::IntVarImpBwd(const IntVarImp* x)
    : n(NULL), c(x->ranges_bwd()) {}
  forceinline void
  IntVarImpBwd::init(const IntVarImp* x) {
    n=NULL; c=x->ranges_bwd();
  }

  forceinline bool
  IntVarImpBwd::operator()(void) const {
    return c != NULL;
  }
  forceinline void
  IntVarImpBwd::operator++(void) {
    const IntVarImp::RangeList* p=c->prev(n); n=c; c=p;
  }

  forceinline int
  IntVarImpBwd::min(void) const {
    return c->min();
  }
  forceinline int
  IntVarImpBwd::max(void) const {
    return c->max();
  }
  forceinline unsigned int
  IntVarImpBwd::width(void) const {
    return c->width();
  }


  /*
   * More domain operations
   *
   */
  template <class I>
  forceinline ModEvent
  IntVarImp::inter(Space* home, I& i) {
    IntVarImpFwd j(this);
    Iter::Ranges::Inter<I,IntVarImpFwd> ij(i,j);
    return narrow(home,ij);
  }

  template <class I>
  forceinline ModEvent
  IntVarImp::minus(Space* home, I& i) {
    IntVarImpFwd j(this);
    Iter::Ranges::Diff<IntVarImpFwd,I> ij(j,i);
    return narrow(home,ij);
  }

  /*
   * Dependencies
   *
   */
  forceinline void
  IntVarImp::subscribe(Space* home, Propagator* p, PropCond pc, bool process) {
    IntVarImpBase::subscribe(home,p,pc,dom.min()==dom.max(),process);
  }
  forceinline void
  IntVarImp::cancel(Space* home, Propagator* p, PropCond pc) {
    IntVarImpBase::cancel(home,p,pc,dom.min()==dom.max());
  }

  forceinline void
  IntVarImp::subscribe(Space* home, Advisor* a) {
    IntVarImpBase::subscribe(home,a,dom.min()==dom.max());
  }
  forceinline void
  IntVarImp::cancel(Space* home, Advisor* a) {
    IntVarImpBase::cancel(home,a,dom.min()==dom.max());
  }

}}

// STATISTICS: int-var
