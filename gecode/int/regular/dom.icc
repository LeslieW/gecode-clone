/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Christian Schulte <schulte@gecode.org>
 *
 *  Copyright:
 *     Christian Schulte, 2004
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

#include "gecode/iter.hh"

namespace Gecode { namespace Int { namespace Regular {


  /*
   * Classes for the layered graph
   *
   */

  /**
   * \brief States are described by number of incoming and outgoing edges
   */
  class State {
  public:
    unsigned int i_deg;
    unsigned int o_deg;
  };

  /**
   * \brief %Edge in the layered graph
   */
  class Edge {
  public:
    State* i_state;
    State* o_state;
    Edge*  next;
    Edge(State* i, State* o, Edge* n);
    static void  operator delete(void*, size_t);
    static void  operator delete(void*,Space*);
    static void* operator new(size_t, Space*);
  };

  forceinline
  Edge::Edge(State* i, State* o, Edge* n)
    : i_state(i), o_state(o), next(n) {}
  forceinline void
  Edge::operator delete(void*, size_t) {}
  forceinline void
  Edge::operator delete(void*,Space*) {}
  forceinline void*
  Edge::operator new(size_t s, Space* home) {
    return home->alloc(s);
  }


  /**
   * \brief Support for a value
   *
   */
  class Support {
  public:
    int   val;
    Edge* edges;
  };


  /**
   * \name Flags for modification in layer
   */
  //@{
  const int MOD_NONE  = 0; ///< No modification
  const int MOD_IDEG  = 1; ///< Indegree has become zero
  const int MOD_ODEG  = 2; ///< Outdegree has become zero
  //@}

  class Layer {
  public:
    Support*     support;
    unsigned int size;
    int          modified;
  };


  /**
   * \brief Iterator for telling variable domains by scanning transitions
   *
   */
  class LayerValues {
  private:
    const Support* s1; 
    const Support* s2; 
  public:
    LayerValues(void);
    LayerValues(const Layer&);
    void init(const Layer&);
    bool operator()(void) const;
    void operator++(void);
    int val(void) const;
  };

  forceinline
  LayerValues::LayerValues(void) {}
  forceinline
  LayerValues::LayerValues(const Layer& l)
    : s1(l.support), s2(l.support+l.size) {}
  forceinline void
  LayerValues::init(const Layer& l) {
    s1=l.support; s2=l.support+l.size;
  }
  forceinline bool
  LayerValues::operator()(void) const {
    return s1<s2;
  }
  forceinline void
  LayerValues::operator++(void) {
    s1++;
  }
  forceinline int
  LayerValues::val(void) const {
    return s1->val;
  }


  /*
   * The layered graph
   *
   */

  template <class View, bool shared>
  forceinline
  Dom<View,shared>::LayeredGraph::LayeredGraph(void) : layers(NULL) {}

  template <class View, bool shared>
  forceinline bool
  Dom<View,shared>::LayeredGraph::constructed(void) const {
    return layers != NULL;
  }

  template <class View, bool shared>
  forceinline ExecStatus
  Dom<View,shared>::LayeredGraph::construct(Space* home,
                                            ViewArray<View> x, 
                                            const DFA& dfa) {
    int n = x.size();
    layers = reinterpret_cast<Layer*>
      (home->alloc(sizeof(Layer)*(n+2))) + 1;

    unsigned int n_states = dfa.n_states();

    // Allocate memory
    State* states = reinterpret_cast<State*>
      (home->alloc(sizeof(State)*(n+1)*n_states));

    // Initialize states (indegree and outdegree)
    for (int i = (n+1)*n_states; i--; ) {
      states[i].i_deg = 0;
      states[i].o_deg = 0;
    }

    // Mark initial state as being reachable
    states[0].i_deg = 1;

    // Mark final states as reachable as well
    for (int s = dfa.final_fst(); s < dfa.final_lst(); s++)
      states[n*n_states + s].o_deg = 1;

    // First pass: add transitions
    for (int i=0; i<n; i++) {
      layers[i].support = 
        reinterpret_cast<Support*>(home->alloc(x[i].size() * sizeof(Support)));
      int j=0;
      // Enter links leaving reachable states (indegree != 0)
      DFA::Transitions ta(dfa);
      ViewValues<View> nx(x[i]);
      while (nx() && ta()) {
        if (ta.transition()->symbol > nx.val()) {
          ++nx;
        } else if (ta.transition()->symbol < nx.val()) {
          ++ta;
        } else {
          int v = nx.val();
          assert(ta.transition()->symbol == v);
          Edge* e = NULL;
          do {
            // Compute pointers to states
            State* i_state = &states[(i  )*n_states + 
                                     ta.transition()->i_state];
            if (i_state->i_deg != 0) {
              // Add new transition as state is reachable
              State* o_state = &states[(i+1)*n_states + 
                                       ta.transition()->o_state];
              i_state->o_deg++; 
              o_state->i_deg++;
              e = new (home) Edge(i_state,o_state,e);
            }
            ++ta;
          } while (ta() && (ta.transition()->symbol == v));
          // Found support for value
          if (e != NULL) {
            layers[i].support[j].val   = v;
            layers[i].support[j].edges = e;
            j++;
          }
          ++nx;
        }
      }
      if (j == 0)
        return ES_FAILED;
      layers[i].size = j;
    }

    // Second pass: prune all transitions that do not lead to final state
    for (int i=n; i--; ) {
      int k=0;
      for (int j=0; j<layers[i].size; j++) {
        Edge** p = &layers[i].support[j].edges;
        for (Edge* e = *p; e != NULL; e = e->next)
          if (e->o_state->o_deg != 0) {
            // This state is still reachable, keep edge
            p = &e->next;
          } else {
            // Unreachable state, prune edge
            e->i_state->o_deg--; e->o_state->i_deg--;
            *p = e->next;
          }
        // Write endmarker for edges
        *p = NULL;
        // Value has support, copy the support information
        if (layers[i].support[j].edges != NULL)
          layers[i].support[k++]=layers[i].support[j];
      }
      if (k == 0)
        return ES_FAILED;
      layers[i].size = k;
    }
    return ES_OK;
  }

  template <class View, bool shared>
  forceinline ExecStatus
  Dom<View,shared>::LayeredGraph::prune(Space* home, ViewArray<View> x) {
    int n = x.size();
    // Forward pass
    for (int i = 0; i < n; i++)
      if ((layers[i].size != x[i].size()) && (layers[i].modified & MOD_IDEG)) {
        int j=0;
        int k=0;
        ViewValues<View> vx(x[i]);
        for ( ; vx() && (j<layers[i].size); j++) {
          assert(layers[i].support[j].val <= vx.val());
          if (layers[i].support[j].val != vx.val()) {
            // Value has lost support
            for (Edge* e=layers[i].support[j].edges; e!=NULL; e=e->next) {
              // Adapt states
              if ((--e->i_state->o_deg) == 0)
                layers[i-1].modified |= MOD_ODEG;
              if ((--e->o_state->i_deg) == 0)
                layers[i+1].modified |= MOD_IDEG;
            }
          } else {
            assert(layers[i].support[j].val == vx.val());
            // Some edges might have lost support
            Edge** p = &layers[i].support[j].edges;
            for (Edge* e = *p; e != NULL; e = e->next) 
              if (e->i_state->i_deg == 0) {
                // Adapt states
                if ((--e->i_state->o_deg) == 0)
                  layers[i-1].modified |= MOD_ODEG;
                if ((--e->o_state->i_deg) == 0)
                  layers[i+1].modified |= MOD_IDEG;
                // Remove edge
                *p = e->next;
              } else {
                // Keep edge
                p = &e->next;
              }
            // Write endmarker for edges
            *p=NULL;
            // Value still has support
            if (layers[i].support[j].edges != NULL)
              layers[i].support[k++]=layers[i].support[j];
            ++vx;
          }
        }
        // Remove remaining values
        for (; j < layers[i].size; j++)
          for (Edge* e=layers[i].support[j].edges; e!=NULL; e=e->next) {
            // Adapt states
            if ((--e->i_state->o_deg) == 0)
              layers[i-1].modified |= MOD_ODEG;
            if ((--e->o_state->i_deg) == 0)
              layers[i+1].modified |= MOD_IDEG;
          }
        // Update size
        if (k == 0)
          return ES_FAILED;
        layers[i].size = k;
      } else if (layers[i].size != x[i].size()) {
        int j=0;
        int k=0;
        ViewValues<View> vx(x[i]);
        for ( ; vx() && (j<layers[i].size); j++) {
          assert(layers[i].support[j].val <= vx.val());
          if (layers[i].support[j].val != vx.val()) {
            // Value has lost support
            for (Edge* e=layers[i].support[j].edges; e!=NULL; e=e->next) {
              // Adapt states
              if ((--e->i_state->o_deg) == 0)
                layers[i-1].modified |= MOD_ODEG;
              if ((--e->o_state->i_deg) == 0)
                layers[i+1].modified |= MOD_IDEG;
            }
          } else {
            layers[i].support[k++]=layers[i].support[j];
            ++vx;
          }
        }
        // Remove remaining values
        for (; j < layers[i].size; j++)
          for (Edge* e=layers[i].support[j].edges; e!=NULL; e=e->next) {
            // Adapt states
            if ((--e->i_state->o_deg) == 0)
              layers[i-1].modified |= MOD_ODEG;
            if ((--e->o_state->i_deg) == 0)
              layers[i+1].modified |= MOD_IDEG;
          }
        // Update size
        if (k == 0)
          return ES_FAILED;
        layers[i].size = k;
      } else if (layers[i].modified & MOD_IDEG) {
        int k=0;
        for (int j=0; j<layers[i].size; j++) {
          // Some edges might have lost support
          Edge** p = &layers[i].support[j].edges;
          for (Edge* e = *p; e != NULL; e = e->next) 
            if (e->i_state->i_deg == 0) {
              // Adapt states
              if ((--e->i_state->o_deg) == 0)
                layers[i-1].modified |= MOD_ODEG;
              if ((--e->o_state->i_deg) == 0)
                layers[i+1].modified |= MOD_IDEG;
              // Remove edge
              *p = e->next;
            } else {
              // Keep edge
              p = &e->next;
            }
          // Write endmarker for edges
          *p=NULL;
          // Value still has support
          if (layers[i].support[j].edges != NULL)
            layers[i].support[k++]=layers[i].support[j];
        }
        // Update size
        if (k == 0)
          return ES_FAILED;
        layers[i].size = k;
      }

    // Backward pass
    for (int i=n; i--; )
      if (layers[i].modified & MOD_ODEG) {
        int k=0;
        for (int j=0; j<layers[i].size; j++) {
          Edge** p = &layers[i].support[j].edges;
          for (Edge* e = *p; e != NULL; e = e->next)
            if (e->o_state->o_deg != 0) {
              // This state is still reachable, keep edge
              p = &e->next;
            } else {
              // Unreachable state, prune edge
              if (--e->i_state->o_deg == 0)
                layers[i-1].modified |= MOD_ODEG;
              --e->o_state->i_deg;
              *p = e->next;
            }
          // Write endmarker for edges
          *p = NULL;
          // Value still has support
          if (layers[i].support[j].edges != NULL)
            layers[i].support[k++]=layers[i].support[j];
        }
        // Update size
        if (k == 0)
          return ES_FAILED;
        layers[i].size = k;
      }
    return ES_OK;
  }

  template <class View, bool shared>
  forceinline ExecStatus
  Dom<View,shared>::LayeredGraph::tell(Space* home, Propagator* p,
                                       ViewArray<View> x) {
    // Tell back variable domains
    if (shared) {
      ExecStatus es = ES_FIX;
      for (int i=x.size(); i--; ) {
        assert(layers[i].size > 0);
        if (x[i].modified())
          es = ES_NOFIX;
        if ((x[i].size() != layers[i].size) ||
            x[i].modified()) {
          LayerValues lv(layers[i]);
          Iter::Values::ToRanges<LayerValues> lr(lv);
          if (x[i].modified()) {
            GECODE_ME_CHECK(x[i].inter(home,lr));
          } else {
            x[i].narrow(home,lr);
          }
        }
        // Reset modification data
        layers[i].modified = MOD_NONE;
      }
      for (int i=x.size(); i--; )
        if (!x[i].assigned())
          return es;
      x.size(0);
      return ES_SUBSUMED(p,home);
    } else {
      int n=x.size();
      for (int i=x.size(); i--; ) {
        assert(layers[i].size > 0);
        if (x[i].size() != layers[i].size) {
          LayerValues lv(layers[i]);
          Iter::Values::ToRanges<LayerValues> lr(lv);
          x[i].narrow(home,lr);
        }
        if (x[i].assigned())
          n--;
        // Reset modification data
        layers[i].modified = MOD_NONE;
      }
      if (n == 0) {
        x.size(0);
        return ES_SUBSUMED(p,home);
      }
      return ES_FIX;
    }
  }

  template <class View, bool shared>
  ExecStatus
  Dom<View,shared>::propagate(Space* home) {
    if (lg.constructed()) {
      GECODE_ES_CHECK(lg.prune(home,this->x));
    } else {
      GECODE_ES_CHECK(lg.construct(home,this->x,dfa));
    }
    return lg.tell(home,this,this->x);
  }

  template <class View, bool shared>
  forceinline
  Dom<View,shared>::Dom(Space* home, ViewArray<View>& x, DFA& d)
    : NaryPropagator<View,PC_INT_DOM>(home,x), dfa(d) {
    this->force(home);
  }

  template <class View, bool shared>
  forceinline size_t
  Dom<View,shared>::dispose(Space* home) {
    this->unforce(home);
    dfa.~DFA();
    (void) NaryPropagator<View,PC_INT_DOM>::dispose(home);
    return sizeof(*this);
  }

  template <class View, bool shared>
  ExecStatus
  Dom<View,shared>::post(Space* home, ViewArray<View>& x, DFA& d) {
    if (x.shared()) {
      (void) new (home) Dom<View,true>(home,x,d);
    } else {
      (void) new (home) Dom<View,false>(home,x,d);
    }
    return ES_OK;
  }

  template <class View, bool shared>
  forceinline
  Dom<View,shared>::Dom(Space* home, bool share, Dom<View,shared>& p)
    : NaryPropagator<View,PC_INT_DOM>(home,share,p) {
    dfa.update(home,share,p.dfa);
  }

  template <class View, bool shared>
  PropCost
  Dom<View,shared>::cost(void) const {
    return cost_hi(this->x.size(), PC_LINEAR_HI);
  }

  template <class View, bool shared>
  Actor*
  Dom<View,shared>::copy(Space* home, bool share) {
    return new (home) Dom<View,shared>(home,share,*this);
  }

}}}

// STATISTICS: int-prop

