/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Christian Schulte <schulte@gecode.org>
 *
 *  Copyright:
 *     Christian Schulte, 2004
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

#include "gecode/iter.hh"

#include "gecode/support/block-allocator.hh"

namespace Gecode { namespace Int { namespace Regular {


  /*
   * Classes for the layered graph
   *
   */

  /**
   * \brief States are described by number of incoming and outgoing edges
   */
  class State {
  public:
    unsigned int i_deg;
    unsigned int o_deg;
  };

  /**
   * \brief %Edge in the layered graph
   */
  class Edge {
  public:
    int    val;
    State* i_state;
    State* o_state;
    Edge*  next;
    static void  operator delete(void*, size_t);
    static void  operator delete(void*,Space*);
    static void* operator new(size_t, Space*);
  };

  forceinline void
  Edge::operator delete(void*, size_t) {}
  forceinline void
  Edge::operator delete(void*,Space*) {}
  forceinline void*
  Edge::operator new(size_t s, Space* home) {
    return home->alloc(s);
  }


  /**
   * \name Flags for modification in layer
   */
  //@{
  const int MOD_NONE  = 0; ///< No modification
  const int MOD_IDEG  = 1; ///< Indegree has become zero
  const int MOD_ODEG  = 2; ///< Outdegree has become zero
  //@}

  class Layer {
  public:
    Edge*        edges;
    unsigned int size;
    int          modified;
  };


  /**
   * \brief Iterator for telling variable domains by scanning transitions
   *
   */
  class EdgeRanges {
  private:
    const Edge* e1; const Edge* e2;
  public:
    EdgeRanges(void);
    EdgeRanges(const Edge*);
    void init(const Edge*);
    bool operator()(void) const;
    void operator++(void);
    int min(void) const;
    int max(void) const;
    unsigned int width(void) const;
  };

  forceinline
  EdgeRanges::EdgeRanges(void) {}
  forceinline
  EdgeRanges::EdgeRanges(const Edge* e)
    : e1(e), e2(e) {
    assert(e1);
    // e2 always points to the end of  the interval
    while ((e2->next != NULL) && (e2->next->val <= e2->val+1))
      e2 = e2->next;
  }
  forceinline void
  EdgeRanges::init(const Edge* e) {
    e1=e; e2=e;
    assert(e1);
    // e2 always points to the end of  the interval
    while ((e2->next != NULL) && (e2->next->val <= e2->val+1))
      e2 = e2->next;
  }

  forceinline bool
  EdgeRanges::operator()(void) const {
    return e1 != NULL;
  }

  forceinline void
  EdgeRanges::operator++(void) {
    e1 = e2->next;
    if (e1 != NULL) {
      e2 = e1;
      while ((e2->next != NULL) && (e2->next->val <= e2->val+1))
        e2 = e2->next;
    }
  }

  forceinline int
  EdgeRanges::min(void) const {
    return e1->val;
  }
  forceinline int
  EdgeRanges::max(void) const {
    return e2->val;
  }
  forceinline unsigned int
  EdgeRanges::width(void) const {
    return max()-min()+1;
  }



  /*
   * The layered graph
   *
   */

  template <class View>
  forceinline
  Dom<View>::LayeredGraph::LayeredGraph(void) : layers(NULL) {}

  template <class View>
  forceinline bool
  Dom<View>::LayeredGraph::constructed(void) const {
    return layers != NULL;
  }

  template <class View>
  forceinline void
  Dom<View>::LayeredGraph::construct(Space* home,
                                     ViewArray<View> x, const DFA& dfa) {
    int n = x.size();
    layers = reinterpret_cast<Layer*>
      (home->alloc(sizeof(Layer)*(n+2))) + 1;

    unsigned int n_states = dfa.n_states();

    // Allocate memory
    State* states = reinterpret_cast<State*>
      (home->alloc(sizeof(State)*(n+1)*n_states));

    // Initialize states (indegree and outdegree)
    for (int i = (n+1)*n_states; i--; ) {
      states[i].i_deg = 0;
      states[i].o_deg = 0;
    }

    // Mark initial state as being reachable
    states[0].i_deg = 1;

    // Mark final states as reachable as well
    for (int s = dfa.final_fst(); s < dfa.final_lst(); s++)
      states[n*n_states + s].o_deg = 1;

    // First pass: add transitions
    for (int i = 0; i < n; i++) {
      Edge** p = &layers[i].edges;
      // Enter links leaving reachable states (indegree != 0)
      DFA::Transitions  t_a(dfa);
      ViewRanges<View>  rx(x[i]);
      while (rx() && t_a()) {
        const DFA::Transition* t = t_a.transition();
        // Compute pointers to states
        State* i_state = &states[(i  )*n_states + t->i_state];
        State* o_state = &states[(i+1)*n_states + t->o_state];
        if (t->symbol > rx.max()) {
          ++rx;
        } else if ((t->symbol >= rx.min()) && (i_state->i_deg > 0)) {
          // Add new transition as state is reachable
          i_state->o_deg++; o_state->i_deg++;
          Edge* e = new (home) Edge;
          e->i_state = i_state;
          e->val     = t->symbol;
          e->o_state = o_state;
          *p = e;
          p = &e->next;
          ++t_a;
        } else {
          ++t_a;
        }
      }
      // Write endmarker for edges
      *p = NULL;
    }
  }

  template <class View>
  forceinline ExecStatus
  Dom<View>::LayeredGraph::prune_initial(Space* home, Propagator* p,
                                         ViewArray<View> x) {
    // Second pass: prune all transitions that do not lead to final state
    for (int i = x.size(); i--; ) {
      Edge** p = &layers[i].edges;
      Edge*  e = *p;
      while (e != NULL) {
        if (e->o_state->o_deg != 0) {
          // This state is still reachable, keep edge
          p = &e->next;
        } else {
          // Unreachable state, prune edge
          *p = e->next;
          e->i_state->o_deg--; e->o_state->i_deg--;
        }
        e = e->next;
      }
      *p = NULL;
    }

    // Tell back variable domains
    ExecStatus es = ES_FIX;
    for (int i=x.size(); i--; ) {
      if (layers[i].edges == NULL)
        return ES_FAILED;
      if (x[i].modified())
        es = ES_NOFIX;
      EdgeRanges er(layers[i].edges);
      if (x[i].modified()) {
        GECODE_ME_CHECK(x[i].inter(home,er));
      } else {
        x[i].narrow(home,er);
      }
      // Initialize size and modification data
      layers[i].modified = MOD_NONE;
      layers[i].size     = x[i].size();
    }
    for (int i=x.size(); i--; )
      if (!x[i].assigned())
        return es;
    x.size(0);
    return ES_SUBSUMED(p,home);
  }

  template <class View>
  forceinline ExecStatus
  Dom<View>::LayeredGraph::prune(Space* home, Propagator* p, 
                                 ViewArray<View> x) {
    int n = x.size();
    // Prune edges for which no value support exists
    for (int i = 0; i < n; i++)
      if (layers[i].size != x[i].size()) {
        layers[i].size = x[i].size();
        Edge** p = &layers[i].edges;
        Edge*  e = *p;
        ViewRanges<View> rx(x[i]);
        while (rx() && (e != NULL)) {
          if (e->val > rx.max()) {
            ++rx;
          } else if ((e->val < rx.min()) || (e->i_state->i_deg == 0)) {
            // Adapt states
            if ((--e->i_state->o_deg) == 0)
              layers[i-1].modified |= MOD_ODEG;
            if ((--e->o_state->i_deg) == 0)
              layers[i+1].modified |= MOD_IDEG;
            // Remove this edge
            *p = e->next; e = e->next;
          } else {
            // Keep edge
            p = &e->next; e = e->next;
          }
        }
        // Write endmarker for edges
        *p = NULL;
        // Remove all remaining edges
        while (e != NULL) {
          // Adapt states
          if (--e->i_state->o_deg == 0)
            layers[i-1].modified |= MOD_ODEG;
          if (--e->o_state->i_deg == 0)
            layers[i+1].modified |= MOD_IDEG;
          e = e->next;
        }
      }  else if (layers[i].modified & MOD_IDEG) {
        assert(layers[i].size == x[i].size());
        Edge** p = &layers[i].edges;
        Edge*  e = *p;
        while (e != NULL) {
          if (e->i_state->i_deg == 0) {
            // Adapt states
            if (--e->i_state->o_deg == 0)
              layers[i-1].modified |= MOD_ODEG;
            if (--e->o_state->i_deg == 0)
              layers[i+1].modified |= MOD_IDEG;
            // Remove this edge
            *p = e->next;
          } else {
            // Keep edge
            p = &e->next;
          }
          e = e->next;
        }
        // Write endmarker for edges
        *p = NULL;
      }

    for (int i=n; i--; )
      if (layers[i].modified & MOD_ODEG) {
        Edge** p = &layers[i].edges;
        Edge*  e = *p;
        while (e != NULL) {
          if (e->o_state->o_deg != 0) {
            // This state is still reachable, keep edge
            p = &e->next;
          } else {
            // Unreachable state, prune edge
            if (--e->i_state->o_deg == 0)
              layers[i-1].modified |= MOD_ODEG;
            --e->o_state->i_deg;
            *p = e->next;
          }
          e = e->next;
        }
        *p = NULL;
      }
    // Tell back variable domains
    ExecStatus es = ES_FIX;
    for (int i=n; i--; )
      if (layers[i].modified) {
        layers[i].modified = MOD_NONE;
        if (layers[i].edges == NULL)
          return ES_FAILED;
        if (x[i].modified())
          es = ES_NOFIX;
        EdgeRanges er(layers[i].edges);
        if (x[i].modified()) {
          GECODE_ME_CHECK(x[i].inter(home,er));
        } else {
          x[i].narrow(home,er);
        }
        layers[i].size = x[i].size();
      }
    for (int i=x.size(); i--; )
      if (!x[i].assigned())
        return es;
    x.size(0);
    return ES_SUBSUMED(p,home);
  }

  template <class View>
  ExecStatus
  Dom<View>::propagate(Space* home) {
    if (lg.constructed()) {
      return lg.prune(home,this,this->x);
    } else {
      lg.construct(home,this->x,dfa);
      return lg.prune_initial(home,this,this->x);
    }
  }

  template <class View>
  forceinline
  Dom<View>::Dom(Space* home, ViewArray<View>& x, DFA& d)
    : NaryPropagator<View,PC_INT_DOM>(home,x), dfa(d) {
    this->force(home);
  }

  template <class View>
  forceinline size_t
  Dom<View>::dispose(Space* home) {
    this->unforce(home);
    dfa.~DFA();
    (void) NaryPropagator<View,PC_INT_DOM>::dispose(home);
    return sizeof(*this);
  }

  template <class View>
  ExecStatus
  Dom<View>::post(Space* home, ViewArray<View>& x, DFA& d) {
    (void) new (home) Dom<View>(home,x,d);
    return ES_OK;
  }

  template <class View>
  forceinline
  Dom<View>::Dom(Space* home, bool share, Dom<View>& p)
    : NaryPropagator<View,PC_INT_DOM>(home,share,p) {
    dfa.update(share,p.dfa);
  }

  template <class View>
  PropCost
  Dom<View>::cost(void) const {
    return cost_hi(this->x.size(), PC_LINEAR_HI);
  }

  template <class View>
  Actor*
  Dom<View>::copy(Space* home, bool share) {
    return new (home) Dom<View>(home,share,*this);
  }

}}}

// STATISTICS: int-prop

