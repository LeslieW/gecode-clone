/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Christian Schulte <schulte@gecode.org>
 *
 *  Copyright:
 *     Christian Schulte, 2004
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

#include "gecode/iter.hh"

namespace Gecode { namespace Int { namespace Regular {


  /*
   * Classes for the layered graph
   *
   */

  /**
   * \brief States are described by number of incoming and outgoing edges
   */
  class State {
  public:
    unsigned int i_deg;
    unsigned int o_deg;
  };

  /**
   * \brief %Edge in the layered graph
   */
  class Edge {
  public:
    State* i_state; ///< Pointer to in-state
    State* o_state; ///< Pointer to out-state
    Edge*  next;    ///< Next edge in support list
    /// Construct new edge and increment states
    Edge(State& i, State& o, Edge* n);
    static void  operator delete(void*, size_t);
    static void  operator delete(void*,Space*);
    static void* operator new(size_t, Space*);
  };

  forceinline
  Edge::Edge(State& i, State& o, Edge* n)
    : i_state(&i), o_state(&o), next(n) {
    i_state->o_deg++; o_state->i_deg++;
  }
  forceinline void
  Edge::operator delete(void*, size_t) {}
  forceinline void
  Edge::operator delete(void*,Space*) {}
  forceinline void*
  Edge::operator new(size_t s, Space* home) {
    return home->alloc(s);
  }


  /// Support information for a value
  class Support {
  public:
    int   val;   ///< Supported value
    Edge* edges; ///< Supporting edges in layered graph
  };

  /**
   * \name Flags for modification in layer
   */
  //@{
  const int MOD_NONE  = 0; ///< No modification
  const int MOD_IDEG  = 1; ///< Indegree has become zero
  const int MOD_ODEG  = 2; ///< Outdegree has become zero
  //@}

  /// Layer for a view in the layered graph
  class Layer {
  public:
    unsigned int size;     ///< Number of supported values
    Support*     support;  ///< Supported values
    int          modified; ///< Modification information
  };

  /// Iterator for telling variable domains by scanning support
  class LayerValues {
  private:
    const Support* s1; ///< Current support
    const Support* s2; ///< End of support
  public:
    /// Default constructor
    LayerValues(void);
    /// Initialize for support of layer \a l
    LayerValues(const Layer& l);
    /// Initialize for support of layer \a l
    void init(const Layer& l);
    /// Test whether more values supported
    bool operator()(void) const;
    /// Move to next supported value
    void operator++(void);
    /// Return supported value
    int val(void) const;
  };

  forceinline
  LayerValues::LayerValues(void) {}
  forceinline
  LayerValues::LayerValues(const Layer& l)
    : s1(l.support), s2(l.support+l.size) {}
  forceinline void
  LayerValues::init(const Layer& l) {
    s1=l.support; s2=l.support+l.size;
  }
  forceinline bool
  LayerValues::operator()(void) const {
    return s1<s2;
  }
  forceinline void
  LayerValues::operator++(void) {
    s1++;
  }
  forceinline int
  LayerValues::val(void) const {
    return s1->val;
  }


  /*
   * The layered graph
   *
   */

  template <class View, bool shared>
  forceinline bool
  Dom<View,shared>::constructed(void) const {
    return layers != NULL;
  }

  template <class View, bool shared>
  forceinline void
  Dom<View,shared>::eliminate(void) {
    if (!constructed() || (layers[0].size > 1))
      return;
    assert(layers[0].size == 1);
    // Skip all layers corresponding to assigned views
    int i = 1;
    while (layers[i].size == 1)
      i++;
    // There is only a single edge
    Edge* e = layers[i-1].support[0].edges;
    assert((e->next == NULL) && (e->o_state->i_deg == 1));
    // Map the state address to the state
    start = static_cast<int>(e->o_state-states) % dfa.n_states();
    layers += i;
    x.drop_fst(i);
  }

  template <class View, bool shared>
  forceinline ExecStatus
  Dom<View,shared>::construct(Space* home) {
    int n = x.size();
    layers = reinterpret_cast<Layer*>(home->alloc(sizeof(Layer)*(n+2)))+1;
    
    unsigned int n_states = dfa.n_states();

    // Allocate memory
    states = reinterpret_cast<State*>
      (home->alloc(sizeof(State)*(n+1)*n_states));

    // Initialize states (indegree and outdegree)
    for (int i = (n+1)*n_states; i--; )
      states[i].i_deg = states[i].o_deg = 0;

    // Mark initial state as being reachable
    states[start].i_deg = 1;

    // Mark final states as reachable as well
    for (int s = dfa.final_fst(); s < dfa.final_lst(); s++)
      states[n*n_states + s].o_deg = 1;

    // Forward pass: add transitions
    for (int i=0; i<n; i++) {
      layers[i].modified = MOD_NONE;
      layers[i].support = 
        reinterpret_cast<Support*>(home->alloc(x[i].size()*sizeof(Support)));
      unsigned int j=0;
      // Enter links leaving reachable states (indegree != 0)
      DFA::Transitions t(dfa);
      ViewValues<View> nx(x[i]);
      while (nx()) {
        while (t.symbol() < nx.val())
          ++t;
        assert(t.symbol() == nx.val());
        Edge* e = NULL;
        do {
          // Is in-state of transition reachable?
          if (states[i*n_states + t.i_state()].i_deg != 0)
            e = new (home) Edge(states[i*n_states + t.i_state()],
                                states[(i+1)*n_states +  t.o_state()],
                                e);
          ++t;
        } while (t() && (t.symbol() == nx.val()));
        // Found support for value
        if (e != NULL) {
          layers[i].support[j].val   = nx.val();
          layers[i].support[j].edges = e;
          j++;
        }
        ++nx;
      }
      layers[i].size = j;
      if (j == 0)
        return ES_FAILED;
    }

    bool mod      = false;
    bool assigned = true;
    
    // Backward pass: prune all transitions that do not lead to final state
    for (int i=n; i--; ) {
      unsigned int k=0;
      for (unsigned int j=0; j<layers[i].size; j++) {
        Edge** p = &layers[i].support[j].edges;
        for (Edge* e = *p; e != NULL; e = e->next)
          if (e->o_state->o_deg != 0) {
            // This state is still reachable, keep edge
            p = &e->next;
          } else {
            // Unreachable state, prune edge
            e->i_state->o_deg--; e->o_state->i_deg--;
            *p = e->next;
          }
        // Write endmarker for edges
        *p = NULL;
        // Value has support, copy the support information
        if (layers[i].support[j].edges != NULL)
          layers[i].support[k++]=layers[i].support[j];
      }
      layers[i].size = k;
      if (k == 0)
        return ES_FAILED;
      if (shared && x[i].modified()) {
        LayerValues lv(layers[i]);
        ModEvent me = x[i].inter_v(home,lv,false);
        if (me_failed(me))
          return ES_FAILED;
        if (me_modified(me))
          mod = true;
      } else if (x[i].size() != layers[i].size) {
        LayerValues lv(layers[i]);
        GECODE_ME_CHECK(x[i].narrow_v(home,lv,false));
      }
      if (!x[i].assigned())
        assigned = false;
    }

    if (assigned)
      return ES_SUBSUMED(this,home);
    return (shared && mod) ? ES_NOFIX : ES_FIX;
  }

  template <class View, bool shared>
  forceinline ExecStatus
  Dom<View,shared>::prune(Space* home) {
    // Synchronize views
    for (int i=0; i<x.size(); i++)
      if (layers[i].size != x[i].size()) {
        int moddeg = MOD_NONE;
        unsigned int j=0;
        unsigned int k=0;
        for (ViewValues<View> vx(x[i]); vx() && (j<layers[i].size); j++)
          if (layers[i].support[j].val < vx.val()) {
            // Supported value not any longer in view
            for (Edge* e=layers[i].support[j].edges; e!=NULL; e=e->next) {
              // Adapt states
              if ((--e->i_state->o_deg) == 0) moddeg |= MOD_ODEG;
              if ((--e->o_state->i_deg) == 0) moddeg |= MOD_IDEG;
            }
          } else {
            assert(layers[i].support[j].val == vx.val());
            layers[i].support[k++]=layers[i].support[j];
            ++vx;
          }
        if (k == 0)
          return ES_FAILED;
        // Remove remaining values
        for (; j < layers[i].size; j++)
          for (Edge* e=layers[i].support[j].edges; e!=NULL; e=e->next) {
            // Adapt states
            if ((--e->i_state->o_deg) == 0) moddeg |= MOD_ODEG;
            if ((--e->o_state->i_deg) == 0) moddeg |= MOD_IDEG;
          }
        // Update size and modification information
        layers[i].size = k;
        layers[i-1].modified |= (moddeg & MOD_ODEG);
        layers[i+1].modified |= (moddeg & MOD_IDEG);
      }

    ExecStatus es = ES_FIX;
    // Forward pass
    for (int i=0; i<x.size(); i++) 
      if (layers[i].modified & MOD_IDEG) {
        bool premod = shared & x[i].modified();
        int  moddeg = MOD_NONE;
        unsigned int k=0;
        for (unsigned int j=0; j<layers[i].size; j++) {
          // Some edges might have lost support
          Edge** p = &layers[i].support[j].edges;
          for (Edge* e = *p; e != NULL; e = e->next) 
            if (e->i_state->i_deg == 0) {
              // Adapt states
              if ((--e->i_state->o_deg) == 0) moddeg |= MOD_ODEG;
              if ((--e->o_state->i_deg) == 0) moddeg |= MOD_IDEG;
              // Remove edge
              *p = e->next;
            } else {
              // Keep edge
              p = &e->next;
            }
          // Write endmarker for edges
          *p=NULL;
          // Check whether value is still supported
          if (layers[i].support[j].edges == NULL) {
            GECODE_ME_CHECK(x[i].nq(home,layers[i].support[j].val));
          } else {
            layers[i].support[k++]=layers[i].support[j];
          }
        }
        assert(k > 0);
        // Update size and modification information
        if (premod && (layers[i].size != k))
          es = ES_NOFIX;
        layers[i].size = k;
        layers[i-1].modified |= (moddeg & MOD_ODEG);
        layers[i+1].modified |= (moddeg & MOD_IDEG);
      }

    // Backward pass
    for (int i=x.size(); i--; )
      if (layers[i].modified & MOD_ODEG) {
        bool premod = shared & x[i].modified();
        int moddeg = MOD_NONE;
        unsigned int k=0;
        for (unsigned int j=0; j<layers[i].size; j++) {
          Edge** p = &layers[i].support[j].edges;
          for (Edge* e = *p; e != NULL; e = e->next)
            if (e->o_state->o_deg != 0) {
              // This state is still reachable, keep edge
              p = &e->next;
            } else {
              // Unreachable state, prune edge
              if (--e->i_state->o_deg == 0) moddeg |= MOD_ODEG;
              --e->o_state->i_deg;
              *p = e->next;
            }
          // Write endmarker for edges
          *p = NULL;
          // Check whether value has still support
          if (layers[i].support[j].edges == NULL) {
            GECODE_ME_CHECK(x[i].nq(home,layers[i].support[j].val));
          } else {
            layers[i].support[k++]=layers[i].support[j];
          }
        }
        assert(k > 0);
        // Update size and modification information
        if (premod && (layers[i].size != k))
          es = ES_NOFIX;
        layers[i].size = k;
        layers[i-1].modified |= moddeg;
      }
    
    // Check subsumtion
    for (int i=x.size(); i--; )
      if (!x[i].assigned())
        return es;
    return ES_SUBSUMED(this,home);
  }

  template <class View, bool shared>
  ExecStatus
  Dom<View,shared>::propagate(Space* home) {
    return constructed() ? prune(home) : construct(home);
  }

  template <class View, bool shared>
  forceinline
  Dom<View,shared>::Dom(Space* home, ViewArray<View>& x0, DFA& d)
    : Propagator(home), x(x0), dfa(d), start(0), layers(NULL) {
    assert(x.size() > 0);
    x.subscribe(home,this,PC_INT_DOM);
    this->force(home);
  }

  template <class View, bool shared>
  forceinline size_t
  Dom<View,shared>::dispose(Space* home) {
    this->unforce(home);
    // Subscriptions don't need to be cancelled as all views are assigned
    dfa.~DFA();
    (void) Propagator::dispose(home);
    return sizeof(*this);
  }

  template <class View, bool shared>
  ExecStatus
  Dom<View,shared>::post(Space* home, ViewArray<View>& x, DFA& d) {
    if (x.size() == 0) {
      // Check whether the start state 0 is also a final state
      if ((d.final_fst() <= 0) && (d.final_lst() >= 0))
        return ES_OK;
      return ES_FAILED;
    }
    assert(x.size() > 0);
    for (int i=x.size(); i--; ) {
      DFA::Symbols s(d);
      GECODE_ME_CHECK(x[i].inter_v(home,s,false));
    }
    if (x.shared()) {
      (void) new (home) Dom<View,true>(home,x,d);
    } else {
      (void) new (home) Dom<View,false>(home,x,d);
    }
    return ES_OK;
  }

  template <class View, bool shared>
  forceinline
  Dom<View,shared>::Dom(Space* home, bool share, Dom<View,shared>& p)
    : Propagator(home,share,p), layers(NULL) {
    assert(p.x.size() > 0);
    p.eliminate();
    x.update(home,share,p.x);
    dfa.update(home,share,p.dfa);
    start = p.start;
  }

  template <class View, bool shared>
  PropCost
  Dom<View,shared>::cost(void) const {
    return cost_hi(this->x.size(), PC_LINEAR_HI);
  }

  template <class View, bool shared>
  Actor*
  Dom<View,shared>::copy(Space* home, bool share) {
    return new (home) Dom<View,shared>(home,share,*this);
  }

}}}

// STATISTICS: int-prop

