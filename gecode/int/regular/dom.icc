/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Christian Schulte <schulte@gecode.org>
 *
 *  Copyright:
 *     Christian Schulte, 2004
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

#include "gecode/iter.hh"

namespace Gecode { namespace Int { namespace Regular {


  /*
   * Classes for the layered graph
   *
   */

  /**
   * \brief States are described by number of incoming and outgoing edges
   */
  class State {
  public:
    unsigned int i_deg;
    unsigned int o_deg;
  };

  /**
   * \brief %Edge in the layered graph
   */
  class Edge {
  public:
    State* i_state; ///< Pointer to in-state
    State* o_state; ///< Pointer to out-state
    Edge*  next;    ///< Next edge in support list
    /// Construct new edge
    Edge(State* i, State* o, Edge* n);
    static void  operator delete(void*, size_t);
    static void  operator delete(void*,Space*);
    static void* operator new(size_t, Space*);
  };

  forceinline
  Edge::Edge(State* i, State* o, Edge* n)
    : i_state(i), o_state(o), next(n) {}
  forceinline void
  Edge::operator delete(void*, size_t) {}
  forceinline void
  Edge::operator delete(void*,Space*) {}
  forceinline void*
  Edge::operator new(size_t s, Space* home) {
    return home->alloc(s);
  }


  /// Support information for a value
  class Support {
  public:
    int   val;   ///< Supported value
    Edge* edges; ///< Supporting edges in layered graph
  };

  /**
   * \name Flags for modification in layer
   */
  //@{
  const int MOD_NONE  = 0; ///< No modification
  const int MOD_IDEG  = 1; ///< Indegree has become zero
  const int MOD_ODEG  = 2; ///< Outdegree has become zero
  //@}

  /// Layer for a view in the layered graph
  class Layer {
  public:
    unsigned int size;     ///< Number of supported values
    int          modified; ///< Modification information
    int          lost;     ///< One of the values that lost support
    Support*     support;  ///< Supported values
  };

  /// Iterator for telling variable domains by scanning support
  class LayerValues {
  private:
    const Support* s1; ///< Current support
    const Support* s2; ///< End of support
  public:
    /// Default constructor
    LayerValues(void);
    /// Initialize for support of layer \a l
    LayerValues(const Layer& l);
    /// Initialize for support of layer \a l
    void init(const Layer& l);
    /// Test whether more values supported
    bool operator()(void) const;
    /// Move to next supported value
    void operator++(void);
    /// Return supported value
    int val(void) const;
  };

  forceinline
  LayerValues::LayerValues(void) {}
  forceinline
  LayerValues::LayerValues(const Layer& l)
    : s1(l.support), s2(l.support+l.size) {}
  forceinline void
  LayerValues::init(const Layer& l) {
    s1=l.support; s2=l.support+l.size;
  }
  forceinline bool
  LayerValues::operator()(void) const {
    return s1<s2;
  }
  forceinline void
  LayerValues::operator++(void) {
    s1++;
  }
  forceinline int
  LayerValues::val(void) const {
    return s1->val;
  }


  /*
   * The layered graph
   *
   */

  template <class View, bool shared>
  forceinline
  Dom<View,shared>::LayeredGraph::LayeredGraph(void) : layers(NULL) {}

  template <class View, bool shared>
  forceinline bool
  Dom<View,shared>::LayeredGraph::constructed(void) const {
    return layers != NULL;
  }

  template <class View, bool shared>
  forceinline ExecStatus
  Dom<View,shared>::LayeredGraph::construct(Space* home,
                                            ViewArray<View> x, 
                                            const DFA& dfa) {
    int n = x.size();
    layers = reinterpret_cast<Layer*>(home->alloc(sizeof(Layer)*(n+2)))+1;
    
    unsigned int n_states = dfa.n_states();

    // Allocate memory
    State* states = reinterpret_cast<State*>
      (home->alloc(sizeof(State)*(n+1)*n_states));

    // Initialize states (indegree and outdegree)
    for (int i = (n+1)*n_states; i--; )
      states[i].i_deg = states[i].o_deg = 0;

    // Mark initial state as being reachable
    states[0].i_deg = 1;

    // Mark final states as reachable as well
    for (int s = dfa.final_fst(); s < dfa.final_lst(); s++)
      states[n*n_states + s].o_deg = 1;

    // First pass: add transitions
    for (int i=0; i<n; i++) {
      Layer& l = layers[i];
      layers[i].support = 
        reinterpret_cast<Support*>(home->alloc(x[i].size()*sizeof(Support)));
      int j=0;
      // Enter links leaving reachable states (indegree != 0)
      DFA::Transitions t(dfa);
      ViewValues<View> nx(x[i]);
      while (nx() && t()) {
        if (t.symbol() > nx.val()) {
          layers[i].lost = nx.val();
          ++nx;
        } else if (t.symbol() < nx.val()) {
          ++t;
        } else {
          assert(t.symbol() == nx.val());
          Edge* e = NULL;
          do {
            // Compute pointer to in-state
            State* i_state = &states[i*n_states + t.i_state()];
            if (i_state->i_deg != 0) {
              // Add new transition as state is reachable
              // Compute pointer to out-state
              State* o_state = &states[(i+1)*n_states +  t.o_state()];
              i_state->o_deg++; 
              o_state->i_deg++;
              e = new (home) Edge(i_state,o_state,e);
            }
            ++t;
          } while (t() && (t.symbol() == nx.val()));
          // Found support for value
          if (e != NULL) {
            layers[i].support[j].val   = nx.val();
            layers[i].support[j].edges = e;
            j++;
          } else {
            layers[i].lost = nx.val();
          }
          ++nx;
        }
      }
      if (j == 0)
        return ES_FAILED;
      layers[i].size = j;
    }

    // Second pass: prune all transitions that do not lead to final state
    for (int i=n; i--; ) {
      Layer& l = layers[i];
      int k=0;
      for (int j=0; j<layers[i].size; j++) {
        Edge** p = &layers[i].support[j].edges;
        for (Edge* e = *p; e != NULL; e = e->next)
          if (e->o_state->o_deg != 0) {
            // This state is still reachable, keep edge
            p = &e->next;
          } else {
            // Unreachable state, prune edge
            e->i_state->o_deg--; e->o_state->i_deg--;
            *p = e->next;
          }
        // Write endmarker for edges
        *p = NULL;
        // Value has support, copy the support information
        if (layers[i].support[j].edges != NULL)
          layers[i].support[k++]=layers[i].support[j];
        else
          layers[i].lost = layers[i].support[j].val;
      }
      if (k == 0)
        return ES_FAILED;
      layers[i].size = k;
    }
    return ES_OK;
  }

  template <class View, bool shared>
  forceinline ExecStatus
  Dom<View,shared>::LayeredGraph::prune(Space* home, ViewArray<View> x) {
    // Forward pass
    for (int i=0; i<x.size(); i++) {
      if ((layers[i].size != x[i].size()) && (layers[i].modified & MOD_IDEG)) {
        // Both the view as well some in states have changed
        int j=0;
        int k=0;
        ViewValues<View> vx(x[i]);
        for ( ; vx() && (j<layers[i].size); j++) {
          assert(layers[i].support[j].val <= vx.val());
          if (layers[i].support[j].val != vx.val()) {
            // Value has lost support
            for (Edge* e=layers[i].support[j].edges; e!=NULL; e=e->next) {
              // Adapt states
              if ((--e->i_state->o_deg) == 0)
                layers[i-1].modified |= MOD_ODEG;
              if ((--e->o_state->i_deg) == 0)
                layers[i+1].modified |= MOD_IDEG;
            }
            layers[i].lost = layers[i].support[j].val;
          } else {
            assert(layers[i].support[j].val == vx.val());
            // Some edges might have lost support
            Edge** p = &layers[i].support[j].edges;
            for (Edge* e = *p; e != NULL; e = e->next) 
              if (e->i_state->i_deg == 0) {
                // Adapt states
                if ((--e->i_state->o_deg) == 0)
                  layers[i-1].modified |= MOD_ODEG;
                if ((--e->o_state->i_deg) == 0)
                  layers[i+1].modified |= MOD_IDEG;
                // Remove edge
                *p = e->next;
              } else {
                // Keep edge
                p = &e->next;
              }
            // Write endmarker for edges
            *p=NULL;
            // Value still has support
            if (layers[i].support[j].edges != NULL)
              layers[i].support[k++]=layers[i].support[j];
            else
              layers[i].lost = layers[i].support[j].val;
            ++vx;
          }
        }
        // Remove remaining values
        for (; j < layers[i].size; j++) {
          for (Edge* e=layers[i].support[j].edges; e!=NULL; e=e->next) {
            // Adapt states
            if ((--e->i_state->o_deg) == 0)
              layers[i-1].modified |= MOD_ODEG;
            if ((--e->o_state->i_deg) == 0)
              layers[i+1].modified |= MOD_IDEG;
          }
          layers[i].lost = layers[i].support[j].val;
        }
        // Update size
        if (k == 0)
          return ES_FAILED;
        layers[i].size = k;
      } else if (layers[i].size != x[i].size()) {
        // Only the view has changed
        int j=0;
        int k=0;
        ViewValues<View> vx(x[i]);
        for ( ; vx() && (j<layers[i].size); j++) {
          assert(layers[i].support[j].val <= vx.val());
          if (layers[i].support[j].val != vx.val()) {
            // Value has lost support
            for (Edge* e=layers[i].support[j].edges; e!=NULL; e=e->next) {
              // Adapt states
              if ((--e->i_state->o_deg) == 0)
                layers[i-1].modified |= MOD_ODEG;
              if ((--e->o_state->i_deg) == 0)
                layers[i+1].modified |= MOD_IDEG;
            }
            layers[i].lost = layers[i].support[j].val;
          } else {
            layers[i].support[k++]=layers[i].support[j];
            ++vx;
          }
        }
        // Remove remaining values
        for (; j < layers[i].size; j++) {
          for (Edge* e=layers[i].support[j].edges; e!=NULL; e=e->next) {
            // Adapt states
            if ((--e->i_state->o_deg) == 0)
              layers[i-1].modified |= MOD_ODEG;
            if ((--e->o_state->i_deg) == 0)
              layers[i+1].modified |= MOD_IDEG;
          }
          layers[i].lost = layers[i].support[j].val;
        }
        // Update size
        if (k == 0)
          return ES_FAILED;
        layers[i].size = k;
      } else if (layers[i].modified & MOD_IDEG) {
        // Only some in states have changed
        int k=0;
        for (int j=0; j<layers[i].size; j++) {
          // Some edges might have lost support
          Edge** p = &layers[i].support[j].edges;
          for (Edge* e = *p; e != NULL; e = e->next) 
            if (e->i_state->i_deg == 0) {
              // Adapt states
              if ((--e->i_state->o_deg) == 0)
                layers[i-1].modified |= MOD_ODEG;
              if ((--e->o_state->i_deg) == 0)
                layers[i+1].modified |= MOD_IDEG;
              // Remove edge
              *p = e->next;
            } else {
              // Keep edge
              p = &e->next;
            }
          // Write endmarker for edges
          *p=NULL;
          // Value still has support
          if (layers[i].support[j].edges != NULL)
            layers[i].support[k++]=layers[i].support[j];
          else
            layers[i].lost = layers[i].support[j].val;
        }
        // Update size
        if (k == 0)
          return ES_FAILED;
        layers[i].size = k;
      }
    }

    // Backward pass
    for (int i=x.size(); i--; ) {
      Layer& l = layers[i];
      if (layers[i].modified & MOD_ODEG) {
        int k=0;
        for (int j=0; j<layers[i].size; j++) {
          Edge** p = &layers[i].support[j].edges;
          for (Edge* e = *p; e != NULL; e = e->next)
            if (e->o_state->o_deg != 0) {
              // This state is still reachable, keep edge
              p = &e->next;
            } else {
              // Unreachable state, prune edge
              if (--e->i_state->o_deg == 0)
                layers[i-1].modified |= MOD_ODEG;
              --e->o_state->i_deg;
              *p = e->next;
            }
          // Write endmarker for edges
          *p = NULL;
          // Value still has support
          if (layers[i].support[j].edges != NULL)
            layers[i].support[k++]=layers[i].support[j];
          else
            layers[i].lost = layers[i].support[j].val;
        }
        // Update size
        if (k == 0)
          return ES_FAILED;
        layers[i].size = k;
      }
    }

    return ES_OK;
  }

  template <class View, bool shared>
  forceinline ExecStatus
  Dom<View,shared>::LayeredGraph::tell(Space* home, Propagator* p,
                                       ViewArray<View> x) {
    // Reset modification information for border areas
    layers[-1].modified = MOD_NONE;
    layers[x.size()].modified = MOD_NONE;
    // Tell back variable domains
    if (shared) {
      ExecStatus es = ES_FIX;
      for (int i=x.size(); i--; ) {
        layers[i].modified = MOD_NONE;
        assert(layers[i].size > 0);
        if (x[i].modified())
          es = ES_NOFIX;
        if ((x[i].size() != layers[i].size) || x[i].modified()) {
          if (((x[i].size() - layers[i].size) == 1) && !x[i].modified()) {
            GECODE_ME_CHECK(x[i].nq(home,layers[i].lost));
          } else {
            LayerValues lv(layers[i]);
            Iter::Values::ToRanges<LayerValues> lr(lv);
            if (x[i].modified()) {
              GECODE_ME_CHECK(x[i].inter(home,lr));
            } else {
              x[i].narrow(home,lr);
            }
          }
        }
      }
      for (int i=x.size(); i--; )
        if (!x[i].assigned())
          return es;
      x.size(0);
      return ES_SUBSUMED(p,home);
    } else {
      int n=x.size();
      for (int i=x.size(); i--; ) {
        layers[i].modified = MOD_NONE;
        assert(layers[i].size > 0);
        if (x[i].size() != layers[i].size) {
          if ((x[i].size() - layers[i].size) == 1) {
            x[i].nq(home,layers[i].lost);
          } else {
            LayerValues lv(layers[i]);
            Iter::Values::ToRanges<LayerValues> lr(lv);
            x[i].narrow(home,lr);
          }
        }
        if (x[i].assigned())
          n--;
      }
      if (n == 0) {
        x.size(0);
        return ES_SUBSUMED(p,home);
      }
      return ES_FIX;
    }
  }

  template <class View, bool shared>
  ExecStatus
  Dom<View,shared>::propagate(Space* home) {
    if (lg.constructed()) {
      GECODE_ES_CHECK(lg.prune(home,this->x));
    } else {
      GECODE_ES_CHECK(lg.construct(home,this->x,dfa));
    }
    return lg.tell(home,this,this->x);
  }

  template <class View, bool shared>
  forceinline
  Dom<View,shared>::Dom(Space* home, ViewArray<View>& x, DFA& d)
    : NaryPropagator<View,PC_INT_DOM>(home,x), dfa(d) {
    this->force(home);
  }

  template <class View, bool shared>
  forceinline size_t
  Dom<View,shared>::dispose(Space* home) {
    this->unforce(home);
    dfa.~DFA();
    (void) NaryPropagator<View,PC_INT_DOM>::dispose(home);
    return sizeof(*this);
  }

  template <class View, bool shared>
  ExecStatus
  Dom<View,shared>::post(Space* home, ViewArray<View>& x, DFA& d) {
    /*
    for (int i=x.size(); i--; ) {
      // @FIXME@: SEGFAULTS!
      DFA::Symbols s(d);
      Iter::Values::ToRanges<DFA::Symbols> r(s);
      GECODE_ME_CHECK(x[i].inter(home,r));
    }
    */
    if (x.shared()) {
      (void) new (home) Dom<View,true>(home,x,d);
    } else {
      (void) new (home) Dom<View,false>(home,x,d);
    }
    return ES_OK;
  }

  template <class View, bool shared>
  forceinline
  Dom<View,shared>::Dom(Space* home, bool share, Dom<View,shared>& p)
    : NaryPropagator<View,PC_INT_DOM>(home,share,p) {
    dfa.update(home,share,p.dfa);
  }

  template <class View, bool shared>
  PropCost
  Dom<View,shared>::cost(void) const {
    return cost_hi(this->x.size(), PC_LINEAR_HI);
  }

  template <class View, bool shared>
  Actor*
  Dom<View,shared>::copy(Space* home, bool share) {
    return new (home) Dom<View,shared>(home,share,*this);
  }

}}}

// STATISTICS: int-prop

