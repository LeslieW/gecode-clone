/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Christian Schulte <schulte@gecode.org>
 *
 *  Copyright:
 *     Christian Schulte, 2003
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

#include <climits>

#include "gecode/support/dynamic-array.hh"

#include "gecode/iter.hh"

namespace Gecode { namespace Int { namespace Distinct {

  /**
   * \brief Class for combining two pointers with a flag
   *
   * When one pointer is given, this other can be retrieved.
   *
   */

  template <class T>
  class CombPtrFlag {
  private:
    /// Store pointer and flag
    ptrdiff_t cpf;
  public:
    /// Initialize with pointer \a p1 and \a p2
    CombPtrFlag(T* p1, T* p2);
    /// Initialize with pointer \a p1 and \a p2
    void init(T* p1, T* p2);
    /// Return the other pointer when \a p is given
    T* ptr(T* p) const;
    /// Check whether flag is set
    int is_set(void) const;
    /// Set flag
    void set(void);
    /// Clear flag
    void unset(void);
  };

  /**
   * \brief Bidirectional links for both edges and anchors in nodes of view-value graph
   *
   */
  class BiLink {
  private:
    BiLink* _prev; BiLink* _next;
  public:
    BiLink(void);

    BiLink* prev(void) const; void prev(BiLink*);
    BiLink* next(void) const; void next(BiLink*);

    void add(BiLink*);
    void unlink(void);

    void mark(void);
    bool marked(void) const;

    bool empty(void) const;
  };

  template <class View> class Edge;

  /**
   * \brief Base-class for nodes (both view and value nodes)
   *
   * Note: the obvious ill-design to have also nodes and edges
   * parametric wrt View is because the right design (having template
   * function members) gets miscompiled (and actually not even compiled
   * with some C++ compilers). Duh!
   *
   */
  template <class View>
  class Node : public BiLink {
  public:
    unsigned int low, min, comp;
    Edge<View>* iter;

    Node(void);

    Edge<View>* edge_fst(void) const;
    Edge<View>* edge_lst(void) const;

    static void  operator delete(void*, size_t);
    static void  operator delete(void*,Space*);
    static void* operator new(size_t, Space*);
  };

  /**
   * \brief Value nodes in view-value graph
   *
   */
  template <class View>
  class ValNode : public Node<View> {
  protected:
    const int      _val; 
    Edge<View>*    _matching;
  public:
    ValNode<View>* next_val;
    ValNode(int);
    int val(void) const;
    void matching(Edge<View>*);
    Edge<View>* matching(void) const;
  };

  /**
   * \brief View nodes in view-value graph
   *
   */
  template <class View>
  class ViewNode : public Node<View> {
  protected:
    Edge<View>* _val_edges; View _view;
  public:
    ViewNode(View);
    Edge<View>*  val_edges(void) const;
    Edge<View>** val_edges_ref(void);

    View view(void) const;
  };

  /**
   * \brief Edges in view-value graph
   *
   */
  template <class View>
  class Edge : public BiLink {
  protected:
    Edge<View>*              _next_edge;
    CombPtrFlag<Node<View> > sd;
  public:
    Edge(Node<View>*, Node<View>*);

    Node<View>* dst(Node<View>*) const;

    ViewNode<View>* view(ValNode<View>*) const;
    ValNode<View>* val(ViewNode<View>*) const;

    bool used(Node<View>*) const;
    void use(void);
    void free(void);

    void revert(Node<View>*);

    Edge<View>*  next_edge(void) const;
    Edge<View>** next_edge_ref(void);

    Edge<View>* next(void) const;

    static void  operator delete(void*, size_t);
    static void  operator delete(void*,Space*);
    static void* operator new(size_t, Space*);
  };

}}}

#include "gecode/int/distinct/combptr.icc"
#include "gecode/int/distinct/bilink.icc"
#include "gecode/int/distinct/edge.icc"
#include "gecode/int/distinct/node.icc"

namespace Gecode { namespace Int { namespace Distinct {


  template <class View>
  forceinline
  DomCtrl<View>::ViewValGraph::ViewValGraph(void)
    : view(NULL), val(NULL), count(1) {}

  template <class View>
  forceinline bool
  DomCtrl<View>::ViewValGraph::initialized(void) const {
    return view != NULL;
  }

  template <class View>
  forceinline bool
  DomCtrl<View>::ViewValGraph::match(MatchStack& m, ViewNode<View>* x) {
    count++;
  start:
    // Try to find matching edge cheaply: is there a free edge around?
    {
      Edge<View>* e = x->val_edges();
      // This holds true as domains are never empty
      assert(e != NULL);
      do {
        if (!e->val(x)->matching()) {
          e->revert(x); e->val(x)->matching(e);
          // Found a matching, revert all edges on stack
          while (!m.empty()) {
            x = m.pop(); e = x->iter;
            e->val(x)->matching()->revert(e->val(x));
            e->revert(x); e->val(x)->matching(e);
          }
          return true;
        }
        e = e->next_edge();
      } while (e != NULL);
    }
    // No, find matching edge by augmenting path method
    Edge<View>* e = x->val_edges();
    do {
      if (e->val(x)->matching()->view(e->val(x))->min < count) { 
        e->val(x)->matching()->view(e->val(x))->min = count;
        m.push(x); x->iter = e;
        x = e->val(x)->matching()->view(e->val(x));
        goto start;
      }
    next:
      e = e->next_edge();
    } while (e != NULL);
    if (!m.empty()) {
      x = m.pop(); e = x->iter; goto next;
    }
    // All nodes and edges unsuccessfully tried
    return false;
  }

  template <class View>
  ExecStatus
  DomCtrl<View>::ViewValGraph::init(Space* home, int n, View* x) {
    n_view = n; 
    view = reinterpret_cast<ViewNode<View>**>
      (home->alloc(n_view*sizeof(ViewNode<View>*)));

    n_val = 0;
    val = NULL;

    for (int i=n; i--; ) {
      view[i] = new (home) ViewNode<View>(x[i]);
      Edge<View>** edge_p = view[i]->val_edges_ref();
      ViewValues<View> xi(x[i]);
      ValNode<View>** v = &val;
      while (xi() && (*v != NULL)) {
        if ((*v)->val() == xi.val()) {
          *edge_p = new (home) Edge<View>(*v,view[i]);
          edge_p = (*edge_p)->next_edge_ref();
          v = &((*v)->next_val);
          ++xi;
        } else if ((*v)->val() < xi.val()) {
          v = &((*v)->next_val);
        } else {
          ValNode<View>* nv = new (home) ValNode<View>(xi.val());
          nv->next_val = *v; *v = nv; v = &nv->next_val;
          *edge_p = new (home) Edge<View>(nv,view[i]);
          edge_p = (*edge_p)->next_edge_ref();
          ++xi; n_val++;
        }
      }
      while (xi()) {
        ValNode<View>* nv = new (home) ValNode<View>(xi.val());
        nv->next_val = *v; *v = nv; v = &nv->next_val;
        *edge_p = new (home) Edge<View>(nv,view[i]);
        edge_p = (*edge_p)->next_edge_ref();
        ++xi; n_val++;
      }
      *edge_p = NULL;
    }
    
    // Definitly not enough values
    if (n_val < n)
      return ES_FAILED;

    GECODE_AUTOSTACK(ViewNode<View>*,NULL,m,n_view);
    for (int i = n_view; i--; )
      if (!match(m,view[i]))
        return ES_FAILED;
    return ES_OK;
  }

  template <class View>
  forceinline void
  DomCtrl<View>::ViewValGraph::mark(void) {
    {
      // Marks all edges as used that are on simple paths in the graph
      // that start from a free (unmatched node) by depth-first-search
      GECODE_AUTOSTACK(ValNode<View>*,NULL,visit,n_val);
      
      // Insert all free nodes: they can be only value nodes as we
      // have a maximum matching covering all view nodes
      count++;
      {
        ValNode<View>** v = &val; 
        while (*v != NULL)
          if (!(*v)->matching()) {
            if ((*v)->empty()) {
              *v = (*v)->next_val;
              n_val--;
            } else {
              (*v)->min = count;
              visit.push(*v);
              v = &((*v)->next_val);
            }
          } else {
            v = &((*v)->next_val);
          }
      }
      
      // Invariant: only value nodes are on the stack!
      while (!visit.empty()) {
        ValNode<View>* n = visit.pop();
        for (Edge<View>* e = n->edge_fst(); e != n->edge_lst(); e=e->next()) {
          // Get the value node
          e->use();
          ViewNode<View>* x = e->view(n);
          if (x->min < count) {
            x->min = count;
            assert(x->edge_fst()->next() == x->edge_lst());
            ValNode<View>* m = x->edge_fst()->val(x);
            x->edge_fst()->use();
            if (m->min < count) {
              m->min = count;
              visit.push(m);
            }
          }
        }
      }
    }

    {
      GECODE_AUTOSTACK(Node<View>*,NULL,scc,n_val+n_view);
      GECODE_AUTOSTACK(Node<View>*,NULL,visit,n_val+n_view);

      count++;
      unsigned int cnt0 = count;
      unsigned int cnt1 = count;

      for (int i = n_view; i--; )
        if (view[i]->min < count) {
          Node<View>* w = view[i];
        start:
          w->low = w->min = cnt0++;
          scc.push(w);
          Edge<View>* e = w->edge_fst();
          while (e != w->edge_lst()) {
            if (e->dst(w)->min < count) {
              visit.push(w); w->iter = e;
              w=e->dst(w);
              goto start;
            }
          next:
            if (e->dst(w)->low < w->min)
              w->min = e->dst(w)->low;
            e = e->next();
          }
          if (w->min < w->low) {
            w->low = w->min;
          } else {
            Node<View>* v;
            do {
              v = scc.pop();
              v->comp = cnt1;
              v->low  = UINT_MAX;
            } while (v != w);
            cnt1++;
          }
          if (!visit.empty()) {
            w=visit.pop(); e=w->iter; goto next;
          }
        }
      count = cnt0+1;
    }
  }

  template <class View>
  forceinline bool
  DomCtrl<View>::ViewValGraph::tell(Space* home) {
    bool assigned = false;
    // Tell constraints and also eliminate nodes and edges
    for (int i = n_view; i--; ) {
      ViewNode<View>* x = view[i];
      if (!x->edge_fst()->used(x)) {
        x->view().eq(home,x->edge_fst()->val(x)->val());
        x->edge_fst()->val(x)->matching(NULL);
        view[i] = view[--n_view];
        assigned = true;
      } else {
        for (Edge<View>* e = view[i]->val_edges(); e!=NULL; e = e->next_edge())
          if (!e->used(view[i])) {
#ifndef NDEBUG
            ModEvent me = 
#endif
              view[i]->view().nq(home,e->val(view[i])->val());
            assert(me != ME_INT_VAL);
          }
      }
    }
    return assigned;
  }

  template <class View>
  forceinline void
  DomCtrl<View>::ViewValGraph::purge(void) {
    if (count > (UINT_MAX >> 1)) {
      count = 1;
      for (int i=n_view; i--; )
        view[i]->min = 0;
      for (ValNode<View>* v = val; v != NULL; v = v->next_val)
        v->min = 0;
    }
  }

  template <class View>
  bool
  DomCtrl<View>::ViewValGraph::sync(void) {
    // Stack for view nodes to be rematched
    GECODE_AUTOSTACK(ViewNode<View>*,NULL,re,n_view);
    // Synchronize nodes
    for (int i = n_view; i--; ) {
      ViewNode<View>* x = view[i];
      if (x->view().assigned()) {
        x->edge_fst()->val(x)->matching(NULL);
        for (Edge<View>* e = x->val_edges(); e != NULL; e = e->next_edge())
          e->unlink();
        view[i] = view[--n_view];
      } else {
        ViewRanges<View> r(x->view());
        Edge<View>*  m = x->edge_fst();      // Matching edge
        Edge<View>** p = x->val_edges_ref();
        Edge<View>*  e = *p;
        do {
          while (e->val(x)->val() < r.min()) {
            // Skip edge
            e->unlink(); e->mark();
            e = e->next_edge();
          }
          *p = e;
          assert(r.min() == e->val(x)->val());
          // This edges must be kept
          for (unsigned int i=r.width(); i--; ) {
            e->free();
            p = e->next_edge_ref();
            e = e->next_edge();
          }
          ++r;
        } while (r());
        *p = NULL;
        while (e != NULL) {
          e->unlink(); e->mark();
          e = e->next_edge();
        }
        if (m->marked()) {
          // Matching has been deleted!
          m->val(x)->matching(NULL);
          re.push(x);
        }
      }
    }
    GECODE_AUTOSTACK(ViewNode<View>*,NULL,m,n_view);
    while (!re.empty())
      if (!match(m,re.pop()))
        return false;
    return true;
  }



  /*
   * The propagation controller
   *
   */

  template <class View>
  forceinline
  DomCtrl<View>::DomCtrl(void) {}

  template <class View>
  forceinline bool
  DomCtrl<View>::available(void) {
    return vvg.initialized();
  }

  template <class View>
  forceinline ExecStatus
  DomCtrl<View>::init(Space* home, int n, View* x) {
    return vvg.init(home,n,x);
  }

  template <class View>
  forceinline ExecStatus
  DomCtrl<View>::sync(void) {
    vvg.purge();
    return vvg.sync() ? ES_OK : ES_FAILED;
  }

  template <class View>
  forceinline bool
  DomCtrl<View>::propagate(Space* home) {
    vvg.mark();
    return vvg.tell(home);
  }


  /*
   * The propagator proper
   *
   */

  template <class View>
  forceinline
  Dom<View>::Dom(Space* home, ViewArray<View>& x)
    : NaryPropagator<View,PC_INT_DOM>(home,x) {}

  template <class View>
  ExecStatus
  Dom<View>::post(Space* home, ViewArray<View>& x) {
    if (x.size() == 2)
      return Rel::Nq<View>::post(home,x[0],x[1]);
    if (x.size() == 3)
      return TerDom<View>::post(home,x[0],x[1],x[2]);
    if (x.size() > 3) {
      // Do bounds propagation to make view-value graph smaller
      GECODE_ES_CHECK(prop_bnd<View>(home,x))
      (void) new (home) Dom<View>(home,x);
    }
    return ES_OK;
  }

  template <class View>
  forceinline
  Dom<View>::Dom(Space* home, bool share, Dom<View>& p)
    : NaryPropagator<View,PC_INT_DOM>(home,share,p) {}

  template <class View>
  PropCost
  Dom<View>::cost(void) const {
    return cost_lo(x.size(),
                   (View::pme(this) == ME_INT_VAL)
                   ? PC_LINEAR_LO : PC_CUBIC_LO);
  }

  template <class View>
  Actor*
  Dom<View>::copy(Space* home, bool share) {
    return new (home) Dom<View>(home,share,*this);
  }

  template <class View>
  ExecStatus
  Dom<View>::propagate(Space* home) {
    if (View::pme(this) == ME_INT_VAL) {
      ExecStatus es = prop_val<View,false>(home,x);
      GECODE_ES_CHECK(es);
      if (x.size() < 2)
        return ES_SUBSUMED(this,home);
      if (es == ES_FIX)
        return ES_FIX_PARTIAL(this,View::pme(ME_INT_DOM));
      es = prop_bnd<View>(home,x);
      if (x.size() < 2)
        return ES_SUBSUMED(this,home);
      GECODE_ES_CHECK(es);
      es = prop_val<View,true>(home,x);
      if (x.size() < 2)
        return ES_SUBSUMED(this,home);
      GECODE_ES_CHECK(es);
      return ES_FIX_PARTIAL(this,View::pme(ME_INT_DOM));
    }

    if (x.size() == 2)
      GECODE_REWRITE(this,Rel::Nq<View>::post(home,x[0],x[1]));
    if (x.size() == 3)
      GECODE_REWRITE(this,TerDom<View>::post(home,x[0],x[1],x[2]));

    if (dc.available()) {
      GECODE_ES_CHECK(dc.sync());
    } else {
      GECODE_ES_CHECK(dc.init(home,x.size(),&x[0]));
    }

    (void) dc.propagate(home);

    return ES_FIX;
  }

}}}

// STATISTICS: int-prop

