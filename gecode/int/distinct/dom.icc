/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Christian Schulte <schulte@gecode.org>
 *
 *  Copyright:
 *     Christian Schulte, 2003
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

#include <climits>

#include "gecode/support/dynamic-array.hh"

#include "gecode/iter.hh"

namespace Gecode { namespace Int { namespace Distinct {

  /**
   * \brief Class for combining two pointers with a flag
   *
   * When one pointer is given, this other can be retrieved.
   *
   */

  template <class T>
  class CombPtrFlag {
  private:
    /// Store pointer and flag
    ptrdiff_t cpf;
  public:
    /// Initialize with pointer \a p1 and \a p2
    CombPtrFlag(T* p1, T* p2);
    /// Initialize with pointer \a p1 and \a p2
    void init(T* p1, T* p2);
    /// Return the other pointer when \a p is given
    T* ptr(T* p) const;
    /// Check whether flag is set
    int is_set(void) const;
    /// Set flag
    void set(void);
    /// Clear flag
    void unset(void);
  };

  /**
   * \brief Bidirectional links for both edges and anchors in nodes of view-value graph
   *
   */
  class BiLink {
  private:
    BiLink* _prev; BiLink* _next;
  public:
    BiLink(void);

    BiLink* prev(void) const; void prev(BiLink*);
    BiLink* next(void) const; void next(BiLink*);

    void add(BiLink*);
    void unlink(void);

    void mark(void);
    bool marked(void) const;

    bool empty(void) const;
  };

  template <class View> class Edge;

  /**
   * \brief Base-class for nodes (both view and value nodes)
   *
   * Note: the obvious ill-design to have also nodes and edges
   * parametric wrt View is because the right design (having template
   * function members) gets miscompiled (and actually not even compiled
   * with some C++ compilers). Duh!
   *
   */
  template <class View>
  class Node : public BiLink {
  public:
    unsigned int low, min, comp;
    Edge<View>* iter;

    Node(void);

    Edge<View>* edge_fst(void) const;
    Edge<View>* edge_lst(void) const;

    static void  operator delete(void*, size_t);
    static void  operator delete(void*,Space*);
    static void* operator new(size_t, Space*);
  };

  /**
   * \brief Value nodes in view-value graph
   *
   */
  template <class View>
  class ValNode : public Node<View> {
  protected:
    const int _val; Edge<View>* _matching;
  public:
    ValNode(int);
    int val(void) const;
    void matching(Edge<View>*);
    Edge<View>* matching(void) const;
  };

  /**
   * \brief View nodes in view-value graph
   *
   */
  template <class View>
  class ViewNode : public Node<View> {
  protected:
    Edge<View>* _val_edges; View _view;
  public:
    ViewNode(View);
    Edge<View>*  val_edges(void) const;
    Edge<View>** val_edges_ref(void);

    View view(void) const;
  };

  /**
   * \brief Edges in view-value graph
   *
   */
  template <class View>
  class Edge : public BiLink {
  protected:
    Edge<View>*              _next_edge;
    CombPtrFlag<Node<View> > sd;
  public:
    Edge(Node<View>*, Node<View>*);

    Node<View>* dst(Node<View>*) const;

    ViewNode<View>* view(ValNode<View>*) const;
    ValNode<View>* val(ViewNode<View>*) const;

    bool used(Node<View>*) const;
    void use(void);
    void free(void);

    void revert(Node<View>*);

    Edge<View>*  next_edge(void) const;
    Edge<View>** next_edge_ref(void);

    Edge<View>* next(void) const;

    static void  operator delete(void*, size_t);
    static void  operator delete(void*,Space*);
    static void* operator new(size_t, Space*);
  };

}}}

#include "gecode/int/distinct/combptr.icc"
#include "gecode/int/distinct/bilink.icc"
#include "gecode/int/distinct/edge.icc"
#include "gecode/int/distinct/node.icc"

namespace Gecode { namespace Int { namespace Distinct {


  template <class View>
  forceinline
  DomCtrl<View>::ViewValGraph::ViewValGraph(void)
    : view(NULL), val(NULL), count(1) {}

  template <class View>
  forceinline bool
  DomCtrl<View>::ViewValGraph::initialized(void) const {
    return view != NULL;
  }

  template <class View>
  forceinline bool
  DomCtrl<View>::ViewValGraph::match(MatchStack& m, ViewNode<View>* x) {
    count++;
  start:
    // Try to find matching edge cheaply: is there a free edge around?
    {
      Edge<View>* e = x->val_edges();
      // This holds true as domains are never empty
      assert(e != NULL);
      do {
        if (!e->val(x)->matching()) {
          e->revert(x); e->val(x)->matching(e);
          // Found a matching, revert all edges on stack
          while (!m.empty()) {
            x = m.pop(); e = x->iter;
            e->val(x)->matching()->revert(e->val(x));
            e->revert(x); e->val(x)->matching(e);
          }
          return true;
        }
        e = e->next_edge();
      } while (e != NULL);
    }
    // No, find matching edge by augmenting path method
    Edge<View>* e = x->val_edges();
    do {
      if (e->val(x)->matching()->view(e->val(x))->min < count) { 
        e->val(x)->matching()->view(e->val(x))->min = count;
        m.push(x); x->iter = e;
        x = e->val(x)->matching()->view(e->val(x));
        goto start;
      }
    next:
      e = e->next_edge();
    } while (e != NULL);
    if (!m.empty()) {
      x = m.pop(); e = x->iter; goto next;
    }
    // All nodes and edges unsuccessfully tried
    return false;
  }

  template <class View>
  ExecStatus
  DomCtrl<View>::ViewValGraph::init(Space* home, int n, View* x) {
    // Find value information for construction of view value graph
    int min = x[n-1].min();
    int max = x[n-1].max();
    for (int i=n-1; i--; ) {
      min = std::min(min,x[i].min());
      max = std::max(max,x[i].max());
    }

    unsigned int width = max-min+1;

    // Definitly not enough values
    if (width < static_cast<unsigned int>(n))
      return ES_FAILED;

    // Test whether the values are dense or sparse
    if (((3*static_cast<unsigned int>(n)) >> 1) >= width) {
      n_view = n; 
      view = reinterpret_cast<ViewNode<View>**>
        (home->alloc(n_view*sizeof(ViewNode<View>*)));
      iview = reinterpret_cast<ViewNode<View>**>
        (home->alloc(n_view*sizeof(ViewNode<View>*)));
      n_val = static_cast<int>(width);
      val  = reinterpret_cast<ValNode<View>**>
        (home->alloc(n_val*sizeof(ValNode<View>*)));
      // Init value nodes
      {
        int v = min+n_val;
        for (int i = n_val; i--; )
          val[i] = new (home) ValNode<View>(--v);
      }
      // Init view nodes and edges
      for (int i = n; i--; ) {
        iview[i] = view[i] = new (home) ViewNode<View>(x[i]);
        Edge<View>** edge_p = view[i]->val_edges_ref();
        ViewValues<View> x_i(x[i]);
        while (x_i()) {
          *edge_p = new (home) Edge<View>(val[x_i.val()-min],view[i]);
          edge_p = (*edge_p)->next_edge_ref();
          ++x_i;
        }
        *edge_p = NULL;
      }
    } else {
      n_view = n;
      Support::DynamicArray<int> val_inf(64);
      // Compute set of values
      n_val = 0;
      GECODE_AUTOARRAY(ViewRanges<View>,x_r,n_view);
      for (int i = n_view; i--; )
        x_r[i].init(x[i]);
      Iter::Ranges::NaryUnion<ViewRanges<View> > xu(x_r, n_view);
      // Of course, the union of non-empty iterators is non-empty
      assert(xu());
      // Fill array of values
      do {
        for (int v = xu.min(); v <= xu.max(); v++)
          val_inf[n_val++] = v;
        ++xu;
      } while (xu());
      if (n_val < n_view)
        return ES_FAILED;
      view = reinterpret_cast<ViewNode<View>**>
        (home->alloc(n_view*sizeof(ViewNode<View>*)));
      iview = reinterpret_cast<ViewNode<View>**>
        (home->alloc(n_view*sizeof(ViewNode<View>*)));
      val  = reinterpret_cast<ValNode<View>**>
        (home->alloc(n_val*sizeof(ValNode<View>*)));
      // Init value nodes
      for (int i = n_val; i--; )
        val[i] = new (home) ValNode<View>(val_inf[i]);
      // Init view nodes
      for (int i = n_view; i--; ) {
        iview[i] = view[i] = new (home) ViewNode<View>(x[i]);
        Edge<View>** edge_p = view[i]->val_edges_ref();
        ViewValues<View> x_i(x[i]);
        int j = 0;
        while (x_i()) {
          while (val_inf[j] < x_i.val())
            j++;
          *edge_p = new (home) Edge<View>(val[j],view[i]);
          edge_p = (*edge_p)->next_edge_ref();
          ++x_i;
        }
        *edge_p = NULL;
      }
    }
    GECODE_AUTOSTACK(ViewNode<View>*,NULL,m,n_view);
    for (int i = n_view; i--; )
      if (!match(m,view[i]))
        return ES_FAILED;
    return ES_OK;
  }

  template <class View>
  forceinline void
  DomCtrl<View>::ViewValGraph::mark(void) {
    {
      // Marks all edges as used that are on simple paths in the graph
      // that start from a free (unmatched node) by depth-first-search
      GECODE_AUTOSTACK(ValNode<View>*,NULL,visit,n_val);
      
      // Insert all free nodes: they can be only value nodes as we
      // have a maximum matching covering all view nodes
      count++;
      for (int i = n_val; i--; )
        if (!val[i]->matching())
          // Is it orphaned?
          if (val[i]->empty()) {
            val[i] = val[--n_val];
          } else {
            val[i]->min = count;
            visit.push(val[i]);
          }
      
      // Invariant: only value nodes are on the stack!
      while (!visit.empty()) {
        ValNode<View>* n = visit.pop();
        for (Edge<View>* e = n->edge_fst(); e != n->edge_lst(); e=e->next()) {
          // Get the value node
          e->use();
          ViewNode<View>* x = e->view(n);
          if (x->min < count) {
            x->min = count;
            assert(x->edge_fst()->next() == x->edge_lst());
            ValNode<View>* m = x->edge_fst()->val(x);
            x->edge_fst()->use();
            if (m->min < count) {
              m->min = count;
              visit.push(m);
            }
          }
        }
      }
    }

    {
      GECODE_AUTOSTACK(Node<View>*,NULL,scc,n_val+n_view);
      GECODE_AUTOSTACK(Node<View>*,NULL,visit,n_val+n_view);

      count++;
      unsigned int cnt0 = count;
      unsigned int cnt1 = count;

      for (int i = n_view; i--; )
        if (view[i]->min < count) {
          Node<View>* w = view[i];
        start:
          w->low = w->min = cnt0++;
          scc.push(w);
          Edge<View>* e = w->edge_fst();
          while (e != w->edge_lst()) {
            if (e->dst(w)->min < count) {
              visit.push(w); w->iter = e;
              w=e->dst(w);
              goto start;
            }
          next:
            if (e->dst(w)->low < w->min)
              w->min = e->dst(w)->low;
            e = e->next();
          }
          if (w->min < w->low) {
            w->low = w->min;
          } else {
            Node<View>* v;
            do {
              v = scc.pop();
              v->comp = cnt1;
              v->low  = UINT_MAX;
            } while (v != w);
            cnt1++;
          }
          if (!visit.empty()) {
            w=visit.pop(); e=w->iter; goto next;
          }
        }
      count = cnt0+1;
    }
  }

  template <class View>
  forceinline bool
  DomCtrl<View>::ViewValGraph::tell(Space* home) {
    bool assigned = false;
    // Tell constraints and also eliminate nodes and edges
    for (int i = n_view; i--; ) {
      ViewNode<View>* x = view[i];
      if (!x->edge_fst()->used(x)) {
        x->view().eq(home,x->edge_fst()->val(x)->val());
        x->edge_fst()->val(x)->matching(NULL);
        view[i] = view[--n_view];
        assigned = true;
      } else {
        Edge<View>** p = x->val_edges_ref();
        Edge<View>*  e = *p;
        while (e != NULL) {
          if (e->used(x)) {
            // Keep edge
            e->free();
            p = e->next_edge_ref();
            e = e->next_edge();
          } else {
            // Skip edge
            x->view().nq(home,e->val(x)->val());
            e->unlink();
            e = e->next_edge();
            *p = e;
          }
        }
        *p = NULL;
      }
    }
        /*
        for (Edge<View>* e = view[i]->val_edges(); e!=NULL; e = e->next_edge())
          if (!e->used(view[i])) {
#ifndef NDEBUG
            ModEvent me = 
#endif
              view[i]->view().nq(home,e->val(view[i])->val());
            assert(me != ME_INT_VAL);
          }
        */
    return assigned;
  }

  template <class View>
  forceinline void
  DomCtrl<View>::ViewValGraph::purge(void) {
    if (count > (UINT_MAX >> 1)) {
      count = 1;
      for (int i=n_view; i--; )
        view[i]->min = 0;
      for (int i=n_val; i--; )
        val[i]->min = 0;
    }
  }

  template <class View>
  bool
  DomCtrl<View>::ViewValGraph::sync(void) {
#if defined(DISTINCT_DOM_ADVISOR_IMPROVE_CHEAP) || defined(DISTINCT_DOM_ADVISOR_IMPROVE_EXPENSIVE)
    return true;
#else
    // Stack for view nodes to be rematched
    GECODE_AUTOSTACK(ViewNode<View>*,NULL,re,n_view);
    // Synchronize nodes
    for (int i = n_view; i--; ) {
      ViewNode<View>* x = view[i];
      if (x->view().assigned()) {
        x->edge_fst()->val(x)->matching(NULL);
        for (Edge<View>* e = x->val_edges(); e != NULL; e = e->next_edge())
          e->unlink();
        view[i] = view[--n_view];
      } else {
        ViewRanges<View> r(x->view());
        Edge<View>*  m = x->edge_fst();      // Matching edge
        Edge<View>** p = x->val_edges_ref();
        Edge<View>*  e = *p;
        do {
          while (e->val(x)->val() < r.min()) {
            // Skip edge
            e->unlink(); e->mark();
            e = e->next_edge();
          }
          *p = e;
          assert(r.min() == e->val(x)->val());
          // This edges must be kept
          for (unsigned int i=r.width(); i--; ) {
            e->free();
            p = e->next_edge_ref();
            e = e->next_edge();
          }
          ++r;
        } while (r());
        *p = NULL;
        while (e != NULL) {
          e->unlink(); e->mark();
          e = e->next_edge();
        }
        if (m->marked()) {
          // Matching has been deleted!
          m->val(x)->matching(NULL);
          re.push(x);
        }
      }
    }
    GECODE_AUTOSTACK(ViewNode<View>*,NULL,m,n_view);
    while (!re.empty())
      if (!match(m,re.pop()))
        return false;
    return true;
#endif
  }

  template <class View>
  forceinline bool
  DomCtrl<View>::ViewValGraph::sync(int i, const Delta& d) {
#ifdef DISTINCT_DOM_ADVISOR_IMPROVE_CHEAP
    ViewNode<View>* x = iview[i];
    ViewRanges<View> r(x->view());
    Edge<View>*  m = x->edge_fst();      // Matching edge
    Edge<View>** p = x->val_edges_ref();
    Edge<View>*  e = *p;
    do {
      while (e->val(x)->val() < r.min()) {
        // Skip edge
        e->unlink(); e->mark();
        e = e->next_edge();
      }
      *p = e;
      assert(r.min() == e->val(x)->val());
      // This edges must be kept
      for (unsigned int i=r.width(); i--; ) {
        e->free();
          p = e->next_edge_ref();
          e = e->next_edge();
      }
      ++r;
    } while (r());
    *p = NULL;
    while (e != NULL) {
      e->unlink(); e->mark();
      e = e->next_edge();
    }
    if (m->marked()) {
      // Matching has been deleted!
      m->val(x)->matching(NULL);
      GECODE_AUTOSTACK(ViewNode<View>*,NULL,ms,n_view);
      return match(ms,x);
    }
#endif
#ifdef DISTINCT_DOM_ADVISOR_IMPROVE_EXPENSIVE
    ViewNode<View>* x = iview[i];
    if (x->view().assigned()) {
      int n = x->view().val();
      bool rematch = (x->edge_fst()->val(x)->val() != n);
      Edge<View>*  m = x->edge_fst();      // Matching edge
      Edge<View>** p = x->val_edges_ref();
      Edge<View>*  e = *p;
      while (e->val(x)->val() < n) {
        // Skip edge
        e->unlink(); e = e->next_edge();
      }
      *p = e;
      assert(n == e->val(x)->val());
      // This edge must be kept
      e->free();
      p = e->next_edge_ref();
      e = e->next_edge();
      *p = NULL;
      while (e != NULL) {
        e->unlink(); e = e->next_edge();
      }
      if (rematch) {
        // Matching has been deleted!
        assert(rematch);
        m->val(x)->matching(NULL);
        GECODE_AUTOSTACK(ViewNode<View>*,NULL,ms,n_view);
        return match(ms,x);
      } else {
        assert(!rematch);
      }
    } else if (x->view().any(d)) {
      ViewRanges<View> r(x->view());
      Edge<View>*  m = x->edge_fst();      // Matching edge
      Edge<View>** p = x->val_edges_ref();
      Edge<View>*  e = *p;
      do {
        while (e->val(x)->val() < r.min()) {
          // Skip edge
          e->unlink(); e->mark();
          e = e->next_edge();
        }
        *p = e;
        assert(r.min() == e->val(x)->val());
        // This edges must be kept
        for (unsigned int i=r.width(); i--; ) {
          e->free();
          p = e->next_edge_ref();
          e = e->next_edge();
        }
        ++r;
      } while (r());
      *p = NULL;
      while (e != NULL) {
        e->unlink(); e->mark();
        e = e->next_edge();
      }
      if (m->marked()) {
        // Matching has been deleted!
        m->val(x)->matching(NULL);
        GECODE_AUTOSTACK(ViewNode<View>*,NULL,ms,n_view);
        return match(ms,x);
      }
    } else {
      int min = x->view().min(d);
      int max = x->view().max(d);
      int n_m = x->edge_fst()->val(x)->val();
      bool rematch = ((min <= n_m) && (n_m <= max));
      Edge<View>*  m = x->edge_fst();      // Matching edge
      Edge<View>** p = x->val_edges_ref();
      Edge<View>*  e = *p;
      // Keep
      while (e->val(x)->val() < min) {
        e->free();
        p = e->next_edge_ref();
        e = e->next_edge();
      }
      // Skip
      while ((e != NULL) && e->val(x)->val() <= max) {
        e->unlink(); e = e->next_edge();
      }
      *p = e;
      // Keep
      while (e != NULL) {
        e->free(); e = e->next_edge();
      }
      if (rematch) {
        // Matching has been deleted!
        m->val(x)->matching(NULL);
        GECODE_AUTOSTACK(ViewNode<View>*,NULL,ms,n_view);
        return match(ms,x);
      }
    }
#endif
    return true;
  }


  /*
   * The propagation controller
   *
   */

  template <class View>
  forceinline
  DomCtrl<View>::DomCtrl(void) {}

  template <class View>
  forceinline bool
  DomCtrl<View>::available(void) {
    return vvg.initialized();
  }

  template <class View>
  forceinline ExecStatus
  DomCtrl<View>::init(Space* home, int n, View* x) {
    return vvg.init(home,n,x);
  }

  template <class View>
  forceinline ExecStatus
  DomCtrl<View>::sync(void) {
    vvg.purge();
    return vvg.sync() ? ES_OK : ES_FAILED;
  }

  template <class View>
  forceinline bool
  DomCtrl<View>::propagate(Space* home) {
    vvg.mark();
    return vvg.tell(home);
  }

#ifdef DISTINCT_DOM_ADVISOR
  template <class View>
  forceinline ExecStatus
  DomCtrl<View>::advise(Space* home, Advisor& _a, const Delta& d,
                        ViewArray<View> x, bool ignore) {
    Dom<View>::Index& a = static_cast<Dom<View>::Index&>(_a);
#ifdef DISTINCT_DOM_ADVISOR_SCHEDULE
    return (View::modevent(d) == ME_INT_VAL) ? 
      ES_SUBSUMED_NOFIX(a,home) : ES_NOFIX; 
#endif
#ifdef DISTINCT_DOM_ADVISOR_AVOID
    if (!available())
      return (View::modevent(d) == ME_INT_VAL) ?
        ES_SUBSUMED_NOFIX(a,home) : ES_NOFIX; 
      
    int i = a.i;
    assert(same(x[i],vvg.iview[i]->view()));

    if (x[i].size() > vvg.n_view) {
      return (View::modevent(d) == ME_INT_VAL) ?
        ES_SUBSUMED_FIX(a,home) : ES_FIX; 
    }
    return (View::modevent(d) == ME_INT_VAL) ?
      ES_SUBSUMED_NOFIX(a,home) : ES_NOFIX; 
#endif
#ifdef DISTINCT_DOM_ADVISOR_IMPROVE_CHEAP
    if (!available())
      return (View::modevent(d) == ME_INT_VAL) ?
        ES_SUBSUMED_NOFIX(a,home) : ES_NOFIX; 
      
    int i = a.i;
    assert(same(x[i],vvg.iview[i]->view()));

    if (ignore || (x[i].size() > vvg.n_view)) {
      return (View::modevent(d) == ME_INT_VAL) ?
        ES_SUBSUMED_FIX(a,home) : ES_FIX; 
    }

    if (!vvg.sync(i,d))
      return ES_FAILED;
    
    return (View::modevent(d) == ME_INT_VAL) ?
      ES_SUBSUMED_NOFIX(a,home) : ES_NOFIX; 
#endif
#ifdef DISTINCT_DOM_ADVISOR_IMPROVE_EXPENSIVE
    if (!available())
      return (View::modevent(d) == ME_INT_VAL) ?
        ES_SUBSUMED_NOFIX(a,home) : ES_NOFIX; 
      
    int i = a.i;
    assert(same(x[i],vvg.iview[i]->view()));

    if (ignore) {
      return (View::modevent(d) == ME_INT_VAL) ?
        ES_SUBSUMED_FIX(a,home) : ES_FIX; 
    }

    if (!vvg.sync(i,d))
      return ES_FAILED;
    
    return (View::modevent(d) == ME_INT_VAL) ?
      ES_SUBSUMED_NOFIX(a,home) : ES_NOFIX; 
#endif
  }
#endif


  /*
   * The propagator proper
   *
   */

  template <class View>
  forceinline
  Dom<View>::Dom(Space* home, ViewArray<View>& x0)
    : Propagator(home), x(x0), y(home,x), ignore(false)
#ifdef DISTINCT_DOM_ADVISOR
    , c(home,x.size())
#endif
  {
#ifdef DISTINCT_DOM_ADVISOR
    for (int i=x.size(); i--; )
      x[i].subscribe(home, new (home) Index(home,this,c,i));
    View::schedule(home,this,ME_INT_VAL);    
#else
    x.subscribe(home, this, PC_INT_DOM);
#endif
  }

  template <class View>
  forceinline size_t
  Dom<View>::dispose(Space* home) {
#ifdef DISTINCT_DOM_ADVISOR
    c.dispose(home);
#else
    x.cancel(home,this,PC_INT_DOM);
#endif
    (void) Propagator::dispose(home);
    return sizeof(*this);
  }

  template <class View>
  ExecStatus
  Dom<View>::post(Space* home, ViewArray<View>& x) {
    if (x.size() == 2)
      return Rel::Nq<View>::post(home,x[0],x[1]);
    if (x.size() == 3)
      return TerDom<View>::post(home,x[0],x[1],x[2]);
    if (x.size() > 3) {
      // Do bounds propagation to make view-value graph smaller
      GECODE_ES_CHECK(prop_bnd<View>(home,x))
      (void) new (home) Dom<View>(home,x);
    }
    return ES_OK;
  }

  template <class View>
  forceinline
  Dom<View>::Dom(Space* home, bool share, Dom<View>& p)
    : Propagator(home,share,p), ignore(false)
#ifdef DISTINCT_DOM_ADVISOR
      , c(home,share,p.c)
#endif
  {
    x.update(home,share,p.x);
    y.update(home,share,p.y);
  }

  template <class View>
  PropCost
  Dom<View>::cost(void) const {
    return cost_lo(x.size(),
                   (View::pme(this) == ME_INT_VAL)
                   ? PC_LINEAR_LO : PC_CUBIC_LO);
  }

  template <class View>
  Actor*
  Dom<View>::copy(Space* home, bool share) {
    return new (home) Dom<View>(home,share,*this);
  }

#ifdef DISTINCT_DOM_ADVISOR
  template <class View>
  ExecStatus
  Dom<View>::advise(Space* home, Advisor& _a, const Delta& d) {
    return dc.advise(home,_a,d,y,ignore);
  }
#endif

  template <class View>
  ExecStatus
  Dom<View>::propagate(Space* home) {
    if (View::pme(this) == ME_INT_VAL) {
      ExecStatus es = prop_val<View,false>(home,x);
      GECODE_ES_CHECK(es);
      if (x.size() < 2)
        return ES_SUBSUMED(this,home);
      if (es == ES_FIX)
        return ES_FIX_PARTIAL(this,View::pme(ME_INT_DOM));
      es = prop_bnd<View>(home,x);
      if (x.size() < 2)
        return ES_SUBSUMED(this,home);
      GECODE_ES_CHECK(es);
      es = prop_val<View,true>(home,x);
      if (x.size() < 2)
        return ES_SUBSUMED(this,home);
      GECODE_ES_CHECK(es);
      return ES_FIX_PARTIAL(this,View::pme(ME_INT_DOM));
    }

    if (x.size() == 2)
      GECODE_REWRITE(this,Rel::Nq<View>::post(home,x[0],x[1]));
    if (x.size() == 3)
      GECODE_REWRITE(this,TerDom<View>::post(home,x[0],x[1],x[2]));

    if (dc.available()) {
      GECODE_ES_CHECK(dc.sync());
    } else {
      GECODE_ES_CHECK(dc.init(home,y.size(),&y[0]));
    }
    ignore = true;
    (void) dc.propagate(home);
    ignore = false;
    return ES_FIX;
  }

}}}

// STATISTICS: int-prop

