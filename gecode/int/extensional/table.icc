/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Mikael Lagerkvist <lagerkvist@gecode.org>
 *
 *  Copyright:
 *     Mikael Lagerkvist, 2007
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  Permission is hereby granted, free of charge, to any person obtaining
 *  a copy of this software and associated documentation files (the
 *  "Software"), to deal in the Software without restriction, including
 *  without limitation the rights to use, copy, modify, merge, publish,
 *  distribute, sublicense, and/or sell copies of the Software, and to
 *  permit persons to whom the Software is furnished to do so, subject to
 *  the following conditions:
 *
 *  The above copyright notice and this permission notice shall be
 *  included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#ifndef __GECODE_TABLE_ICC__
#define __GECODE_TABLE_ICC__

namespace Gecode {
  /**
   * \brief Data stored for a Table
   *
   */
  class Table::TableI {
  private:
    /// Possible dfa for rewriting into regular
    //DFA _dfa;
    //bool dfa_exists;
  public:
    /// How often is the Table implementation referred to
    unsigned int* use_cnt;
    /// Arity
    int arity;
    /// Number of tuples
    int size;
    /// Tuples index
    tuple** tuples;
    /// Tuples data
    int* data;
    /// Excess storage
    int excess;
    /// Minimum and maximum in domain-values
    int min, max;
    /// Domainsize
    int domsize;
    /// Initial last structure
    tuple** last;
    /// Pointer to NULL-pointer
    tuple* nullptr;

    // Default initialization
    void init(void) {
      use_cnt = Memory::bmalloc<unsigned int>(1);
      *use_cnt = 1;
      arity = -1;
      size = 0;
      tuples = NULL;
      data = NULL;
      excess = 0;
      min = Limits::Int::int_max;
      max = Limits::Int::int_min;
      domsize = -1;
      last = NULL;
      nullptr = NULL;
      //_dfa = DFA();
      //dfa_exists = false;
    }
    /// Add tuple. Assumes that arity matches.
    template <class T>
    void add(T t);
    /// Create a copy
    GECODE_INT_EXPORT TableI* copy(void);
    /// Finalize datastructure (disallows additions of more tuples)
    GECODE_INT_EXPORT void finalize(void);
    /// Is datastructure finalized
    bool finalized(void) { 
      assert(*use_cnt);
      assert((excess == -1 && domsize >= 0) ||
             (excess != -1 && domsize == -1)); 
      return excess == -1; 
    }

    /// Dispose
    void dispose(void) {
      --*use_cnt;
      if (*use_cnt == 0) {
        excess = -2;
        //Memory::free(use_cnt);
        //Memory::free(tuples);
        //Memory::free(data);
        //Memory::free(last);
      }
    }

    /// Get DFA (datastructure must be finalized first)
    //GECODE_INT_EXPORT DFA dfa(void);
  };

  template <class T>
  void
  Table::TableI::add(T t){
    assert(arity  != -1); // Arity has been set
    assert(excess != -1); // Tuples may still be added
    if (excess == 0) {
      int ndatasize = static_cast<int>(1+size*1.5);
      data = Memory::brealloc<int>(data, size * arity, 
                                   ndatasize * arity);
      excess = ndatasize - size;
    }
    --excess;
    int end = size*arity;
    for (int i = arity; i--; ) {
      data[end+i] = t[i];
      if (t[i] < min) min = t[i];
      if (t[i] > max) max = t[i];
    }
    ++size;
  }
  

  forceinline
  Table::Table(void) : tablei(Memory::bmalloc<TableI>(1)) {
    tablei->init();
  }

  inline void
  Table::add(const IntArgs& tuple) {
    assert(tablei->arity == -1 ||
           tablei->arity == tuple.size());
    tablei->arity = tuple.size();
    tablei->add(tuple);
  }

  inline void
  Table::finalize(void) {
    tablei->finalize();
  }

  inline int
  Table::arity(void) {
    assert(tablei->arity != -1);
    return tablei->arity;
  }
  inline int
  Table::tuples(void) {
    assert(tablei->finalized());
    return tablei->size;
  }
  inline Table::tuple
  Table::operator[](int i) {
    assert(tablei->finalized());
    return tablei->data + i*tablei->arity;
  }

  /*
  inline DFA
  Table::dfa(void) {
    if (!tablei->finalized()) tablei->finalize();
    return tablei->dfa();
  }
  */
  forceinline
  Table::Table(const Table& d)
    : tablei(d.tablei) {
    ++*tablei->use_cnt;
  }

  inline void
  Table::update(Space* home, bool share, Table& d) {
    if (share) {
      tablei->dispose();
      if (tablei->use_cnt == 0) {
        Memory::free(tablei);
      }
      tablei = d.tablei;
    } else {
      tablei = d.tablei->copy();
    }
    ++*tablei->use_cnt;
  }

  forceinline
  Table::~Table(void) {
    tablei->dispose();
    if (tablei->use_cnt == 0) {
      Memory::free(tablei);
    }
  }

  forceinline const Table&
  Table::operator=(const Table& d) {
    if (&d != this) {
      tablei->dispose();
      if (tablei->use_cnt == 0) {
        Memory::free(tablei);
      }
      tablei = d.tablei;
      ++*tablei->use_cnt;
    }
    return *this;
  }

}

#endif

// STATISTICS: int-prop

