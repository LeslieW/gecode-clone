/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Mikael Lagerkvist <lagerkvist@gecode.org>
 *
 *  Copyright:
 *     Mikael Lagerkvist, 2007
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

#include "gecode/support/dynamic-array.hh"

namespace Gecode {
  /**
   * \brief Data stored for a Table
   *
   */
  class Table::TableI {
  private:
    /// Possible dfa for rewriting into regular
    DFA _dfa;
  public:
    /// How often is the Table implementation referred to
    unsigned int use_cnt;
    /// Arity
    int arity;
    /// Number of tuples
    int size;
    /// Tuples index
    tuple** tuples;
    /// Tuples data
    int* data;
    /// Excess storage
    int excess;
    /// Minimum and maximum in domain-values
    int min, max;
    /// Domainsize
    int domsize;
    /// Initial last structure
    tuple*** last;

    // Default initialization
    void init(void) {
      use_cnt = 1;
      arity = -1;
      size = 0;
      tuples = NULL;
      data = NULL;
      excess = 0;
      min = Limits::Int::int_max;
      max = Limits::Int::int_min;
      domsize = -1;
      last = NULL;
    }
    /// Add tuple. Assumes that arity matches.
    template <class T>
    void add(T t) {
      assert(arity  != -1); // Arity has been set
      assert(excess != -1); // Tuples may still be added
      if (excess == 0) {
        int ndatasize = static_cast<int>(1+size*1.5);
        data = Memory::brealloc<int>(data, ndatasize * arity);
        excess = ndatasize - size;
      }
      --excess;
      int end = size*arity;
      for (int i = arity; i--; ) {
        data[end+i] = t[i];
        if (t[i] < min) min = t[i];
        if (t[i] > max) max = t[i];
      }
      ++size;
    }
    /// Create a copy
    GECODE_INT_EXPORT TableI* copy(void);
    /// Finalize datastructure (disallows additions of more tuples)
    GECODE_INT_EXPORT void finalize(void);
    /// Is datastructure finalized
    bool finalized(void) { return excess == -1; }

    /// Get DFA (datastructure must be finalized first)
    DFA dfa(void);
  };


  forceinline
  Table::Table(void) : tablei(Memory::bmalloc<TableI>(1)) {
    tablei->init();
  }

  forceinline
  Table::Table(const Table& d)
    : tablei(d.tablei) {
    tablei->use_cnt++;
  }

  inline void
  Table::update(Space* home, bool share, Table& d) {
    if (share) {
      tablei = d.tablei;
      tablei->use_cnt++;
    } else {
      tablei = d.tablei->copy();
    }
  }

  forceinline
  Table::~Table(void) {
    if (--tablei->use_cnt == 0) {
      Memory::free(tablei->last);
      Memory::free(tablei->tuples);
      Memory::free(tablei->data);
      Memory::free(tablei);
    }
  }

  forceinline const Table&
  Table::operator=(const Table& d) {
    if (&d != this) {
      if (--tablei->use_cnt == 0) {
        Memory::free(tablei->last);
        Memory::free(tablei->tuples);
        Memory::free(tablei->data);
        Memory::free(tablei);
      }
      tablei = d.tablei;
      tablei->use_cnt++;
    }
    return *this;
  }

}


// STATISTICS: int-prop

