/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Mikael Lagerkvist <lagerkvist@gecode.org>
 *
 *  Copyright:
 *     Mikael Lagerkvist, 2007
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

#include "gecode/support/bitset.hh"

namespace Gecode { namespace Int { namespace Extensional {
  const bool incremental_debug = false;
#define derr if(incremental_debug) std::cerr

  /*
   * The propagator proper
   *
   */

  template <class View>
  forceinline
  Incremental<View>::Incremental(Space* home, ViewArray<View>& x, const Table& t)
    : Base<View,false>(home,x,t), support_data(NULL), 
      work(x.size()), unassigned(x.size()), ac(home) {
    init_support(home);

    GECODE_AUTOARRAY(Support::BitSet<unsigned long>, dom, x.size());
    init_dom(home, dom);
    for (int i = x.size(); i--; ) {
      if (x[i].assigned()) {
        --unassigned;
      } else {
        (void) new (home) SupportAdvisor(home, this, ac, x[i], i);
      }
      ViewValues<View> vv(x[i]);
      while (vv()) {
        find_support(home, dom, i, vv.val());
        ++vv;
      }
    }
    if (!work.empty() || unassigned==0)
      // Work to be done or subsumption
      View::schedule(home,this,ME_INT_BND);
  }

  template <class View>
  ExecStatus
  Incremental<View>::post(Space* home, ViewArray<View>& x, const Table& t) {
    (void) new (home) Incremental<View>(home,x,t);
    return ES_OK;
  }

  template <class View>
  forceinline
  Incremental<View>::Incremental(Space* home, bool share, Incremental<View>& p)
    : Base<View,false>(home,share,p), support_data(NULL), 
      work(2), unassigned(p.unassigned), ac(home,share,p.ac) {
    init_support(home);
    int literals = table.tablei->domsize*x.size();    
    for (int i = literals; i--; ) {
      SupportEntry** n = &(support_data[i]);
      SupportEntry*  o = p.support_data[i];
      while (o) {
        // Allocate new support entry
        //SupportEntry* s = static_cast<SupportEntry*>
        //  (home->fl_alloc<sizeof(SupportEntry)>());
        SupportEntry* s = static_cast<SupportEntry*>
          (home->alloc(sizeof(SupportEntry)));
        s->t = o->t;
        s->next = NULL;
        // Link in support entry
        (*n) = s;
        n = &(s->next);
        // move to next one
        o = o->next;
      }
    }
  }

  template <class View>
  PropCost
  Incremental<View>::cost(void) const {
    return (View::pme(this) == ME_INT_VAL)
      ? PC_QUADRATIC_HI : PC_CUBIC_HI;
  }

  template <class View>
  Actor*
  Incremental<View>::copy(Space* home, bool share) {
    return new (home) Incremental<View>(home,share,*this);
  }


  template <class View>
  ExecStatus
  Incremental<View>::propagate(Space* home) {
    assert(!work.empty() || unassigned==0);

    /// Set up datastructures
    /// Bit-sets for amortized O(1) access to domains
    GECODE_AUTOARRAY(Support::BitSet<unsigned long>, dom, x.size());
    init_dom(home, dom);

    /// Work loop
    while (!work.empty()) {
      Work w = work.pop();
      if (dom[w.var].get(w.val)) {
        // Work is still relevant
        switch (w.work) {
        case WT_FIND_SUPPORT:
          find_support(home, dom, w.var, w.val);
          break;
        case WT_REMOVE_VALUE:
          assert(support(w.var, w.val) == NULL);
          ModEvent me = x[w.var].nq(home,w.val);
          if (me_failed(me)) {
            return ES_FAILED;
          }
          dom[w.var].set(w.val, false);
          break;
        };
      }
    }
    if (unassigned != 0) {
      return ES_FIX;
    }
    assert(support(0, x[0].val()) != NULL);
    assert(valid(support(0, x[0].val())->t, dom));
    return ES_SUBSUMED(this, home);
  }



  template <class View>
  forceinline void
  Incremental<View>::print_support(int var, int val, int tabs) {
    for (int t = tabs; t--; ) derr << "\t";
    SupportEntry* s = support(var, val);
    derr << "Support for var=" << var << " val=" << val 
         << " at s=" << (unsigned long long)s << " is:";
    if (!s)
      derr << "empty";
    while (s) {
      derr << " {t(" << (unsigned long long)s->t <<"):[";
      for (int i = 0; i < x.size(); ++i) derr << s->t[i];
      derr << "], next:" << (unsigned long long)s->next << "} ";
      s = s->next;
    }
    derr << std::endl;
  }

  template <class View>
  forceinline void
  Incremental<View>::add_support(Space* home, tuple l) {
    for (int i = x.size(); i--; ) {
      int pos = (i*table.tablei->domsize) + (l[i] - table.tablei->min);

      //SupportEntry* s = static_cast<SupportEntry*>
      //  (home->fl_alloc<sizeof(SupportEntry)>());
      SupportEntry* s = static_cast<SupportEntry*>
        (home->alloc(sizeof(SupportEntry)));
      s->t = l;
      s->next = support_data[pos];
      support_data[pos] = s;
    }
  }

  template <class View>
  forceinline void
  Incremental<View>::remove_support(Space* home, tuple l, int var, int val
#if defined(SYSTEM_ADVISOR_IMPROVE_EXPENSIVE)
                                    , Domain dom
#endif
                                    ) {
    for (int i = x.size(); i--; ) {
      int v = l[i];
      int ov = v - table.tablei->min;
      int pos = (i*(table.tablei->domsize)) + ov;

      assert(support_data[pos] != NULL);
      
      SupportEntry** a = &(support_data[pos]);
      while ((*a)->t != l) {
        assert((*a)->next != NULL);
        a = &((*a)->next);
      }
      SupportEntry* old = *a;
      *a = (*a)->next;
      
      //FreeList* fl = reinterpret_cast<FreeList*>(old);
      //fl->next(NULL);
      //home->fl_dispose<sizeof(SupportEntry)>(fl, fl);
      home->reuse(old, sizeof(SupportEntry));
      if (i != var && support_data[pos] == NULL) {
#if defined(SYSTEM_ADVISOR_IMPROVE_CHEAP)
        work.push(Work(WT_FIND_SUPPORT, i, v));
#elif defined(SYSTEM_ADVISOR_IMPROVE_EXPENSIVE)
        find_support(home, dom, i, v);
#endif
      }
    }
  }

  template <class View>
  forceinline void
  Incremental<View>::find_support(Space* home, Domain dom, int var, int val) {
    if (support(var, val) == NULL) {
      int oval = val - table.tablei->min;
      // Find support for value vv.val() in variable var
      tuple l = Base<View,false>::find_support(dom, var, oval);
      if (l == NULL) {
        // No possible supports left
        work.push(Work(WT_REMOVE_VALUE, var, val));
      } else {
        // Mark values in support as supported
        add_support(home, l);
      }
    }
  }

  template <class View>
  forceinline void
  Incremental<View>::init_support(Space* home) {
    assert(support_data == NULL);
    int literals = table.tablei->domsize*x.size();
    support_data = static_cast<SupportEntry**>
      (home->alloc(literals*sizeof(SupportEntry*)));
    for (int i = literals; i--; ) {
      support_data[i] = NULL;
    }
  }

  template <class View>
  forceinline SupportEntry*
  Incremental<View>::support(int var, int val) {
    int oval = val - table.tablei->min;
    return support_data[(var*(table.tablei->domsize)) + oval];
  }


  // 
  // Advisor proper
  //
  template <class View>
  ExecStatus
  Incremental<View>::advise(Space *home, Advisor& a0, const Delta& d) {
    SupportAdvisor& a = static_cast<SupportAdvisor&>(a0);
    ModEvent me = a.x.modevent(d);
    int lo = a.x.min(d);
    int hi = a.x.max(d);
    bool westart = work.empty();
    
#if defined(SYSTEM_ADVISOR_IMPROVE_CHEAP) || defined(SYSTEM_ADVISOR_IMPROVE_EXPENSIVE)
#if defined(SYSTEM_ADVISOR_IMPROVE_EXPENSIVE)
    GECODE_AUTOARRAY(Support::BitSet<unsigned long>, dom, x.size());
    init_dom(home, dom);
#endif
    if (lo <= hi) {
      for (int val = lo; val <= hi; ++val) {
        while (SupportEntry* s = support(a.pos, val)) {
#if defined(SYSTEM_ADVISOR_IMPROVE_CHEAP)
          remove_support(home, s->t, a.pos, val);
#else //defined(SYSTEM_ADVISOR_IMPROVE_EXPENSIVE)
          remove_support(home, s->t, a.pos, val, dom);
#endif
        }
      }
    } else {
      ViewValues<View> vv(a.x);
      for (int i = table.tablei->min; i <= table.tablei->max; ++i) {
        if (vv() && i == vv.val()) {
          ++vv;
          continue;
        }
        while (SupportEntry* s = support(a.pos, i)) {
#if defined(SYSTEM_ADVISOR_IMPROVE_CHEAP)
          remove_support(home, s->t, a.pos, i);
#else //defined(SYSTEM_ADVISOR_IMPROVE_EXPENSIVE)
          remove_support(home, s->t, a.pos, i, dom);
#endif
        }
      }
    }
#elif defined(SYSTEM_ADVISOR_BASE_AVOID)
    assert(0);
    // Slow and imprecise
    if (a.x.any(d)) {
      for (unsigned int var = x.size(); var--; ) {
        if (var == a.pos) continue;
        for (int val = table.tablei->domsize; val--; ) {
          tuple l = last(var, val);
          if (l != NULL && 
              ((me != ME_INT_VAL && l[a.pos] >= lo && l[a.pos] <= hi) ||
               (me == ME_INT_VAL && l[a.pos] != a.x.val()))) {
            if (me == ME_INT_VAL) {
              --unassigned;
              return ES_SUBSUMED_NOFIX(a,home);
            }
            return ES_NOFIX;
          }
        }
      }
    } else {
      if (me == ME_INT_VAL) {
        --unassigned;
        return ES_SUBSUMED_NOFIX(a,home);
      }
      return ES_NOFIX;
    }
#endif
    
    if (me == ME_INT_VAL) {
      --unassigned;
      if ((work.empty() || !westart) && unassigned!=0) {
        // nothing to do or already scheduled
        return ES_SUBSUMED_FIX(a,home);
      }
      return ES_SUBSUMED_NOFIX(a,home);
    }
    if (work.empty() || !westart) {
      // nothing to do or already scheduled
      return ES_FIX;
    }
    return ES_NOFIX;
  }
  

  template <class View>
  size_t
  Incremental<View>::dispose(Space* home) {
    (void) Base<View,false>::dispose(home);
    /// @todo take care of support    
    (void) ac.dispose(home);
    (void) work.~DynamicStack<Work>();
    return sizeof(*this);
  }

}}}

// STATISTICS: int-prop

