/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Mikael Lagerkvist <lagerkvist@gecode.org>
 *
 *  Copyright:
 *     Mikael Lagerkvist, 2007
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */
namespace Gecode { namespace Int { namespace Extensional {
  /*
   * The propagator proper
   *
   */

  template <class View, bool subscribe>
  forceinline
  Base<View,subscribe>::Base(Space* home, ViewArray<View>& x0, const Table& t)
    : Propagator(home), x(x0), table(t), last_data(NULL) {
    if (subscribe)
      x.subscribe(home, this, PC_INT_DOM);

    if (!table.tablei->finalized()) table.tablei->finalize();
    init_last(home, table.tablei->last);
  }

  template <class View, bool subscribe>
  forceinline
  Base<View,subscribe>::Base(Space* home, bool share, Base<View,subscribe>& p)
    : Propagator(home,share,p), last_data(NULL) {
    x.update(home, share, p.x);
    table.update(home, share, p.table);

    init_last(home, p.last_data);
  }

  template <class View, bool subscribe>
  forceinline void
  Base<View,subscribe>::init_last(Space* home, tuple** source) {
    if (last_data == NULL) {
      int literals = table.tablei->domsize*x.size();
      last_data = static_cast<tuple**>(home->alloc(literals*sizeof(tuple*)));
      for (int i = literals; i--; ) {
        last_data[i] = source[i];
      }
      for (int i = 0; i < x.size(); ++i) {
        int domsize = table.tablei->domsize;
        for (int d = 0; d < domsize; ++d) {
          tuple* l = last_data[(i*domsize) + d];
        }
      }

    }
  }

  template <class View, bool subscribe>
  PropCost
  Base<View,subscribe>::cost() const {
    return PC_QUADRATIC_HI;
  }

#define GECODE_LAST_TUPLE(l) (*(l))

  template <class View, bool subscribe>
  forceinline tuple
  Base<View,subscribe>::last(int var, int val) {
    return GECODE_LAST_TUPLE(last_data[(var*table.tablei->domsize) + val]);
  }

  template <class View, bool subscribe>
  forceinline tuple
  Base<View,subscribe>::last_next(int var, int val) {
    assert(last(var, val) != NULL);
    assert(last(var, val)[var] == val+table.tablei->min);
    int pos = (var*table.tablei->domsize) + val;
    ++(last_data[pos]);
    if (last(var,val)[var] != (val+table.tablei->min))
      last_data[pos] = table.tablei->nullptr;
    return last(var, val);
  }


  template <class View, bool subscribe>
  forceinline void
  Base<View,subscribe>::init_dom(Space* home, Domain dom) {
    // \todo use offset!!!
    int domsize = table.tablei->domsize;
    for (int i = x.size(); i--; ) {
      dom[i].init(home, domsize);
      ViewValues<View> vv(x[i]);
      while (vv()) {
        dom[i].set(vv.val());
        ++vv;
      }
    }
  }

  template <class View, bool subscribe>
  forceinline bool
  Base<View,subscribe>::valid(tuple t, Domain dom) {
    for (int i = x.size(); i--; )
      if (!dom[i].get(t[i]))
        return false;
    return true;
  }
#undef GECODE_LAST_TUPLE
  template <class View, bool subscribe>
  forceinline tuple
  Base<View,subscribe>::find_support(Domain dom, int var, int val) {
    tuple l = last(var, val);
    while (l != NULL && !valid(l, dom)) {
      l = last_next(var, val);
    }
    return l;
  }


  template <class View, bool subscribe>
  size_t
  Base<View,subscribe>::dispose(Space* home) {
    if (subscribe)
      x.cancel(home,this,PC_INT_DOM);
    (void) Propagator::dispose(home);
    (void) table.~Table();    
    // take care of last_data
    int literals = table.tablei->domsize*x.size();    
    home->reuse(last_data, sizeof(tuple*)*literals);
    return sizeof(*this);
  }
}}}

// STATISTICS: int-prop

