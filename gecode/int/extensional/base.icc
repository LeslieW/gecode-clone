/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Mikael Lagerkvist <lagerkvist@gecode.org>
 *
 *  Copyright:
 *     Mikael Lagerkvist, 2007
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */
namespace Gecode { namespace Int { namespace Extensional {
  const bool base_debug = false;
#define derr if (base_debug) std::cerr

  /*
   * The propagator proper
   *
   */

  template <class View, bool subscribe>
  forceinline
  Base<View,subscribe>::Base(Space* home, ViewArray<View>& x0, const Table& t)
    : Propagator(home), x(x0), table(t), last_data(NULL) {
    if (subscribe)
      x.subscribe(home, this, PC_INT_DOM);

    if (!table.tablei->finalized()) table.tablei->finalize();
    init_last(home, table.tablei->last);
  }

  template <class View, bool subscribe>
  forceinline
  Base<View,subscribe>::Base(Space* home, bool share, Base<View,subscribe>& p)
    : Propagator(home,share,p), last_data(NULL) {
    x.update(home, share, p.x);
    table.update(home, share, p.table);

    init_last(home, p.last_data);
    derr << "Copying of last finished: "  << std::endl;
    for (int i = 0; i < x.size(); ++i) {
      derr << "Variable " << i << ":  ";
      int domsize = table.tablei->domsize;
      for (int d = 0; d < domsize; ++d) {
        derr << "[" << (table.tablei->min+d) << "]=" 
                  << ((last_data[(i*domsize) + d] && *(last_data[(i*domsize) + d]))
                      ? (*(last_data[(i*domsize) + d]))[i] 
                      : -1) 
                  << "  ";
      }
      derr << std::endl;
    }

    if (last_data != NULL && last_data[3] != NULL)
      derr << last_data[3][0] << std::endl;
  }

  template <class View, bool subscribe>
  forceinline void
  Base<View,subscribe>::init_last(Space* home, tuple** source) {
    if (last_data == NULL) {
      derr << "Initializing last" << std::endl;
      int literals = table.tablei->domsize*x.size();
      last_data = static_cast<tuple**>(home->alloc(literals*sizeof(tuple*)));
      for (int i = literals; i--; ) {
        last_data[i] = source[i];
      }
      derr << "Initialization of last=" << ((long long)last_data) << " finished: "  << std::endl;
      for (int i = 0; i < x.size(); ++i) {
        derr << "Variable " << i << ":  ";
        int domsize = table.tablei->domsize;
        for (int d = 0; d < domsize; ++d) {
          derr << "[" << (table.tablei->min+d) << "]=";
          tuple* l = last_data[(i*domsize) + d];
          if (l && *l)
            for (int i = 0; i < x.size(); ++i) derr << (*l)[i];
          else
            derr << "NULL";
          derr << "  ";
        }
        derr << std::endl;
      }

    }

    if (last_data != NULL && last_data[3] != NULL)
      derr << last_data[3][0] << std::endl;
  }

  template <class View, bool subscribe>
  PropCost
  Base<View,subscribe>::cost() const {
    return PC_QUADRATIC_HI;
  }

#define GECODE_LAST_TUPLE(l) (*(l))

  template <class View, bool subscribe>
  forceinline tuple
  Base<View,subscribe>::last(int var, int val) {
    return GECODE_LAST_TUPLE(last_data[(var*table.tablei->domsize) + val]);
  }

  template <class View, bool subscribe>
  forceinline tuple
  Base<View,subscribe>::last_next(int var, int val) {
    assert(last(var, val) != NULL);
    assert(last(var, val)[var] == val+table.tablei->min);
    int pos = (var*table.tablei->domsize) + val;
    ++(last_data[pos]);
    if (last(var,val)[var] != (val+table.tablei->min))
      last_data[pos] = table.tablei->nullptr;
    return last(var, val);
  }


  template <class View, bool subscribe>
  forceinline void
  Base<View,subscribe>::init_dom(Space* home, Domain dom) {
    // \todo use offset!!!
    int domsize = table.tablei->domsize;
    for (int i = x.size(); i--; ) {
      dom[i].init(home, domsize);
      ViewValues<View> vv(x[i]);
      while (vv()) {
        dom[i].set(vv.val());
        ++vv;
      }
      if (base_debug) {
        derr << "Copying variable " << i << ": " << x[i] << std::endl;
        for (int j = table.tablei->min; j <= table.tablei->max; ++j)
          derr << (x[i].in(j) ? "1" : "0");
        derr << std::endl;
        for (int j = table.tablei->min; j <= table.tablei->max; ++j)
          derr << (dom[i].get(j) ? "1" : "0");
        derr << std::endl;
      }
    }
  }

  template <class View, bool subscribe>
  forceinline bool
  Base<View,subscribe>::valid(tuple t, Domain dom) {
    for (int i = x.size(); i--; )
      if (!dom[i].get(t[i]))
        return false;
    return true;
  }
#undef GECODE_LAST_TUPLE
  template <class View, bool subscribe>
  forceinline tuple
  Base<View,subscribe>::find_support(Domain dom, int var, int val) {
    derr << "\tFind support for var=" << var << " val=" << val << std::endl;
    tuple l = last(var, val);
    derr << "\tlast is l=" << l << std::endl;
    while (l != NULL && !valid(l, dom)) {
      derr << "\t";
      for (int i = 0; i < x.size(); ++i) derr << l[i] << " ";
      derr << " as last not valid" << std::endl;
      l = last_next(var, val);
      derr << "\tlast is l=" << l << std::endl;
    }
    if (l) {
      derr << "\t";
      for (int i = 0; i < x.size(); ++i) derr << l[i] << " ";
      derr << " is a valid last" << std::endl;
    } else
      derr << "\t...last invalid" << std::endl;
    return l;
  }


  template <class View, bool subscribe>
  size_t
  Base<View,subscribe>::dispose(Space* home) {
    if (subscribe)
      x.cancel(home,this,PC_INT_DOM);
    (void) Propagator::dispose(home);
    //(void) table.dispose(home);    
    // take care of last_data
    return sizeof(*this);
  }
#undef derr
}}}

// STATISTICS: int-prop

