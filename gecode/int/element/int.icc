/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Christian Schulte <schulte@gecode.org>
 *
 *  Copyright:
 *     Christian Schulte, 2004
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  Permission is hereby granted, free of charge, to any person obtaining
 *  a copy of this software and associated documentation files (the
 *  "Software"), to deal in the Software without restriction, including
 *  without limitation the rights to use, copy, modify, merge, publish,
 *  distribute, sublicense, and/or sell copies of the Software, and to
 *  permit persons to whom the Software is furnished to do so, subject to
 *  the following conditions:
 *
 *  The above copyright notice and this permission notice shall be
 *  included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

namespace Gecode { namespace Int { namespace Element {


  // Index value pairs
  template <class ViewA, class ViewB>
  forceinline void
  Int<ViewA,ViewB>::IdxVal::mark(void) {
    idx = -1;
  }
  template <class ViewA, class ViewB>
  forceinline bool
  Int<ViewA,ViewB>::IdxVal::marked(void) const {
    return idx<0;
  }

  // Index iterator
  template <class ViewA, class ViewB>
  forceinline
  Int<ViewA,ViewB>::IterIdx::IterIdx(IdxVal& ivl) {
    IdxVal* p=&ivl;
    l = p->idx_next;
    while ((l != NULL) && l->marked())
      l=l->idx_next;
    p->idx_next=l;
  }
  template <class ViewA, class ViewB>
  forceinline bool
  Int<ViewA,ViewB>::IterIdx::operator()(void) const {
    return l != NULL;
  }
  template <class ViewA, class ViewB>
  forceinline void
  Int<ViewA,ViewB>::IterIdx::operator++(void) {
    IdxVal* p=l;
    l = p->idx_next;
    while ((l != NULL) && l->marked())
      l=l->idx_next;
    p->idx_next=l;
  }
  template <class ViewA, class ViewB>
  forceinline int
  Int<ViewA,ViewB>::IterIdx::val(void) const {
    assert(!l->marked());
    return l->idx;
  }



  template <class ViewA, class ViewB>
  forceinline
  Int<ViewA,ViewB>::IterVal::IterVal(const IdxVal& ivl)
    : l(ivl.val_next) {}
  template <class ViewA, class ViewB>
  forceinline bool
  Int<ViewA,ViewB>::IterVal::operator()(void) const {
    return l != NULL;
  }
  template <class ViewA, class ViewB>
  forceinline void
  Int<ViewA,ViewB>::IterVal::operator++(void) {
    l=l->val_next;
  }
  template <class ViewA, class ViewB>
  forceinline int
  Int<ViewA,ViewB>::IterVal::val(void) const {
    assert(!l->marked());
    return l->val;
  }



  // Sort function
  template <class ViewA, class ViewB>
  forceinline bool
  Int<ViewA,ViewB>::ByVal::operator()(IdxVal*& x, IdxVal*& y) {
    return x->val < y->val;
  }


  /*
   * Element propagator proper
   *
   */
  template <class ViewA, class ViewB>
  forceinline
  Int<ViewA,ViewB>::Int(Space& home, IntSharedArray& c0, ViewA y0, ViewB y1)
    : Propagator(home), x0(y0), x1(y1), c(c0), iv(NULL) {
    force(home);
    x0.subscribe(home,*this,PC_INT_DOM);
    x1.subscribe(home,*this,PC_INT_DOM);
  }

  template <class ViewA, class ViewB>
  forceinline size_t
  Int<ViewA,ViewB>::dispose(Space& home) {
    unforce(home);
    if (!home.failed()) {
      x0.cancel(home,*this,PC_INT_DOM);
      x1.cancel(home,*this,PC_INT_DOM);
    }
    c.~IntSharedArray();
    (void) Propagator::dispose(home);
    return sizeof(*this);
  }

  template <class ViewA, class ViewB>
  ExecStatus
  Int<ViewA,ViewB>::post(Space& home, IntSharedArray& c, ViewA x0, ViewB x1) {
    GECODE_ME_CHECK(x0.gq(home,0));
    GECODE_ME_CHECK(x0.le(home,c.size()));
    if (x0.assigned()) {
      GECODE_ME_CHECK(x1.eq(home,c[x0.val()]));
    } else {
      (void) new (home) Int<ViewA,ViewB>(home,c,x0,x1);
    }
    return ES_OK;
  }

  template <class ViewA, class ViewB>
  forceinline
  Int<ViewA,ViewB>::Int(Space& home, bool share, Int& p)
    : Propagator(home,share,p), iv(NULL) {
    c.update(home,share,p.c);
    x0.update(home,share,p.x0);
    x1.update(home,share,p.x1);
  }

  template <class ViewA, class ViewB>
  Actor*
  Int<ViewA,ViewB>::copy(Space& home, bool share) {
    return new (home) Int<ViewA,ViewB>(home,share,*this);
  }

  template <class ViewA, class ViewB>
  PropCost
  Int<ViewA,ViewB>::cost(const Space&, const ModEventDelta&) const {
    return PC_BINARY_HI;
  }

  template <class ViewA, class ViewB>
  inline Support::Symbol
  Int<ViewA,ViewB>::ati(void) {
    return Reflection::mangle<ViewA,ViewB>("Gecode::Int::Element::Int");
  }

  template <class ViewA, class ViewB>
  Reflection::ActorSpec
  Int<ViewA,ViewB>::spec(const Space& home, Reflection::VarMap& m) const {
    Reflection::ActorSpec s(ati());
    return s << x0.spec(home, m)
             << x1.spec(home, m)
             << Reflection::Arg::newIntArray(c);
  }

  template <class ViewA, class ViewB>
  void
  Int<ViewA,ViewB>::post(Space& home, Reflection::VarMap& vars,
                         const Reflection::ActorSpec& spec) {
    spec.checkArity(3);
    ViewA x0(home, vars, spec[0]);
    ViewB x1(home, vars, spec[1]);
    Reflection::IntArrayArg* a = spec[2]->toIntArray();
    IntSharedArray is(a->size());
    for (int i=a->size(); i--; ) {
      is[i] = (*a)[i];
    }
    (void) new (home) Int<ViewA,ViewB>(home, is, x0, x1);
  }

  template <class ViewA, class ViewB>
  ExecStatus
  Int<ViewA,ViewB>::propagate(Space& home, const ModEventDelta&) {
    bool assigned = x0.assigned() && x1.assigned();
    if (iv == NULL) {
      // Initialize data structure
      iv = home.alloc<IdxVal>(x0.size() + 1);

      // The first element in iv[0] is used as sentinel
      // Enter information sorted by idx
      IdxVal* by_idx = &iv[1];
      {
        int i = 0;
        ViewValues<ViewA> v(x0);
        while (v()) {
          by_idx[i].idx = v.val();
          by_idx[i].val = c[v.val()];
          ++i; ++v;
        }
      }
      int size = x0.size();
      // Create val links sorted by val
      Region r(home);
      IdxVal** by_val = r.alloc<IdxVal*>(size);
      for (int i = size; i--; )
        by_val[i] = &iv[i+1];
      ByVal lt;
      Support::quicksort<IdxVal*>(by_val,size,lt);
      // Create idx and val links
      for (int i = size-1; i--; ) {
        by_idx[i].idx_next  = by_idx+i+1;
        by_val[i]->val_next = by_val[i+1];
      }
      by_idx[size-1].idx_next  = NULL;
      by_val[size-1]->val_next = NULL;
      // Set up sentinel element: iv[0]
      iv[0].idx_next = &by_idx[0];
      iv[0].val_next = by_val[0];
    } else {
      // Prune index
      IdxVal* p = &iv[0];
      IdxVal* l = p->idx_next;
      ViewRanges<ViewA> i(x0);
      while (i() && (l != NULL)) {
        assert(!l->marked());
        if (l->idx < i.min()) {
          l->mark(); l=l->idx_next; p->idx_next=l;
        } else if (l->idx > i.max()) {
          ++i;
        } else {
          p=l; l=l->idx_next;
        }
      }
      p->idx_next = NULL;
      while (l != NULL) { l->mark(); l=l->idx_next; }
    }

    // Prune values
    {
      IdxVal* p = &iv[0];
      IdxVal* l = p->val_next;
      ViewRanges<ViewB> v(x1);
      while (v() && (l != NULL)) {
        if (l->marked()) {
          l=l->val_next; p->val_next=l;
        } else if (l->val < v.min()) {
          l->mark(); l=l->val_next; p->val_next=l;
        } else if (l->val > v.max()) {
          ++v;
        } else {
          p=l; l=l->val_next;
        }
      }
      p->val_next = NULL;
      while (l != NULL) { l->mark(); l=l->val_next; }
    }

    // Peform tell
    ExecStatus es;
    {
      IterIdx i(iv[0]);
      GECODE_ME_CHECK(x0.narrow_v(home,i,false));
      IterVal v(iv[0]);
      if (shared(x0,x1)) {
        GECODE_ME_CHECK(x1.inter_v(home,v,false));
        es = ES_NOFIX;
      } else {
        GECODE_ME_CHECK(x1.narrow_v(home,v,false));
        es = ES_FIX;
      }
    }
    if (es == ES_NOFIX)
      return assigned ? ES_SUBSUMED(*this,home) : ES_NOFIX;

    return (x0.assigned() || x1.assigned()) ? 
      ES_SUBSUMED(*this,home) : es;
  }

}}}


// STATISTICS: int-prop

