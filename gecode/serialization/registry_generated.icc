namespace Gecode { namespace Serialization { namespace {
class TypeDefs {
public:
  Reflection::Type intvar;
  Reflection::Type boolvar;
  Reflection::Type offsetvar;
  Reflection::Type minusvar;
  Reflection::Type negboolvar;
  Reflection::Type constint;
  Reflection::Type setvar;
  TypeDefs() : intvar("int.IntView"), boolvar("int.BoolView"), 
    offsetvar("int.OffsetView"), minusvar("int.MinusView"),
    negboolvar("int.NegBoolView"), constint("int.ConstIntView"),
    setvar("set.SetView") {}
};
TypeDefs _typeDefs;
class int_Pdistinct_PVal {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      distinct(home,  arg0 ,  ICL_VAL );
      return;
    }
    if ( _typeDefs.offsetvar.equal(spec[ 0]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntArgs arg0_0(a0->size());
      IntVarArgs arg0_1(a0->size());
      for (int i=a0->size(); i--;) {
        arg0_0[i] = (*a0)[i]->first()->toInt();
        arg0_1[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->second()->toVar()])));
      }
      distinct(home,  arg0_0 ,  arg0_1 ,  ICL_VAL );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pdistinct_PVal() { registry.add("int.distinct.Val", &post); }
};
int_Pdistinct_PVal _int_Pdistinct_PVal;

class int_Pdistinct_PBnd {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      distinct(home,  arg0 ,  ICL_BND );
      return;
    }
    if ( _typeDefs.offsetvar.equal(spec[ 0]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntArgs arg0_0(a0->size());
      IntVarArgs arg0_1(a0->size());
      for (int i=a0->size(); i--;) {
        arg0_0[i] = (*a0)[i]->first()->toInt();
        arg0_1[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->second()->toVar()])));
      }
      distinct(home,  arg0_0 ,  arg0_1 ,  ICL_BND );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pdistinct_PBnd() { registry.add("int.distinct.Bnd", &post); }
};
int_Pdistinct_PBnd _int_Pdistinct_PBnd;

class int_Pdistinct_PDom {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      distinct(home,  arg0 ,  ICL_DOM );
      return;
    }
    if ( _typeDefs.offsetvar.equal(spec[ 0]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntArgs arg0_0(a0->size());
      IntVarArgs arg0_1(a0->size());
      for (int i=a0->size(); i--;) {
        arg0_0[i] = (*a0)[i]->first()->toInt();
        arg0_1[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->second()->toVar()])));
      }
      distinct(home,  arg0_0 ,  arg0_1 ,  ICL_DOM );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pdistinct_PDom() { registry.add("int.distinct.Dom", &post); }
};
int_Pdistinct_PDom _int_Pdistinct_PDom;

class ViewValAssignment {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  ViewValAssignment() { registry.add("ViewValAssignment", &post); }
};
ViewValAssignment _ViewValAssignment;

class ViewValBranching {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  ViewValBranching() { registry.add("ViewValBranching", &post); }
};
ViewValBranching _ViewValBranching;

class int_PAbsBnd {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      abs(home,  arg0 ,  arg1 ,  ICL_BND );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_PAbsBnd() { registry.add("int.AbsBnd", &post); }
};
int_PAbsBnd _int_PAbsBnd;

class int_PAbsDom {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      abs(home,  arg0 ,  arg1 ,  ICL_DOM );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_PAbsDom() { registry.add("int.AbsDom", &post); }
};
int_PAbsDom _int_PAbsDom;

class int_PMax {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 2]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      IntVar arg2 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[2]->typedArg()->toVar()])));
      max(home,  arg0 ,  arg1 ,  arg2 );
      return;
    }
    if ( _typeDefs.minusvar.equal(spec[ 0]->type()) &&
         _typeDefs.minusvar.equal(spec[ 1]->type()) &&
         _typeDefs.minusvar.equal(spec[ 2]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      IntVar arg2 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[2]->typedArg()->toVar()])));
      min(home,  arg0 ,  arg1 ,  arg2 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_PMax() { registry.add("int.Max", &post); }
};
int_PMax _int_PMax;

class int_PMult {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 2]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      IntVar arg2 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[2]->typedArg()->toVar()])));
      mult(home,  arg0 ,  arg1 ,  arg2 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_PMult() { registry.add("int.Mult", &post); }
};
int_PMult _int_PMult;

class int_PMultPlus {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 2]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      IntVar arg2 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[2]->typedArg()->toVar()])));
      mult(home,  arg0 ,  arg1 ,  arg2 );
      return;
    }
    if ( _typeDefs.minusvar.equal(spec[ 0]->type()) &&
         _typeDefs.minusvar.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 2]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      IntVar arg2 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[2]->typedArg()->toVar()])));
      mult(home,  arg0 ,  arg1 ,  arg2 );
      return;
    }
    if ( _typeDefs.minusvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
         _typeDefs.minusvar.equal(spec[ 2]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      IntVar arg2 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[2]->typedArg()->toVar()])));
      mult(home,  arg0 ,  arg1 ,  arg2 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_PMultPlus() { registry.add("int.MultPlus", &post); }
};
int_PMultPlus _int_PMultPlus;

class int_PNaryMax {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      max(home,  arg0 ,  arg1 );
      return;
    }
    if ( _typeDefs.minusvar.equal(spec[ 0]->type()) &&
         _typeDefs.minusvar.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      min(home,  arg0 ,  arg1 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_PNaryMax() { registry.add("int.NaryMax", &post); }
};
int_PNaryMax _int_PNaryMax;

class int_PSquare {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      mult(home,  arg0 ,  arg0 ,  arg1 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_PSquare() { registry.add("int.Square", &post); }
};
int_PSquare _int_PSquare;

class int_PSquarePlus {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      mult(home,  arg0 ,  arg0 ,  arg1 );
      return;
    }
    if ( _typeDefs.minusvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      mult(home,  arg0 ,  arg0 ,  arg1 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_PSquarePlus() { registry.add("int.SquarePlus", &post); }
};
int_PSquarePlus _int_PSquarePlus;

class int_Pbool_PBinOrTrue {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.boolvar.equal(spec[ 0]->type()) &&
         _typeDefs.boolvar.equal(spec[ 1]->type()) &&
        true) {
      BoolVar arg0 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[0]->typedArg()->toVar()])));
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      rel(home,  arg0 ,  BOT_OR ,  arg1 ,  true );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pbool_PBinOrTrue() { registry.add("int.bool.BinOrTrue", &post); }
};
int_Pbool_PBinOrTrue _int_Pbool_PBinOrTrue;

class int_Pbool_PEq {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.boolvar.equal(spec[ 0]->type()) &&
         _typeDefs.boolvar.equal(spec[ 1]->type()) &&
        true) {
      BoolVar arg0 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[0]->typedArg()->toVar()])));
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      rel(home,  arg0 ,  BOT_EQV ,  arg1 ,  true );
      return;
    }
    if ( _typeDefs.boolvar.equal(spec[ 0]->type()) &&
         _typeDefs.negboolvar.equal(spec[ 1]->type()) &&
        true) {
      BoolVar arg0 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[0]->typedArg()->toVar()])));
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      rel(home,  arg0 ,  BOT_XOR ,  arg1 ,  true );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pbool_PEq() { registry.add("int.bool.Eq", &post); }
};
int_Pbool_PEq _int_Pbool_PEq;

class int_Pbool_PEqv {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.boolvar.equal(spec[ 0]->type()) &&
         _typeDefs.boolvar.equal(spec[ 1]->type()) &&
         _typeDefs.boolvar.equal(spec[ 2]->type()) &&
        true) {
      BoolVar arg0 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[0]->typedArg()->toVar()])));
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      BoolVar arg2 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[2]->typedArg()->toVar()])));
      rel(home,  arg0 ,  BOT_EQV ,  arg1 ,  arg2 );
      return;
    }
    if ( _typeDefs.boolvar.equal(spec[ 0]->type()) &&
         _typeDefs.boolvar.equal(spec[ 1]->type()) &&
         _typeDefs.negboolvar.equal(spec[ 2]->type()) &&
        true) {
      BoolVar arg0 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[0]->typedArg()->toVar()])));
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      BoolVar arg2 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[2]->typedArg()->toVar()])));
      rel(home,  arg0 ,  BOT_XOR ,  arg1 ,  arg2 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pbool_PEqv() { registry.add("int.bool.Eqv", &post); }
};
int_Pbool_PEqv _int_Pbool_PEqv;

class int_Pbool_PLq {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.boolvar.equal(spec[ 0]->type()) &&
         _typeDefs.boolvar.equal(spec[ 1]->type()) &&
        true) {
      BoolVar arg0 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[0]->typedArg()->toVar()])));
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      rel(home,  arg0 ,  IRT_LQ ,  arg1 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pbool_PLq() { registry.add("int.bool.Lq", &post); }
};
int_Pbool_PLq _int_Pbool_PLq;

class int_Pbool_PNaryOr {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.boolvar.equal(spec[ 0]->type()) &&
         _typeDefs.boolvar.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      BoolVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[(*a0)[i]->toVar()])));
      }
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      rel(home,  arg0 ,  BOT_OR ,  arg1 );
      return;
    }
    if ( _typeDefs.negboolvar.equal(spec[ 0]->type()) &&
         _typeDefs.negboolvar.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      BoolVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[(*a0)[i]->toVar()])));
      }
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      rel(home,  arg0 ,  BOT_AND ,  arg1 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pbool_PNaryOr() { registry.add("int.bool.NaryOr", &post); }
};
int_Pbool_PNaryOr _int_Pbool_PNaryOr;

class int_Pbool_PNaryOrTrue {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.boolvar.equal(spec[ 0]->type()) &&
         _typeDefs.boolvar.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      BoolVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[(*a0)[i]->toVar()])));
      }
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      rel(home,  arg0 ,  BOT_OR ,  true );
      return;
    }
    if ( _typeDefs.negboolvar.equal(spec[ 0]->type()) &&
         _typeDefs.negboolvar.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      BoolVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[(*a0)[i]->toVar()])));
      }
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      rel(home,  arg0 ,  BOT_AND ,  true );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pbool_PNaryOrTrue() { registry.add("int.bool.NaryOrTrue", &post); }
};
int_Pbool_PNaryOrTrue _int_Pbool_PNaryOrTrue;

class int_Pbool_POr {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.boolvar.equal(spec[ 0]->type()) &&
         _typeDefs.boolvar.equal(spec[ 1]->type()) &&
         _typeDefs.boolvar.equal(spec[ 2]->type()) &&
        true) {
      BoolVar arg0 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[0]->typedArg()->toVar()])));
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      BoolVar arg2 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[2]->typedArg()->toVar()])));
      rel(home,  arg0 ,  BOT_OR ,  arg1 ,  arg2 );
      return;
    }
    if ( _typeDefs.negboolvar.equal(spec[ 0]->type()) &&
         _typeDefs.negboolvar.equal(spec[ 1]->type()) &&
         _typeDefs.negboolvar.equal(spec[ 2]->type()) &&
        true) {
      BoolVar arg0 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[0]->typedArg()->toVar()])));
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      BoolVar arg2 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[2]->typedArg()->toVar()])));
      rel(home,  arg0 ,  BOT_AND ,  arg1 ,  arg2 );
      return;
    }
    if ( _typeDefs.negboolvar.equal(spec[ 0]->type()) &&
         _typeDefs.boolvar.equal(spec[ 1]->type()) &&
         _typeDefs.boolvar.equal(spec[ 2]->type()) &&
        true) {
      BoolVar arg0 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[0]->typedArg()->toVar()])));
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      BoolVar arg2 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[2]->typedArg()->toVar()])));
      rel(home,  arg0 ,  BOT_IMP ,  arg1 ,  arg2 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pbool_POr() { registry.add("int.bool.Or", &post); }
};
int_Pbool_POr _int_Pbool_POr;

class int_Pbool_POrTrueSubsumed {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pbool_POrTrueSubsumed() { registry.add("int.bool.OrTrueSubsumed", &post); }
};
int_Pbool_POrTrueSubsumed _int_Pbool_POrTrueSubsumed;

class int_Pbool_PQuadOrTrue {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.boolvar.equal(spec[ 0]->type()) &&
         _typeDefs.boolvar.equal(spec[ 1]->type()) &&
         _typeDefs.boolvar.equal(spec[ 2]->type()) &&
         _typeDefs.boolvar.equal(spec[ 3]->type()) &&
        true) {
      BoolVar arg0 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[0]->typedArg()->toVar()])));
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      BoolVar arg2 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[2]->typedArg()->toVar()])));
      BoolVar arg3 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[3]->typedArg()->toVar()])));
      BoolVarArgs argL0(4);
      argL0[0] = arg0;
      argL0[1] = arg1;
      argL0[2] = arg2;
      argL0[3] = arg3;
      rel(home,  argL0 ,  BOT_OR ,  true );
      return;
    }
    if ( _typeDefs.negboolvar.equal(spec[ 0]->type()) &&
         _typeDefs.negboolvar.equal(spec[ 1]->type()) &&
         _typeDefs.negboolvar.equal(spec[ 2]->type()) &&
         _typeDefs.negboolvar.equal(spec[ 3]->type()) &&
        true) {
      BoolVar arg0 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[0]->typedArg()->toVar()])));
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      BoolVar arg2 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[2]->typedArg()->toVar()])));
      BoolVar arg3 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[3]->typedArg()->toVar()])));
      BoolVarArgs argL0(4);
      argL0[0] = arg0;
      argL0[1] = arg1;
      argL0[2] = arg2;
      argL0[3] = arg3;
      rel(home,  argL0 ,  BOT_AND ,  true );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pbool_PQuadOrTrue() { registry.add("int.bool.QuadOrTrue", &post); }
};
int_Pbool_PQuadOrTrue _int_Pbool_PQuadOrTrue;

class int_Pbool_PTerOrTrue {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.boolvar.equal(spec[ 0]->type()) &&
         _typeDefs.boolvar.equal(spec[ 1]->type()) &&
         _typeDefs.boolvar.equal(spec[ 2]->type()) &&
        true) {
      BoolVar arg0 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[0]->typedArg()->toVar()])));
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      BoolVar arg2 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[2]->typedArg()->toVar()])));
      BoolVarArgs argL0(3);
      argL0[0] = arg0;
      argL0[1] = arg1;
      argL0[2] = arg2;
      rel(home,  argL0 ,  BOT_OR ,  true );
      return;
    }
    if ( _typeDefs.negboolvar.equal(spec[ 0]->type()) &&
         _typeDefs.negboolvar.equal(spec[ 1]->type()) &&
         _typeDefs.negboolvar.equal(spec[ 2]->type()) &&
        true) {
      BoolVar arg0 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[0]->typedArg()->toVar()])));
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      BoolVar arg2 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[2]->typedArg()->toVar()])));
      BoolVarArgs argL0(3);
      argL0[0] = arg0;
      argL0[1] = arg1;
      argL0[2] = arg2;
      rel(home,  argL0 ,  BOT_AND ,  true );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pbool_PTerOrTrue() { registry.add("int.bool.TerOrTrue", &post); }
};
int_Pbool_PTerOrTrue _int_Pbool_PTerOrTrue;

class int_Pchannel_PDom {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      Reflection::ArrayArg<Reflection::Arg*>* a1 =
        spec[1]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg1(a1->size());
      for (int i=a1->size(); i--;) {
        arg1[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a1)[i]->toVar()])));
      }
      channel(home,  arg0 ,  arg1 ,  ICL_DOM );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pchannel_PDom() { registry.add("int.channel.Dom", &post); }
};
int_Pchannel_PDom _int_Pchannel_PDom;

class int_Pchannel_PLinkMulti {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.boolvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      BoolVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[(*a0)[i]->toVar()])));
      }
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      int arg2 = spec[2]->toInt();
      channel(home,  arg0 ,  arg1 ,  arg2 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pchannel_PLinkMulti() { registry.add("int.channel.LinkMulti", &post); }
};
int_Pchannel_PLinkMulti _int_Pchannel_PLinkMulti;

class int_Pchannel_PLinkSingle {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.boolvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      BoolVar arg0 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[0]->typedArg()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      channel(home,  arg0 ,  arg1 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pchannel_PLinkSingle() { registry.add("int.channel.LinkSingle", &post); }
};
int_Pchannel_PLinkSingle _int_Pchannel_PLinkSingle;

class int_Pchannel_PVal {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      Reflection::ArrayArg<Reflection::Arg*>* a1 =
        spec[1]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg1(a1->size());
      for (int i=a1->size(); i--;) {
        arg1[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a1)[i]->toVar()])));
      }
      channel(home,  arg0 ,  arg1 ,  ICL_VAL );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pchannel_PVal() { registry.add("int.channel.Val", &post); }
};
int_Pchannel_PVal _int_Pchannel_PVal;

class int_Pcircuit_PDom {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      circuit(home,  ICL_DOM );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pcircuit_PDom() { registry.add("int.circuit.Dom", &post); }
};
int_Pcircuit_PDom _int_Pcircuit_PDom;

class int_Pcircuit_PVal {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      circuit(home,  ICL_DOM );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pcircuit_PVal() { registry.add("int.circuit.Val", &post); }
};
int_Pcircuit_PVal _int_Pcircuit_PVal;

class int_Pcount_PEqInt {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      int arg2 = spec[2]->toInt();
      count(home,  arg0 ,  arg1 ,  IRT_EQ ,  arg2 );
      return;
    }
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      int arg1 = spec[1]->typedArg()->toInt();
      int arg2 = spec[2]->toInt();
      count(home,  arg0 ,  arg1 ,  IRT_EQ ,  arg2 );
      return;
    }
    if ( _typeDefs.offsetvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntArgs arg0_0(a0->size());
      IntVarArgs arg0_1(a0->size());
      for (int i=a0->size(); i--;) {
        arg0_0[i] = (*a0)[i]->first()->toInt();
        arg0_1[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->second()->toVar()])));
      }
      int arg1 = spec[1]->typedArg()->toInt();
      int arg2 = spec[2]->toInt();
      count(home,  arg0_1 ,  arg0_0 ,  IRT_EQ ,  arg2 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pcount_PEqInt() { registry.add("int.count.EqInt", &post); }
};
int_Pcount_PEqInt _int_Pcount_PEqInt;

class int_Pcount_PEqView {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 2]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      IntVar arg2 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[2]->typedArg()->toVar()])));
      int arg3 = spec[3]->toInt();
      my_count(home,  arg0 ,  arg1 ,  IRT_EQ ,  arg2 ,  arg3 );
      return;
    }
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 2]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      int arg1 = spec[1]->typedArg()->toInt();
      IntVar arg2 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[2]->typedArg()->toVar()])));
      int arg3 = spec[3]->toInt();
      my_count(home,  arg0 ,  arg1 ,  IRT_EQ ,  arg2 ,  arg3 );
      return;
    }
    if ( _typeDefs.offsetvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 2]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntArgs arg0_0(a0->size());
      IntVarArgs arg0_1(a0->size());
      for (int i=a0->size(); i--;) {
        arg0_0[i] = (*a0)[i]->first()->toInt();
        arg0_1[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->second()->toVar()])));
      }
      int arg1 = spec[1]->typedArg()->toInt();
      IntVar arg2 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[2]->typedArg()->toVar()])));
      int arg3 = spec[3]->toInt();
      my_count(home,  arg0_1 ,  arg0_0 ,  IRT_EQ ,  arg2 ,  arg3 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pcount_PEqView() { registry.add("int.count.EqView", &post); }
};
int_Pcount_PEqView _int_Pcount_PEqView;

class int_Pcount_PGqInt {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      int arg2 = spec[2]->toInt();
      count(home,  arg0 ,  arg1 ,  IRT_GQ ,  arg2 );
      return;
    }
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      int arg1 = spec[1]->typedArg()->toInt();
      int arg2 = spec[2]->toInt();
      count(home,  arg0 ,  arg1 ,  IRT_GQ ,  arg2 );
      return;
    }
    if ( _typeDefs.offsetvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntArgs arg0_0(a0->size());
      IntVarArgs arg0_1(a0->size());
      for (int i=a0->size(); i--;) {
        arg0_0[i] = (*a0)[i]->first()->toInt();
        arg0_1[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->second()->toVar()])));
      }
      int arg1 = spec[1]->typedArg()->toInt();
      int arg2 = spec[2]->toInt();
      count(home,  arg0_1 ,  arg0_0 ,  IRT_GQ ,  arg2 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pcount_PGqInt() { registry.add("int.count.GqInt", &post); }
};
int_Pcount_PGqInt _int_Pcount_PGqInt;

class int_Pcount_PGqView {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 2]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      IntVar arg2 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[2]->typedArg()->toVar()])));
      int arg3 = spec[3]->toInt();
      my_count(home,  arg0 ,  arg1 ,  IRT_GQ ,  arg2 ,  arg3 );
      return;
    }
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 2]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      int arg1 = spec[1]->typedArg()->toInt();
      IntVar arg2 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[2]->typedArg()->toVar()])));
      int arg3 = spec[3]->toInt();
      my_count(home,  arg0 ,  arg1 ,  IRT_GQ ,  arg2 ,  arg3 );
      return;
    }
    if ( _typeDefs.offsetvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 2]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntArgs arg0_0(a0->size());
      IntVarArgs arg0_1(a0->size());
      for (int i=a0->size(); i--;) {
        arg0_0[i] = (*a0)[i]->first()->toInt();
        arg0_1[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->second()->toVar()])));
      }
      int arg1 = spec[1]->typedArg()->toInt();
      IntVar arg2 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[2]->typedArg()->toVar()])));
      int arg3 = spec[3]->toInt();
      my_count(home,  arg0_1 ,  arg0_0 ,  IRT_GQ ,  arg2 ,  arg3 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pcount_PGqView() { registry.add("int.count.GqView", &post); }
};
int_Pcount_PGqView _int_Pcount_PGqView;

class int_Pcount_PLqInt {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      int arg2 = spec[2]->toInt();
      count(home,  arg0 ,  arg1 ,  IRT_LQ ,  arg2 );
      return;
    }
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      int arg1 = spec[1]->typedArg()->toInt();
      int arg2 = spec[2]->toInt();
      count(home,  arg0 ,  arg1 ,  IRT_LQ ,  arg2 );
      return;
    }
    if ( _typeDefs.offsetvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntArgs arg0_0(a0->size());
      IntVarArgs arg0_1(a0->size());
      for (int i=a0->size(); i--;) {
        arg0_0[i] = (*a0)[i]->first()->toInt();
        arg0_1[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->second()->toVar()])));
      }
      int arg1 = spec[1]->typedArg()->toInt();
      int arg2 = spec[2]->toInt();
      count(home,  arg0_1 ,  arg0_0 ,  IRT_LQ ,  arg2 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pcount_PLqInt() { registry.add("int.count.LqInt", &post); }
};
int_Pcount_PLqInt _int_Pcount_PLqInt;

class int_Pcount_PLqView {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 2]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      IntVar arg2 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[2]->typedArg()->toVar()])));
      int arg3 = spec[3]->toInt();
      my_count(home,  arg0 ,  arg1 ,  IRT_LQ ,  arg2 ,  arg3 );
      return;
    }
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 2]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      int arg1 = spec[1]->typedArg()->toInt();
      IntVar arg2 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[2]->typedArg()->toVar()])));
      int arg3 = spec[3]->toInt();
      my_count(home,  arg0 ,  arg1 ,  IRT_LQ ,  arg2 ,  arg3 );
      return;
    }
    if ( _typeDefs.offsetvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 2]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntArgs arg0_0(a0->size());
      IntVarArgs arg0_1(a0->size());
      for (int i=a0->size(); i--;) {
        arg0_0[i] = (*a0)[i]->first()->toInt();
        arg0_1[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->second()->toVar()])));
      }
      int arg1 = spec[1]->typedArg()->toInt();
      IntVar arg2 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[2]->typedArg()->toVar()])));
      int arg3 = spec[3]->toInt();
      my_count(home,  arg0_1 ,  arg0_0 ,  IRT_LQ ,  arg2 ,  arg3 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pcount_PLqView() { registry.add("int.count.LqView", &post); }
};
int_Pcount_PLqView _int_Pcount_PLqView;

class int_Pcount_PNqInt {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      int arg2 = spec[2]->toInt();
      count(home,  arg0 ,  arg1 ,  IRT_NQ ,  arg2 );
      return;
    }
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      int arg1 = spec[1]->typedArg()->toInt();
      int arg2 = spec[2]->toInt();
      count(home,  arg0 ,  arg1 ,  IRT_NQ ,  arg2 );
      return;
    }
    if ( _typeDefs.offsetvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntArgs arg0_0(a0->size());
      IntVarArgs arg0_1(a0->size());
      for (int i=a0->size(); i--;) {
        arg0_0[i] = (*a0)[i]->first()->toInt();
        arg0_1[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->second()->toVar()])));
      }
      int arg1 = spec[1]->typedArg()->toInt();
      int arg2 = spec[2]->toInt();
      count(home,  arg0_1 ,  arg0_0 ,  IRT_NQ ,  arg2 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pcount_PNqInt() { registry.add("int.count.NqInt", &post); }
};
int_Pcount_PNqInt _int_Pcount_PNqInt;

class int_Pcount_PNqView {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 2]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      IntVar arg2 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[2]->typedArg()->toVar()])));
      int arg3 = spec[3]->toInt();
      my_count(home,  arg0 ,  arg1 ,  IRT_NQ ,  arg2 ,  arg3 );
      return;
    }
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 2]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      int arg1 = spec[1]->typedArg()->toInt();
      IntVar arg2 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[2]->typedArg()->toVar()])));
      int arg3 = spec[3]->toInt();
      my_count(home,  arg0 ,  arg1 ,  IRT_NQ ,  arg2 ,  arg3 );
      return;
    }
    if ( _typeDefs.offsetvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 2]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntArgs arg0_0(a0->size());
      IntVarArgs arg0_1(a0->size());
      for (int i=a0->size(); i--;) {
        arg0_0[i] = (*a0)[i]->first()->toInt();
        arg0_1[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->second()->toVar()])));
      }
      int arg1 = spec[1]->typedArg()->toInt();
      IntVar arg2 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[2]->typedArg()->toVar()])));
      int arg3 = spec[3]->toInt();
      my_count(home,  arg0_1 ,  arg0_0 ,  IRT_NQ ,  arg2 ,  arg3 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pcount_PNqView() { registry.add("int.count.NqView", &post); }
};
int_Pcount_PNqView _int_Pcount_PNqView;

class int_Pcumulatives_PVal {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pcumulatives_PVal() { registry.add("int.cumulatives.Val", &post); }
};
int_Pcumulatives_PVal _int_Pcumulatives_PVal;

class int_Pdistinct_PTerDom {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 2]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      IntVar arg2 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[2]->typedArg()->toVar()])));
      IntVarArgs argL0(3);
      argL0[0] = arg0;
      argL0[1] = arg1;
      argL0[2] = arg2;
      distinct(home,  argL0 ,  ICL_DOM );
      return;
    }
    if ( _typeDefs.offsetvar.equal(spec[ 0]->type()) &&
         _typeDefs.offsetvar.equal(spec[ 1]->type()) &&
         _typeDefs.offsetvar.equal(spec[ 2]->type()) &&
        true) {
      int arg0_0 = spec[0]->typedArg()->first()->toInt();
      IntVar arg0_1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->second()->toVar()])));
      int arg1_0 = spec[1]->typedArg()->first()->toInt();
      IntVar arg1_1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->second()->toVar()])));
      int arg2_0 = spec[2]->typedArg()->first()->toInt();
      IntVar arg2_1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[2]->typedArg()->second()->toVar()])));
      my_distinct(home,  arg0_0 ,  arg1_0 ,  arg2_0 ,  arg0_1 ,  arg1_1 ,  arg2_1 ,  ICL_DOM );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pdistinct_PTerDom() { registry.add("int.distinct.TerDom", &post); }
};
int_Pdistinct_PTerDom _int_Pdistinct_PTerDom;

class int_Pdom_PReIntSet {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.boolvar.equal(spec[ 1]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      Reflection::ArrayArg<int>* a2 =
        spec[2]->toArray<int>();
      IntArrayIter iai2(a2);
      IntSet arg2(iai2);
      dom(home,  arg0 ,  arg2 ,  arg1 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pdom_PReIntSet() { registry.add("int.dom.ReIntSet", &post); }
};
int_Pdom_PReIntSet _int_Pdom_PReIntSet;

class int_Pdom_PReRange {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.boolvar.equal(spec[ 1]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      int arg2 = spec[2]->toInt();
      int arg3 = spec[3]->toInt();
      dom(home,  arg0 ,  arg2 ,  arg3 ,  arg1 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pdom_PReRange() { registry.add("int.dom.ReRange", &post); }
};
int_Pdom_PReRange _int_Pdom_PReRange;

class int_Pelement_PInt {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      Reflection::ArrayArg<int>* a2 =
        spec[2]->toArray<int>();
      IntArgs arg2(a2->size());
      for (int i=a2->size(); i--;) {
        arg2[i] = (*a2)[i];
      }
      element(home,  arg2 ,  arg0 ,  arg1 );
      return;
    }
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.boolvar.equal(spec[ 1]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      Reflection::ArrayArg<int>* a2 =
        spec[2]->toArray<int>();
      IntArgs arg2(a2->size());
      for (int i=a2->size(); i--;) {
        arg2[i] = (*a2)[i];
      }
      element(home,  arg2 ,  arg0 ,  arg1 );
      return;
    }
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      int arg1 = spec[1]->typedArg()->toInt();
      Reflection::ArrayArg<int>* a2 =
        spec[2]->toArray<int>();
      IntArgs arg2(a2->size());
      for (int i=a2->size(); i--;) {
        arg2[i] = (*a2)[i];
      }
      element(home,  arg2 ,  arg0 ,  arg1 );
      return;
    }
    if ( _typeDefs.offsetvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      int arg0_0 = spec[0]->typedArg()->first()->toInt();
      IntVar arg0_1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->second()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      Reflection::ArrayArg<int>* a2 =
        spec[2]->toArray<int>();
      IntArgs arg2(a2->size());
      for (int i=a2->size(); i--;) {
        arg2[i] = (*a2)[i];
      }
      element(home,  arg2 ,  arg0_1 ,  arg1 ,  arg0_0 );
      return;
    }
    if ( _typeDefs.offsetvar.equal(spec[ 0]->type()) &&
         _typeDefs.boolvar.equal(spec[ 1]->type()) &&
        true) {
      int arg0_0 = spec[0]->typedArg()->first()->toInt();
      IntVar arg0_1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->second()->toVar()])));
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      Reflection::ArrayArg<int>* a2 =
        spec[2]->toArray<int>();
      IntArgs arg2(a2->size());
      for (int i=a2->size(); i--;) {
        arg2[i] = (*a2)[i];
      }
      element(home,  arg2 ,  arg0_1 ,  arg1 ,  arg0_0 );
      return;
    }
    if ( _typeDefs.offsetvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
        true) {
      int arg0_0 = spec[0]->typedArg()->first()->toInt();
      IntVar arg0_1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->second()->toVar()])));
      int arg1 = spec[1]->typedArg()->toInt();
      Reflection::ArrayArg<int>* a2 =
        spec[2]->toArray<int>();
      IntArgs arg2(a2->size());
      for (int i=a2->size(); i--;) {
        arg2[i] = (*a2)[i];
      }
      element(home,  arg2 ,  arg0_1 ,  arg1 ,  arg0_0 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pelement_PInt() { registry.add("int.element.Int", &post); }
};
int_Pelement_PInt _int_Pelement_PInt;

class int_Pelement_PViewBnd {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 3]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      Reflection::ArrayArg<int>* a2 =
        spec[2]->toArray<int>();
      IntArgs arg2(a2->size());
      for (int i=a2->size(); i--;) {
        arg2[i] = (*a2)[i];
      }
      Reflection::ArrayArg<Reflection::Arg*>* a3 =
        spec[3]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg3(a3->size());
      for (int i=a3->size(); i--;) {
        arg3[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a3)[i]->toVar()])));
      }
      my_element(home,  arg2 ,  arg3 ,  arg0 ,  arg1 ,  0 ,  ICL_BND );
      return;
    }
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 3]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      int arg1 = spec[1]->typedArg()->toInt();
      Reflection::ArrayArg<int>* a2 =
        spec[2]->toArray<int>();
      IntArgs arg2(a2->size());
      for (int i=a2->size(); i--;) {
        arg2[i] = (*a2)[i];
      }
      Reflection::ArrayArg<Reflection::Arg*>* a3 =
        spec[3]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg3(a3->size());
      for (int i=a3->size(); i--;) {
        arg3[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a3)[i]->toVar()])));
      }
      my_element(home,  arg2 ,  arg3 ,  arg0 ,  arg1 ,  0 ,  ICL_BND );
      return;
    }
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.boolvar.equal(spec[ 1]->type()) &&
         _typeDefs.boolvar.equal(spec[ 3]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      Reflection::ArrayArg<int>* a2 =
        spec[2]->toArray<int>();
      IntArgs arg2(a2->size());
      for (int i=a2->size(); i--;) {
        arg2[i] = (*a2)[i];
      }
      Reflection::ArrayArg<Reflection::Arg*>* a3 =
        spec[3]->typedArg()->toArray<Reflection::Arg*>();
      BoolVarArgs arg3(a3->size());
      for (int i=a3->size(); i--;) {
        arg3[i] = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[(*a3)[i]->toVar()])));
      }
      my_element(home,  arg2 ,  arg3 ,  arg0 ,  arg1 ,  0 ,  ICL_BND );
      return;
    }
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
         _typeDefs.boolvar.equal(spec[ 3]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      int arg1 = spec[1]->typedArg()->toInt();
      Reflection::ArrayArg<int>* a2 =
        spec[2]->toArray<int>();
      IntArgs arg2(a2->size());
      for (int i=a2->size(); i--;) {
        arg2[i] = (*a2)[i];
      }
      Reflection::ArrayArg<Reflection::Arg*>* a3 =
        spec[3]->typedArg()->toArray<Reflection::Arg*>();
      BoolVarArgs arg3(a3->size());
      for (int i=a3->size(); i--;) {
        arg3[i] = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[(*a3)[i]->toVar()])));
      }
      my_element(home,  arg2 ,  arg3 ,  arg0 ,  arg1 ,  0 ,  ICL_BND );
      return;
    }
    if ( _typeDefs.offsetvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 3]->type()) &&
        true) {
      int arg0_0 = spec[0]->typedArg()->first()->toInt();
      IntVar arg0_1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->second()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      Reflection::ArrayArg<int>* a2 =
        spec[2]->toArray<int>();
      IntArgs arg2(a2->size());
      for (int i=a2->size(); i--;) {
        arg2[i] = (*a2)[i];
      }
      Reflection::ArrayArg<Reflection::Arg*>* a3 =
        spec[3]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg3(a3->size());
      for (int i=a3->size(); i--;) {
        arg3[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a3)[i]->toVar()])));
      }
      my_element(home,  arg2 ,  arg3 ,  arg0_1 ,  arg1 ,  arg0_0 ,  ICL_BND );
      return;
    }
    if ( _typeDefs.offsetvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 3]->type()) &&
        true) {
      int arg0_0 = spec[0]->typedArg()->first()->toInt();
      IntVar arg0_1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->second()->toVar()])));
      int arg1 = spec[1]->typedArg()->toInt();
      Reflection::ArrayArg<int>* a2 =
        spec[2]->toArray<int>();
      IntArgs arg2(a2->size());
      for (int i=a2->size(); i--;) {
        arg2[i] = (*a2)[i];
      }
      Reflection::ArrayArg<Reflection::Arg*>* a3 =
        spec[3]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg3(a3->size());
      for (int i=a3->size(); i--;) {
        arg3[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a3)[i]->toVar()])));
      }
      my_element(home,  arg2 ,  arg3 ,  arg0_1 ,  arg1 ,  arg0_0 ,  ICL_BND );
      return;
    }
    if ( _typeDefs.offsetvar.equal(spec[ 0]->type()) &&
         _typeDefs.boolvar.equal(spec[ 1]->type()) &&
         _typeDefs.boolvar.equal(spec[ 3]->type()) &&
        true) {
      int arg0_0 = spec[0]->typedArg()->first()->toInt();
      IntVar arg0_1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->second()->toVar()])));
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      Reflection::ArrayArg<int>* a2 =
        spec[2]->toArray<int>();
      IntArgs arg2(a2->size());
      for (int i=a2->size(); i--;) {
        arg2[i] = (*a2)[i];
      }
      Reflection::ArrayArg<Reflection::Arg*>* a3 =
        spec[3]->typedArg()->toArray<Reflection::Arg*>();
      BoolVarArgs arg3(a3->size());
      for (int i=a3->size(); i--;) {
        arg3[i] = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[(*a3)[i]->toVar()])));
      }
      my_element(home,  arg2 ,  arg3 ,  arg0_1 ,  arg1 ,  arg0_0 ,  ICL_BND );
      return;
    }
    if ( _typeDefs.offsetvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
         _typeDefs.boolvar.equal(spec[ 3]->type()) &&
        true) {
      int arg0_0 = spec[0]->typedArg()->first()->toInt();
      IntVar arg0_1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->second()->toVar()])));
      int arg1 = spec[1]->typedArg()->toInt();
      Reflection::ArrayArg<int>* a2 =
        spec[2]->toArray<int>();
      IntArgs arg2(a2->size());
      for (int i=a2->size(); i--;) {
        arg2[i] = (*a2)[i];
      }
      Reflection::ArrayArg<Reflection::Arg*>* a3 =
        spec[3]->typedArg()->toArray<Reflection::Arg*>();
      BoolVarArgs arg3(a3->size());
      for (int i=a3->size(); i--;) {
        arg3[i] = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[(*a3)[i]->toVar()])));
      }
      my_element(home,  arg2 ,  arg3 ,  arg0_1 ,  arg1 ,  arg0_0 ,  ICL_BND );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pelement_PViewBnd() { registry.add("int.element.ViewBnd", &post); }
};
int_Pelement_PViewBnd _int_Pelement_PViewBnd;

class int_Pelement_PViewDom {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 3]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      Reflection::ArrayArg<int>* a2 =
        spec[2]->toArray<int>();
      IntArgs arg2(a2->size());
      for (int i=a2->size(); i--;) {
        arg2[i] = (*a2)[i];
      }
      Reflection::ArrayArg<Reflection::Arg*>* a3 =
        spec[3]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg3(a3->size());
      for (int i=a3->size(); i--;) {
        arg3[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a3)[i]->toVar()])));
      }
      my_element(home,  arg2 ,  arg3 ,  arg0 ,  arg1 ,  0 ,  ICL_DOM );
      return;
    }
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 3]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      int arg1 = spec[1]->typedArg()->toInt();
      Reflection::ArrayArg<int>* a2 =
        spec[2]->toArray<int>();
      IntArgs arg2(a2->size());
      for (int i=a2->size(); i--;) {
        arg2[i] = (*a2)[i];
      }
      Reflection::ArrayArg<Reflection::Arg*>* a3 =
        spec[3]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg3(a3->size());
      for (int i=a3->size(); i--;) {
        arg3[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a3)[i]->toVar()])));
      }
      my_element(home,  arg2 ,  arg3 ,  arg0 ,  arg1 ,  0 ,  ICL_DOM );
      return;
    }
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.boolvar.equal(spec[ 1]->type()) &&
         _typeDefs.boolvar.equal(spec[ 3]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      Reflection::ArrayArg<int>* a2 =
        spec[2]->toArray<int>();
      IntArgs arg2(a2->size());
      for (int i=a2->size(); i--;) {
        arg2[i] = (*a2)[i];
      }
      Reflection::ArrayArg<Reflection::Arg*>* a3 =
        spec[3]->typedArg()->toArray<Reflection::Arg*>();
      BoolVarArgs arg3(a3->size());
      for (int i=a3->size(); i--;) {
        arg3[i] = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[(*a3)[i]->toVar()])));
      }
      my_element(home,  arg2 ,  arg3 ,  arg0 ,  arg1 ,  0 ,  ICL_DOM );
      return;
    }
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
         _typeDefs.boolvar.equal(spec[ 3]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      int arg1 = spec[1]->typedArg()->toInt();
      Reflection::ArrayArg<int>* a2 =
        spec[2]->toArray<int>();
      IntArgs arg2(a2->size());
      for (int i=a2->size(); i--;) {
        arg2[i] = (*a2)[i];
      }
      Reflection::ArrayArg<Reflection::Arg*>* a3 =
        spec[3]->typedArg()->toArray<Reflection::Arg*>();
      BoolVarArgs arg3(a3->size());
      for (int i=a3->size(); i--;) {
        arg3[i] = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[(*a3)[i]->toVar()])));
      }
      my_element(home,  arg2 ,  arg3 ,  arg0 ,  arg1 ,  0 ,  ICL_DOM );
      return;
    }
    if ( _typeDefs.offsetvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 3]->type()) &&
        true) {
      int arg0_0 = spec[0]->typedArg()->first()->toInt();
      IntVar arg0_1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->second()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      Reflection::ArrayArg<int>* a2 =
        spec[2]->toArray<int>();
      IntArgs arg2(a2->size());
      for (int i=a2->size(); i--;) {
        arg2[i] = (*a2)[i];
      }
      Reflection::ArrayArg<Reflection::Arg*>* a3 =
        spec[3]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg3(a3->size());
      for (int i=a3->size(); i--;) {
        arg3[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a3)[i]->toVar()])));
      }
      my_element(home,  arg2 ,  arg3 ,  arg0_1 ,  arg1 ,  arg0_0 ,  ICL_DOM );
      return;
    }
    if ( _typeDefs.offsetvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
         _typeDefs.intvar.equal(spec[ 3]->type()) &&
        true) {
      int arg0_0 = spec[0]->typedArg()->first()->toInt();
      IntVar arg0_1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->second()->toVar()])));
      int arg1 = spec[1]->typedArg()->toInt();
      Reflection::ArrayArg<int>* a2 =
        spec[2]->toArray<int>();
      IntArgs arg2(a2->size());
      for (int i=a2->size(); i--;) {
        arg2[i] = (*a2)[i];
      }
      Reflection::ArrayArg<Reflection::Arg*>* a3 =
        spec[3]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg3(a3->size());
      for (int i=a3->size(); i--;) {
        arg3[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a3)[i]->toVar()])));
      }
      my_element(home,  arg2 ,  arg3 ,  arg0_1 ,  arg1 ,  arg0_0 ,  ICL_DOM );
      return;
    }
    if ( _typeDefs.offsetvar.equal(spec[ 0]->type()) &&
         _typeDefs.boolvar.equal(spec[ 1]->type()) &&
         _typeDefs.boolvar.equal(spec[ 3]->type()) &&
        true) {
      int arg0_0 = spec[0]->typedArg()->first()->toInt();
      IntVar arg0_1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->second()->toVar()])));
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      Reflection::ArrayArg<int>* a2 =
        spec[2]->toArray<int>();
      IntArgs arg2(a2->size());
      for (int i=a2->size(); i--;) {
        arg2[i] = (*a2)[i];
      }
      Reflection::ArrayArg<Reflection::Arg*>* a3 =
        spec[3]->typedArg()->toArray<Reflection::Arg*>();
      BoolVarArgs arg3(a3->size());
      for (int i=a3->size(); i--;) {
        arg3[i] = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[(*a3)[i]->toVar()])));
      }
      my_element(home,  arg2 ,  arg3 ,  arg0_1 ,  arg1 ,  arg0_0 ,  ICL_DOM );
      return;
    }
    if ( _typeDefs.offsetvar.equal(spec[ 0]->type()) &&
         _typeDefs.constint.equal(spec[ 1]->type()) &&
         _typeDefs.boolvar.equal(spec[ 3]->type()) &&
        true) {
      int arg0_0 = spec[0]->typedArg()->first()->toInt();
      IntVar arg0_1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->second()->toVar()])));
      int arg1 = spec[1]->typedArg()->toInt();
      Reflection::ArrayArg<int>* a2 =
        spec[2]->toArray<int>();
      IntArgs arg2(a2->size());
      for (int i=a2->size(); i--;) {
        arg2[i] = (*a2)[i];
      }
      Reflection::ArrayArg<Reflection::Arg*>* a3 =
        spec[3]->typedArg()->toArray<Reflection::Arg*>();
      BoolVarArgs arg3(a3->size());
      for (int i=a3->size(); i--;) {
        arg3[i] = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[(*a3)[i]->toVar()])));
      }
      my_element(home,  arg2 ,  arg3 ,  arg0_1 ,  arg1 ,  arg0_0 ,  ICL_DOM );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pelement_PViewDom() { registry.add("int.element.ViewDom", &post); }
};
int_Pelement_PViewDom _int_Pelement_PViewDom;

class int_Pextensional_PBasic {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pextensional_PBasic() { registry.add("int.extensional.Basic", &post); }
};
int_Pextensional_PBasic _int_Pextensional_PBasic;

class int_Pextensional_PIncremental {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pextensional_PIncremental() { registry.add("int.extensional.Incremental", &post); }
};
int_Pextensional_PIncremental _int_Pextensional_PIncremental;

class int_Pextensional_PVal {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pextensional_PVal() { registry.add("int.extensional.Val", &post); }
};
int_Pextensional_PVal _int_Pextensional_PVal;

class int_Pgcc_PBnd {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pgcc_PBnd() { registry.add("int.gcc.Bnd", &post); }
};
int_Pgcc_PBnd _int_Pgcc_PBnd;

class int_Pgcc_PDom {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pgcc_PDom() { registry.add("int.gcc.Dom", &post); }
};
int_Pgcc_PDom _int_Pgcc_PDom;

class int_Pgcc_PVal {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pgcc_PVal() { registry.add("int.gcc.Val", &post); }
};
int_Pgcc_PVal _int_Pgcc_PVal;

class int_Plinear_PDomEq {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PDomEq() { registry.add("int.linear.DomEq", &post); }
};
int_Plinear_PDomEq _int_Plinear_PDomEq;

class int_Plinear_PEq {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PEq() { registry.add("int.linear.Eq", &post); }
};
int_Plinear_PEq _int_Plinear_PEq;

class int_Plinear_PEqBin {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PEqBin() { registry.add("int.linear.EqBin", &post); }
};
int_Plinear_PEqBin _int_Plinear_PEqBin;

class int_Plinear_PEqBoolInt_Pmemory {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PEqBoolInt_Pmemory() { registry.add("int.linear.EqBoolInt.memory", &post); }
};
int_Plinear_PEqBoolInt_Pmemory _int_Plinear_PEqBoolInt_Pmemory;

class int_Plinear_PEqBoolInt_Pspeed {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PEqBoolInt_Pspeed() { registry.add("int.linear.EqBoolInt.speed", &post); }
};
int_Plinear_PEqBoolInt_Pspeed _int_Plinear_PEqBoolInt_Pspeed;

class int_Plinear_PEqBoolScale {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PEqBoolScale() { registry.add("int.linear.EqBoolScale", &post); }
};
int_Plinear_PEqBoolScale _int_Plinear_PEqBoolScale;

class int_Plinear_PEqBoolView {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PEqBoolView() { registry.add("int.linear.EqBoolView", &post); }
};
int_Plinear_PEqBoolView _int_Plinear_PEqBoolView;

class int_Plinear_PEqTer {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PEqTer() { registry.add("int.linear.EqTer", &post); }
};
int_Plinear_PEqTer _int_Plinear_PEqTer;

class int_Plinear_PGqBin {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PGqBin() { registry.add("int.linear.GqBin", &post); }
};
int_Plinear_PGqBin _int_Plinear_PGqBin;

class int_Plinear_PGqBoolInt_PSpeed {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PGqBoolInt_PSpeed() { registry.add("int.linear.GqBoolInt.Speed", &post); }
};
int_Plinear_PGqBoolInt_PSpeed _int_Plinear_PGqBoolInt_PSpeed;

class int_Plinear_PGqBoolInt_Pmemory {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PGqBoolInt_Pmemory() { registry.add("int.linear.GqBoolInt.memory", &post); }
};
int_Plinear_PGqBoolInt_Pmemory _int_Plinear_PGqBoolInt_Pmemory;

class int_Plinear_PGqBoolView {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PGqBoolView() { registry.add("int.linear.GqBoolView", &post); }
};
int_Plinear_PGqBoolView _int_Plinear_PGqBoolView;

class int_Plinear_PLq {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PLq() { registry.add("int.linear.Lq", &post); }
};
int_Plinear_PLq _int_Plinear_PLq;

class int_Plinear_PLqBin {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PLqBin() { registry.add("int.linear.LqBin", &post); }
};
int_Plinear_PLqBin _int_Plinear_PLqBin;

class int_Plinear_PLqBoolScale {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PLqBoolScale() { registry.add("int.linear.LqBoolScale", &post); }
};
int_Plinear_PLqBoolScale _int_Plinear_PLqBoolScale;

class int_Plinear_PLqTer {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PLqTer() { registry.add("int.linear.LqTer", &post); }
};
int_Plinear_PLqTer _int_Plinear_PLqTer;

class int_Plinear_PNq {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PNq() { registry.add("int.linear.Nq", &post); }
};
int_Plinear_PNq _int_Plinear_PNq;

class int_Plinear_PNqBin {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PNqBin() { registry.add("int.linear.NqBin", &post); }
};
int_Plinear_PNqBin _int_Plinear_PNqBin;

class int_Plinear_PNqBoolInt {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PNqBoolInt() { registry.add("int.linear.NqBoolInt", &post); }
};
int_Plinear_PNqBoolInt _int_Plinear_PNqBoolInt;

class int_Plinear_PNqBoolScale {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PNqBoolScale() { registry.add("int.linear.NqBoolScale", &post); }
};
int_Plinear_PNqBoolScale _int_Plinear_PNqBoolScale;

class int_Plinear_PNqBoolView {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PNqBoolView() { registry.add("int.linear.NqBoolView", &post); }
};
int_Plinear_PNqBoolView _int_Plinear_PNqBoolView;

class int_Plinear_PNqTer {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PNqTer() { registry.add("int.linear.NqTer", &post); }
};
int_Plinear_PNqTer _int_Plinear_PNqTer;

class int_Plinear_PReEq {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PReEq() { registry.add("int.linear.ReEq", &post); }
};
int_Plinear_PReEq _int_Plinear_PReEq;

class int_Plinear_PReEqBin {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PReEqBin() { registry.add("int.linear.ReEqBin", &post); }
};
int_Plinear_PReEqBin _int_Plinear_PReEqBin;

class int_Plinear_PReLq {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PReLq() { registry.add("int.linear.ReLq", &post); }
};
int_Plinear_PReLq _int_Plinear_PReLq;

class int_Plinear_PReLqBin {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Plinear_PReLqBin() { registry.add("int.linear.ReLqBin", &post); }
};
int_Plinear_PReLqBin _int_Plinear_PReLqBin;

class int_Pregular_PDom {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Pregular_PDom() { registry.add("int.regular.Dom", &post); }
};
int_Pregular_PDom _int_Pregular_PDom;

class int_Prel_PEqBnd {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      rel(home,  arg0 ,  IRT_EQ ,  arg1 ,  ICL_BND );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Prel_PEqBnd() { registry.add("int.rel.EqBnd", &post); }
};
int_Prel_PEqBnd _int_Prel_PEqBnd;

class int_Prel_PEqDom {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      rel(home,  arg0 ,  IRT_EQ ,  arg1 ,  ICL_DOM );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Prel_PEqDom() { registry.add("int.rel.EqDom", &post); }
};
int_Prel_PEqDom _int_Prel_PEqDom;

class int_Prel_PLe {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      rel(home,  arg0 ,  IRT_LE ,  arg1 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Prel_PLe() { registry.add("int.rel.Le", &post); }
};
int_Prel_PLe _int_Prel_PLe;

class int_Prel_PLex {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Prel_PLex() { registry.add("int.rel.Lex", &post); }
};
int_Prel_PLex _int_Prel_PLex;

class int_Prel_PLexStrict {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Prel_PLexStrict() { registry.add("int.rel.LexStrict", &post); }
};
int_Prel_PLexStrict _int_Prel_PLexStrict;

class int_Prel_PLq {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      rel(home,  arg0 ,  IRT_LQ ,  arg1 );
      return;
    }
    if ( _typeDefs.boolvar.equal(spec[ 0]->type()) &&
         _typeDefs.boolvar.equal(spec[ 1]->type()) &&
        true) {
      BoolVar arg0 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[0]->typedArg()->toVar()])));
      BoolVar arg1 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[1]->typedArg()->toVar()])));
      rel(home,  arg0 ,  IRT_LQ ,  arg1 );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Prel_PLq() { registry.add("int.rel.Lq", &post); }
};
int_Prel_PLq _int_Prel_PLq;

class int_Prel_PNaryEqBnd {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      rel(home,  arg0 ,  IRT_EQ ,  ICL_BND );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Prel_PNaryEqBnd() { registry.add("int.rel.NaryEqBnd", &post); }
};
int_Prel_PNaryEqBnd _int_Prel_PNaryEqBnd;

class int_Prel_PNaryEqDom {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      rel(home,  arg0 ,  IRT_EQ ,  ICL_DOM );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Prel_PNaryEqDom() { registry.add("int.rel.NaryEqDom", &post); }
};
int_Prel_PNaryEqDom _int_Prel_PNaryEqDom;

class int_Prel_PNaryNq {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      rel(home,  arg0 ,  IRT_NQ ,  ICL_DOM );
      return;
    }
    if ( _typeDefs.boolvar.equal(spec[ 0]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      BoolVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[(*a0)[i]->toVar()])));
      }
      rel(home,  arg0 ,  IRT_NQ ,  ICL_DOM );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Prel_PNaryNq() { registry.add("int.rel.NaryNq", &post); }
};
int_Prel_PNaryNq _int_Prel_PNaryNq;

class int_Prel_PNq {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      IntVar arg0 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      rel(home,  arg0 ,  IRT_NQ ,  arg1 );
      return;
    }
    if ( _typeDefs.offsetvar.equal(spec[ 0]->type()) &&
         _typeDefs.offsetvar.equal(spec[ 1]->type()) &&
        true) {
      int arg0_0 = spec[0]->typedArg()->first()->toInt();
      IntVar arg0_1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[0]->typedArg()->second()->toVar()])));
      int arg1_0 = spec[1]->typedArg()->first()->toInt();
      IntVar arg1_1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->second()->toVar()])));
      my_distinct(home,  arg0_0 ,  arg1_0 ,  arg0_1 ,  arg1_1 ,  ICL_DEF );
      return;
    }
    throw Exception("Registry","No suitable post function defined");
  }
  int_Prel_PNq() { registry.add("int.rel.Nq", &post); }
};
int_Prel_PNq _int_Prel_PNq;

class int_Prel_PReEqBnd {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Prel_PReEqBnd() { registry.add("int.rel.ReEqBnd", &post); }
};
int_Prel_PReEqBnd _int_Prel_PReEqBnd;

class int_Prel_PReEqBndInt {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Prel_PReEqBndInt() { registry.add("int.rel.ReEqBndInt", &post); }
};
int_Prel_PReEqBndInt _int_Prel_PReEqBndInt;

class int_Prel_PReEqDom {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Prel_PReEqDom() { registry.add("int.rel.ReEqDom", &post); }
};
int_Prel_PReEqDom _int_Prel_PReEqDom;

class int_Prel_PReEqDomInt {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Prel_PReEqDomInt() { registry.add("int.rel.ReEqDomInt", &post); }
};
int_Prel_PReEqDomInt _int_Prel_PReEqDomInt;

class int_Prel_PReLq {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Prel_PReLq() { registry.add("int.rel.ReLq", &post); }
};
int_Prel_PReLq _int_Prel_PReLq;

class int_Prel_PReLqInt {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Prel_PReLqInt() { registry.add("int.rel.ReLqInt", &post); }
};
int_Prel_PReLqInt _int_Prel_PReLqInt;

class int_Psortedness_PSortedness {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  int_Psortedness_PSortedness() { registry.add("int.sortedness.Sortedness", &post); }
};
int_Psortedness_PSortedness _int_Psortedness_PSortedness;

class set_Pconvex_PConvex {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if ( _typeDefs.setvar.equal(spec[ 0]->type()) &&
        true) {
      SetVar arg0 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[0]->typedArg()->toVar()])));
      convex(home,  arg0 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Pconvex_PConvex() { registry.add("set.convex.Convex", &post); }
};
set_Pconvex_PConvex _set_Pconvex_PConvex;

class set_Pconvex_PConvexHull {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if ( _typeDefs.setvar.equal(spec[ 0]->type()) &&
         _typeDefs.setvar.equal(spec[ 1]->type()) &&
        true) {
      SetVar arg0 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[0]->typedArg()->toVar()])));
      SetVar arg1 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[1]->typedArg()->toVar()])));
      convexHull(home,  arg0 ,  arg1 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Pconvex_PConvexHull() { registry.add("set.convex.ConvexHull", &post); }
};
set_Pconvex_PConvexHull _set_Pconvex_PConvexHull;

class set_Pdistinct_PAtmostOne {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if ( _typeDefs.setvar.equal(spec[ 0]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      SetVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[(*a0)[i]->toVar()])));
      }
      int arg1 = spec[1]->toInt();
      atmostOne(home,  arg0 ,  arg1 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Pdistinct_PAtmostOne() { registry.add("set.distinct.AtmostOne", &post); }
};
set_Pdistinct_PAtmostOne _set_Pdistinct_PAtmostOne;

class set_Pdistinct_PDistinct {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if ( _typeDefs.setvar.equal(spec[ 0]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      SetVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[(*a0)[i]->toVar()])));
      }
      int arg1 = spec[1]->toInt();
      distinct(home,  arg0 ,  arg1 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Pdistinct_PDistinct() { registry.add("set.distinct.Distinct", &post); }
};
set_Pdistinct_PDistinct _set_Pdistinct_PDistinct;

class set_Pint_PCard {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if ( _typeDefs.setvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      SetVar arg0 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[0]->typedArg()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      cardinality(home,  arg0 ,  arg1 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Pint_PCard() { registry.add("set.int.Card", &post); }
};
set_Pint_PCard _set_Pint_PCard;

class set_Pint_PChannel {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if ( _typeDefs.intvar.equal(spec[ 0]->type()) &&
         _typeDefs.setvar.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a0)[i]->toVar()])));
      }
      Reflection::ArrayArg<Reflection::Arg*>* a1 =
        spec[1]->typedArg()->toArray<Reflection::Arg*>();
      SetVarArgs arg1(a1->size());
      for (int i=a1->size(); i--;) {
        arg1[i] = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[(*a1)[i]->toVar()])));
      }
      channel(home,  arg0 ,  arg1 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Pint_PChannel() { registry.add("set.int.Channel", &post); }
};
set_Pint_PChannel _set_Pint_PChannel;

class set_Pint_PMatch {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if ( _typeDefs.setvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      SetVar arg0 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[0]->typedArg()->toVar()])));
      Reflection::ArrayArg<Reflection::Arg*>* a1 =
        spec[1]->typedArg()->toArray<Reflection::Arg*>();
      IntVarArgs arg1(a1->size());
      for (int i=a1->size(); i--;) {
        arg1[i] = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[(*a1)[i]->toVar()])));
      }
      match(home,  arg0 ,  arg1 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Pint_PMatch() { registry.add("set.int.Match", &post); }
};
set_Pint_PMatch _set_Pint_PMatch;

class set_Pint_PMaxElement {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if ( _typeDefs.setvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      SetVar arg0 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[0]->typedArg()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      max(home,  arg0 ,  arg1 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Pint_PMaxElement() { registry.add("set.int.MaxElement", &post); }
};
set_Pint_PMaxElement _set_Pint_PMaxElement;

class set_Pint_PMinElement {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if ( _typeDefs.setvar.equal(spec[ 0]->type()) &&
         _typeDefs.intvar.equal(spec[ 1]->type()) &&
        true) {
      SetVar arg0 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[0]->typedArg()->toVar()])));
      IntVar arg1 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[1]->typedArg()->toVar()])));
      min(home,  arg0 ,  arg1 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Pint_PMinElement() { registry.add("set.int.MinElement", &post); }
};
set_Pint_PMinElement _set_Pint_PMinElement;

class set_Pint_PWeights {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if (          _typeDefs.setvar.equal(spec[ 2]->type()) &&
         _typeDefs.intvar.equal(spec[ 3]->type()) &&
        true) {
      Reflection::ArrayArg<int>* a0 =
        spec[0]->toArray<int>();
      IntArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = (*a0)[i];
      }
      Reflection::ArrayArg<int>* a1 =
        spec[1]->toArray<int>();
      IntArgs arg1(a1->size());
      for (int i=a1->size(); i--;) {
        arg1[i] = (*a1)[i];
      }
      SetVar arg2 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[2]->typedArg()->toVar()])));
      IntVar arg3 = IntVar(Int::IntView(static_cast<Int::IntVarImp*>(v[spec[3]->typedArg()->toVar()])));
      weights(home,  arg0 ,  arg1 ,  arg2 ,  arg3 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Pint_PWeights() { registry.add("set.int.Weights", &post); }
};
set_Pint_PWeights _set_Pint_PWeights;

class set_Pprojectors_PCardProjection {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  set_Pprojectors_PCardProjection() { registry.add("set.projectors.CardProjection", &post); }
};
set_Pprojectors_PCardProjection _set_Pprojectors_PCardProjection;

class set_Pprojectors_PReNaryProjection {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  set_Pprojectors_PReNaryProjection() { registry.add("set.projectors.ReNaryProjection", &post); }
};
set_Pprojectors_PReNaryProjection _set_Pprojectors_PReNaryProjection;

class set_Prel_PDistinct {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if ( _typeDefs.setvar.equal(spec[ 0]->type()) &&
         _typeDefs.setvar.equal(spec[ 1]->type()) &&
        true) {
      SetVar arg0 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[0]->typedArg()->toVar()])));
      SetVar arg1 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[1]->typedArg()->toVar()])));
      rel(home,  arg0 ,  SRT_NQ ,  arg1 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Prel_PDistinct() { registry.add("set.rel.Distinct", &post); }
};
set_Prel_PDistinct _set_Prel_PDistinct;

class set_Prel_PDistinctDoit {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if ( _typeDefs.setvar.equal(spec[ 0]->type()) &&
         _typeDefs.setvar.equal(spec[ 1]->type()) &&
        true) {
      SetVar arg0 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[0]->typedArg()->toVar()])));
      SetVar arg1 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[1]->typedArg()->toVar()])));
      rel(home,  arg0 ,  SRT_NQ ,  arg1 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Prel_PDistinctDoit() { registry.add("set.rel.DistinctDoit", &post); }
};
set_Prel_PDistinctDoit _set_Prel_PDistinctDoit;

class set_Prel_PEq {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if ( _typeDefs.setvar.equal(spec[ 0]->type()) &&
         _typeDefs.setvar.equal(spec[ 1]->type()) &&
        true) {
      SetVar arg0 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[0]->typedArg()->toVar()])));
      SetVar arg1 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[1]->typedArg()->toVar()])));
      rel(home,  arg0 ,  SRT_EQ ,  arg1 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Prel_PEq() { registry.add("set.rel.Eq", &post); }
};
set_Prel_PEq _set_Prel_PEq;

class set_Prel_PNoSubSet {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  set_Prel_PNoSubSet() { registry.add("set.rel.NoSubSet", &post); }
};
set_Prel_PNoSubSet _set_Prel_PNoSubSet;

class set_Prel_PReEq {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if ( _typeDefs.setvar.equal(spec[ 0]->type()) &&
         _typeDefs.setvar.equal(spec[ 1]->type()) &&
         _typeDefs.boolvar.equal(spec[ 2]->type()) &&
        true) {
      SetVar arg0 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[0]->typedArg()->toVar()])));
      SetVar arg1 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[1]->typedArg()->toVar()])));
      BoolVar arg2 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[2]->typedArg()->toVar()])));
      rel(home,  arg0 ,  SRT_EQ ,  arg1 ,  arg2 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Prel_PReEq() { registry.add("set.rel.ReEq", &post); }
};
set_Prel_PReEq _set_Prel_PReEq;

class set_Prel_PReSubset {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if ( _typeDefs.setvar.equal(spec[ 0]->type()) &&
         _typeDefs.setvar.equal(spec[ 1]->type()) &&
         _typeDefs.boolvar.equal(spec[ 2]->type()) &&
        true) {
      SetVar arg0 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[0]->typedArg()->toVar()])));
      SetVar arg1 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[1]->typedArg()->toVar()])));
      BoolVar arg2 = BoolVar(Int::BoolView(static_cast<Int::BoolVarImp*>(v[spec[2]->typedArg()->toVar()])));
      rel(home,  arg0 ,  SRT_SUB ,  arg1 ,  arg2 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Prel_PReSubset() { registry.add("set.rel.ReSubset", &post); }
};
set_Prel_PReSubset _set_Prel_PReSubset;

class set_Prel_PSubSet {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if ( _typeDefs.setvar.equal(spec[ 0]->type()) &&
         _typeDefs.setvar.equal(spec[ 1]->type()) &&
        true) {
      SetVar arg0 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[0]->typedArg()->toVar()])));
      SetVar arg1 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[1]->typedArg()->toVar()])));
      rel(home,  arg0 ,  SRT_SUB ,  arg1 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Prel_PSubSet() { registry.add("set.rel.SubSet", &post); }
};
set_Prel_PSubSet _set_Prel_PSubSet;

class set_Prelop_PIntersection {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if ( _typeDefs.setvar.equal(spec[ 0]->type()) &&
         _typeDefs.setvar.equal(spec[ 1]->type()) &&
         _typeDefs.setvar.equal(spec[ 2]->type()) &&
        true) {
      SetVar arg0 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[0]->typedArg()->toVar()])));
      SetVar arg1 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[1]->typedArg()->toVar()])));
      SetVar arg2 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[2]->typedArg()->toVar()])));
      rel(home,  arg0 ,  SOT_INTER ,  arg1 ,  SRT_EQ ,  arg2 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Prelop_PIntersection() { registry.add("set.relop.Intersection", &post); }
};
set_Prelop_PIntersection _set_Prelop_PIntersection;

class set_Prelop_PIntersectionN {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if ( _typeDefs.setvar.equal(spec[ 0]->type()) &&
         _typeDefs.setvar.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      SetVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[(*a0)[i]->toVar()])));
      }
      SetVar arg1 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[1]->typedArg()->toVar()])));
      rel(home,  SOT_INTER ,  arg0 ,  arg1 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Prelop_PIntersectionN() { registry.add("set.relop.IntersectionN", &post); }
};
set_Prelop_PIntersectionN _set_Prelop_PIntersectionN;

class set_Prelop_PPartitionN {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if ( _typeDefs.setvar.equal(spec[ 0]->type()) &&
         _typeDefs.setvar.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      SetVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[(*a0)[i]->toVar()])));
      }
      SetVar arg1 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[1]->typedArg()->toVar()])));
      rel(home,  SOT_DUNION ,  arg0 ,  arg1 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Prelop_PPartitionN() { registry.add("set.relop.PartitionN", &post); }
};
set_Prelop_PPartitionN _set_Prelop_PPartitionN;

class set_Prelop_PSubOfUnion {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if ( _typeDefs.setvar.equal(spec[ 0]->type()) &&
         _typeDefs.setvar.equal(spec[ 1]->type()) &&
         _typeDefs.setvar.equal(spec[ 2]->type()) &&
        true) {
      SetVar arg0 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[0]->typedArg()->toVar()])));
      SetVar arg1 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[1]->typedArg()->toVar()])));
      SetVar arg2 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[2]->typedArg()->toVar()])));
      rel(home,  arg0 ,  SOT_UNION ,  arg1 ,  SRT_SUP ,  arg2 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Prelop_PSubOfUnion() { registry.add("set.relop.SubOfUnion", &post); }
};
set_Prelop_PSubOfUnion _set_Prelop_PSubOfUnion;

class set_Prelop_PSuperOfInter {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if ( _typeDefs.setvar.equal(spec[ 0]->type()) &&
         _typeDefs.setvar.equal(spec[ 1]->type()) &&
         _typeDefs.setvar.equal(spec[ 2]->type()) &&
        true) {
      SetVar arg0 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[0]->typedArg()->toVar()])));
      SetVar arg1 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[1]->typedArg()->toVar()])));
      SetVar arg2 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[2]->typedArg()->toVar()])));
      rel(home,  arg0 ,  SOT_INTER ,  arg1 ,  SRT_SUB ,  arg2 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Prelop_PSuperOfInter() { registry.add("set.relop.SuperOfInter", &post); }
};
set_Prelop_PSuperOfInter _set_Prelop_PSuperOfInter;

class set_Prelop_PUnion {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if ( _typeDefs.setvar.equal(spec[ 0]->type()) &&
         _typeDefs.setvar.equal(spec[ 1]->type()) &&
         _typeDefs.setvar.equal(spec[ 2]->type()) &&
        true) {
      SetVar arg0 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[0]->typedArg()->toVar()])));
      SetVar arg1 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[1]->typedArg()->toVar()])));
      SetVar arg2 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[2]->typedArg()->toVar()])));
      rel(home,  arg0 ,  SOT_UNION ,  arg1 ,  SRT_EQ ,  arg2 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Prelop_PUnion() { registry.add("set.relop.Union", &post); }
};
set_Prelop_PUnion _set_Prelop_PUnion;

class set_Prelop_PUnionN {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if ( _typeDefs.setvar.equal(spec[ 0]->type()) &&
         _typeDefs.setvar.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      SetVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[(*a0)[i]->toVar()])));
      }
      SetVar arg1 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[1]->typedArg()->toVar()])));
      Reflection::ArrayArg<int>* a2 =
        spec[2]->toArray<int>();
      IntArrayIter iai2(a2);
      IntSet arg2(iai2);
      rel(home,  SOT_UNION ,  arg0 ,  arg2 ,  arg1 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Prelop_PUnionN() { registry.add("set.relop.UnionN", &post); }
};
set_Prelop_PUnionN _set_Prelop_PUnionN;

class set_Pselect_PDisjoint {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  set_Pselect_PDisjoint() { registry.add("set.select.Disjoint", &post); }
};
set_Pselect_PDisjoint _set_Pselect_PDisjoint;

class set_Pselect_PIntersection {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  set_Pselect_PIntersection() { registry.add("set.select.Intersection", &post); }
};
set_Pselect_PIntersection _set_Pselect_PIntersection;

class set_Pselect_PUnion {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  set_Pselect_PUnion() { registry.add("set.select.Union", &post); }
};
set_Pselect_PUnion _set_Pselect_PUnion;

class set_Pselect_PUnionConst {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
    throw Exception("Registry","No suitable post function defined");
  }
  set_Pselect_PUnionConst() { registry.add("set.select.UnionConst", &post); }
};
set_Pselect_PUnionConst _set_Pselect_PUnionConst;

class set_Psequence_PSequence {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if ( _typeDefs.setvar.equal(spec[ 0]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      SetVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[(*a0)[i]->toVar()])));
      }
      sequence(home,  arg0 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Psequence_PSequence() { registry.add("set.sequence.Sequence", &post); }
};
set_Psequence_PSequence _set_Psequence_PSequence;

class set_Psequence_PUnion {
public:
  static void post(Space* home, const std::vector<VarBase*>& v, 
                   Reflection::ActorSpec& spec) {
#ifdef GECODE_HAVE_SET_VARS
    if ( _typeDefs.setvar.equal(spec[ 0]->type()) &&
         _typeDefs.setvar.equal(spec[ 1]->type()) &&
        true) {
      Reflection::ArrayArg<Reflection::Arg*>* a0 =
        spec[0]->typedArg()->toArray<Reflection::Arg*>();
      SetVarArgs arg0(a0->size());
      for (int i=a0->size(); i--;) {
        arg0[i] = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[(*a0)[i]->toVar()])));
      }
      SetVar arg1 = SetVar(Set::SetView(static_cast<Set::SetVarImp*>(v[spec[1]->typedArg()->toVar()])));
      sequentialUnion(home,  arg0 ,  arg1 );
      return;
    }
#endif
    throw Exception("Registry","No suitable post function defined");
  }
  set_Psequence_PUnion() { registry.add("set.sequence.Union", &post); }
};
set_Psequence_PUnion _set_Psequence_PUnion;

}}}
