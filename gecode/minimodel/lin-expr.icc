/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Guido Tack <tack@gecode.org>
 *
 *  Copyright:
 *     Guido Tack, 2004
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  Permission is hereby granted, free of charge, to any person obtaining
 *  a copy of this software and associated documentation files (the
 *  "Software"), to deal in the Software without restriction, including
 *  without limitation the rights to use, copy, modify, merge, publish,
 *  distribute, sublicense, and/or sell copies of the Software, and to
 *  permit persons to whom the Software is furnished to do so, subject to
 *  the following conditions:
 *
 *  The above copyright notice and this permission notice shall be
 *  included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

namespace Gecode { namespace MiniModel {

  /*
   * Operations for nodes
   *
   */
  template <class Var>
  forceinline void*
  LinExpr<Var>::Node::operator new(size_t size) {
    return Memory::malloc(size);
  }

  template <class Var>
  forceinline void
  LinExpr<Var>::Node::operator delete(void* p, size_t) {
    Memory::free(p);
  }


  template <class Var>
  forceinline void
  LinExpr<Var>::Node::increment(void) {
    ++use;
  }

  template <class Var>
  bool
  LinExpr<Var>::Node::decrement(void) {
    if (--use == 0) {
      if (left != NULL) {
        if (left->decrement())
          delete left;
        if (right->decrement())
          delete right;
      }
      return true;
    }
    return false;
  }
  
  template <class Var>
  forceinline
  LinExpr<Var>::Node::Node(int a, const Var& x) :
    use(1),
    left(NULL), right(NULL), signLeft(0), signRight(0),
    a(a), x(x) {}

  template <class Var>
  forceinline
  LinExpr<Var>::Node::Node(Node* l, int sL, Node* r, int sR) :
    use(1),
    left(l), right(r), signLeft(sL), signRight(sR) {
    left->increment();
    right->increment();
  }

  template <class Var>
  int
  LinExpr<Var>::Node::fill(Int::Linear::Term<View> t[], 
                           int i, int m) const {
    if (left != NULL) {
      return right->fill(t, left->fill(t, i, signLeft*m), signRight*m);
    } else {
      t[i].a=m*a; t[i].x=x;
      return i+1;
    }
  }



  /*
   * Operations for expressions
   *
   */

  template <class Var>
  forceinline
  LinExpr<Var>::LinExpr(void)
    : ax(NULL), n(0) {}

  template <class Var>
  inline
  LinExpr<Var>::LinExpr(const Var& x, int a, int c0) :
    ax(new Node(a, x)), n(1), c(c0), sign(1) {
  }

  template <class Var>
  inline
  LinExpr<Var>::LinExpr(const LinExpr<Var>& t1, const LinExpr<Var>& t2, 
                        int m) :
    ax(new Node(t1.ax, t1.sign, t2.ax, t2.sign*m)),
    n(t1.n+t2.n),
    c(t1.c+m*t2.c), sign(1) {}

  template <class Var>
  forceinline
  LinExpr<Var>::LinExpr(const LinExpr<Var>& t, int c0, int sign) :
    ax(t.ax), n(t.n), c(sign*t.c+c0), sign(t.sign*sign) {
    ax->increment();
  }

  template <class Var>
  forceinline
  LinExpr<Var>::LinExpr(int a, const LinExpr<Var>& t) :
    ax(t.ax), n(t.n), c(a*t.c), sign(a*t.sign) {
    ax->increment();
  }

  template <class Var>
  inline const LinExpr<Var>&
  LinExpr<Var>::operator=(const LinExpr<Var>& t) {
    if (this != &t) {
      if ((ax != NULL) && ax->decrement())
        delete ax;
      n    = t.n;
      ax   = t.ax;
      c    = t.c;
      sign = t.sign;
      ax->increment();
    }
    return *this;
  }

  template <class Var>
  forceinline
  LinExpr<Var>::~LinExpr(void) {
    if ((ax != NULL) && ax->decrement())
      delete ax;
  }

  template <class Var>
  inline void
  LinExpr<Var>::post(Space* home, IntRelType irt, 
                     IntConLevel icl, PropKind) const {
    GECODE_AUTOARRAY(Int::Linear::Term<View>, ts, n);
    (void) ax->fill(ts,0,sign);
    Int::Linear::post(home, ts, n, irt, sign*-c, icl);
  }

  template <>
  inline void
  LinExpr<IntVar>::post(Space* home, IntRelType irt, const BoolVar& b,
                        IntConLevel, PropKind) const {
    GECODE_AUTOARRAY(Int::Linear::Term<Int::IntView>, ts, n);
    (void) ax->fill(ts,0,sign);
    Int::Linear::post(home, ts, n, irt, sign*-c, b);
  }

  template <>
  inline void
  LinExpr<BoolVar>::post(Space*, IntRelType, const BoolVar&,
                         IntConLevel, PropKind) const {
    throw ReificationNotSupported("LinExpr::BoolVar");
  }

  template <>
  inline IntVar
  LinExpr<IntVar>::post(Space* home, IntConLevel icl, PropKind pk) const {
    GECODE_AUTOARRAY(Int::Linear::Term<Int::IntView>, ts, n+1);
    (void) ax->fill(ts,0,sign);
    int min, max;
    Int::Linear::estimate(&ts[0],n,sign*c,min,max);
    IntVar x(home, min, max);
    ts[n].x = x; ts[n].a = -1;
    Int::Linear::post(home, ts, n+1, IRT_EQ, sign*-c, icl, pk);
    return x;
  }

  template <>
  inline IntVar
  LinExpr<BoolVar>::post(Space* home, IntConLevel icl, PropKind pk) const {
    GECODE_AUTOARRAY(Int::Linear::Term<Int::BoolView>, ts, n);
    (void) ax->fill(ts,0,sign);
    int min, max;
    Int::Linear::estimate(&ts[0],n,sign*c,min,max);
    IntVar x(home, min, max);
    Int::Linear::post(home, ts, n, IRT_EQ, x, sign*-c, icl, pk);
    return x;
  }

}}

inline Gecode::MiniModel::LinExpr<Gecode::IntVar>
operator+(int c,
          const Gecode::MiniModel::LinExpr<Gecode::IntVar>& t) {
  return Gecode::MiniModel::LinExpr<Gecode::IntVar>(t,c,1);
}
inline Gecode::MiniModel::LinExpr<Gecode::IntVar>
operator+(const Gecode::MiniModel::LinExpr<Gecode::IntVar>& t,
          int c) {
  return Gecode::MiniModel::LinExpr<Gecode::IntVar>(t,c,1);
}
inline Gecode::MiniModel::LinExpr<Gecode::IntVar>
operator+(const Gecode::MiniModel::LinExpr<Gecode::IntVar>& t1,
          const Gecode::MiniModel::LinExpr<Gecode::IntVar>& t2) {
  return Gecode::MiniModel::LinExpr<Gecode::IntVar>(t1,t2,1);
}
inline Gecode::MiniModel::LinExpr<Gecode::IntVar>
operator-(int c,
          const Gecode::MiniModel::LinExpr<Gecode::IntVar>& t) {
  return Gecode::MiniModel::LinExpr<Gecode::IntVar>(t, c, -1);
}
inline Gecode::MiniModel::LinExpr<Gecode::IntVar>
operator-(const Gecode::MiniModel::LinExpr<Gecode::IntVar>& t,
          int c) {
  return Gecode::MiniModel::LinExpr<Gecode::IntVar>(t, -c, 1);
}
inline Gecode::MiniModel::LinExpr<Gecode::IntVar>
operator-(const Gecode::MiniModel::LinExpr<Gecode::IntVar>& t1,
          const Gecode::MiniModel::LinExpr<Gecode::IntVar>& t2) {
  return Gecode::MiniModel::LinExpr<Gecode::IntVar>(t1, t2, -1);
}
inline Gecode::MiniModel::LinExpr<Gecode::IntVar>
operator-(const Gecode::MiniModel::LinExpr<Gecode::IntVar>& t) {
  return Gecode::MiniModel::LinExpr<Gecode::IntVar>(t,0,-1);
}
inline Gecode::MiniModel::LinExpr<Gecode::IntVar>
operator*(int a, const Gecode::IntVar& x) {
  return Gecode::MiniModel::LinExpr<Gecode::IntVar>(x,a);
}
inline Gecode::MiniModel::LinExpr<Gecode::IntVar>
operator*(const Gecode::IntVar& x, int a) {
  return Gecode::MiniModel::LinExpr<Gecode::IntVar>(x,a);
}
inline Gecode::MiniModel::LinExpr<Gecode::IntVar>
operator*(const Gecode::MiniModel::LinExpr<Gecode::IntVar>& t, int a) {
  return Gecode::MiniModel::LinExpr<Gecode::IntVar>(a,t);
}
inline Gecode::MiniModel::LinExpr<Gecode::IntVar>
operator*(int a, const Gecode::MiniModel::LinExpr<Gecode::IntVar>& t) {
  return Gecode::MiniModel::LinExpr<Gecode::IntVar>(a,t);
}



inline Gecode::MiniModel::LinExpr<Gecode::BoolVar>
operator+(int c,
          const Gecode::MiniModel::LinExpr<Gecode::BoolVar>& t) {
  return Gecode::MiniModel::LinExpr<Gecode::BoolVar>(t,c,1);
}
inline Gecode::MiniModel::LinExpr<Gecode::BoolVar>
operator+(const Gecode::MiniModel::LinExpr<Gecode::BoolVar>& t,
          int c) {
  return Gecode::MiniModel::LinExpr<Gecode::BoolVar>(t,c,1);
}
inline Gecode::MiniModel::LinExpr<Gecode::BoolVar>
operator+(const Gecode::MiniModel::LinExpr<Gecode::BoolVar>& t1,
          const Gecode::MiniModel::LinExpr<Gecode::BoolVar>& t2) {
  return Gecode::MiniModel::LinExpr<Gecode::BoolVar>(t1,t2,1);
}
inline Gecode::MiniModel::LinExpr<Gecode::BoolVar>
operator-(int c,
          const Gecode::MiniModel::LinExpr<Gecode::BoolVar>& t) {
  return Gecode::MiniModel::LinExpr<Gecode::BoolVar>(t, c, -1);
}
inline Gecode::MiniModel::LinExpr<Gecode::BoolVar>
operator-(const Gecode::MiniModel::LinExpr<Gecode::BoolVar>& t,
          int c) {
  return Gecode::MiniModel::LinExpr<Gecode::BoolVar>(t, -c, 1);
}
inline Gecode::MiniModel::LinExpr<Gecode::BoolVar>
operator-(const Gecode::MiniModel::LinExpr<Gecode::BoolVar>& t1,
          const Gecode::MiniModel::LinExpr<Gecode::BoolVar>& t2) {
  return Gecode::MiniModel::LinExpr<Gecode::BoolVar>(t1, t2, -1);
}
inline Gecode::MiniModel::LinExpr<Gecode::BoolVar>
operator-(const Gecode::MiniModel::LinExpr<Gecode::BoolVar>& t) {
  return Gecode::MiniModel::LinExpr<Gecode::BoolVar>(t,0,-1);
}
inline Gecode::MiniModel::LinExpr<Gecode::BoolVar>
operator*(int a, const Gecode::BoolVar& x) {
  return Gecode::MiniModel::LinExpr<Gecode::BoolVar>(x,a);
}
inline Gecode::MiniModel::LinExpr<Gecode::BoolVar>
operator*(const Gecode::BoolVar& x, int a) {
  return Gecode::MiniModel::LinExpr<Gecode::BoolVar>(x,a);
}
inline Gecode::MiniModel::LinExpr<Gecode::BoolVar>
operator*(const Gecode::MiniModel::LinExpr<Gecode::BoolVar>& t, int a) {
  return Gecode::MiniModel::LinExpr<Gecode::BoolVar>(a,t);
}
inline Gecode::MiniModel::LinExpr<Gecode::BoolVar>
operator*(int a, const Gecode::MiniModel::LinExpr<Gecode::BoolVar>& t) {
  return Gecode::MiniModel::LinExpr<Gecode::BoolVar>(a,t);
}



namespace Gecode {

  forceinline IntVar
  post(Space*, const IntVar& x, IntConLevel, PropKind) {
    return x;
  }

  inline IntVar
  post(Space* home, int n, IntConLevel, PropKind) {
    IntVar x(home, n, n);
    return x;
  }

  template <class Var>
  inline IntVar
  post(Space* home, const MiniModel::LinExpr<Var>& e, 
       IntConLevel icl, PropKind pk) {
    if (!home->failed())
      return e.post(home,icl,pk);
    IntVar x(home,Int::Limits::min,Int::Limits::max);
    return x;
  }

}

// STATISTICS: minimodel-any
