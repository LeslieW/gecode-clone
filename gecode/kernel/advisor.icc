/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Mikael Lagerkvist <Lagerkvist@gecode.org>
 *
 *  Copyright:
 *     Mikael Lagerkvist, 2006
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

namespace Gecode {
  /**
   * \defgroup TaskAdvisor Programming advisors
   *
   * \ingroup TaskActor
   */

  //@{

  /** \brief Council of advisors
   * 
   * This is a utility class that maintains a council (that is, a 
   * collection) of advisors. The class should be used as a member 
   * of the propagator that wants to use advisors.
   *
   * Lifetime of an advisor is controlled by its council.
   *
   */
  template <class A>
  class Council {
    int siz;
    A** advisors;
  public:
    /** \brief Construct advisor collection
     *
     * \param reserve When given a number larger than 0, this allows
     * the propagator to suggest pre-allocation of a fixed number of
     * slots for advisors.
     */
    Council(Space* home, unsigned int reserve = 1);

    /** \brief Copy constructor
     * 
     */
    Council(Space* home, bool share, Council<A>& c);


    /** \brief Add a advisor to the collection.
     *
     */
    void add(Space* home, Propagator* p, A* a);

    /** \brief Dispose of this colelction
     */
    size_t dispose(Space *home);
  private:
    /** \brief Is the A* \a a an active advisor?
     *
     * \todo static? macro?
     */
    bool active(A* a) const;

    /** \brief Compact representation. 
     * 
     * Compact the storage to the end of the array. Returns memory for
     * disposed advisors.
     *
     * Returns number of used spots.
     */
    int compact(Space* home) const;
  };


  template <class A>
  Council<A>::Council(Space* home, unsigned int reserve)
    : siz(reserve > 1 ? reserve : 1), 
      advisors(static_cast<A**>(home->alloc(sizeof(A*)*siz))) {
    // Set up free-linkage in array
    for (int i = siz; i--; ) 
      advisors[i] = reinterpret_cast<A*>((i+1)%siz);
  }

  template <class A>
  Council<A>::Council(Space* home, bool share, Council<A>& c)
    : siz(c.compact(home)), 
      advisors(static_cast<A**>(home->alloc(sizeof(A*)*siz)))
  {
    for (int ci = c.siz, i = siz; ci-- && i--; ) {
      assert(active(c.advisors[ci]));
      advisors[i] = new (home) A(home,share,*c.advisors[ci]);
    }
  }

  
  template <class A>
  forceinline void
  Council<A>::add(Space *home, Propagator* p, A* a) {
    if (reinterpret_cast<ptrdiff_t>(advisors[0])>siz) {
      compact(home);
      if (reinterpret_cast<ptrdiff_t>(advisors[0])>siz) {
        // @todo better resizing strategy
        int nsiz = static_cast<int>(1.5*static_cast<double>(siz))+1;
        A** newd = static_cast<A**>(home->alloc(sizeof(A*)*nsiz));
        for (int pos = nsiz, oldpos = siz; pos-- && oldpos--; )
          newd[pos] = advisors[oldpos]; 
        for (int i = nsiz-siz-1; i--; ) {
          newd[i] = reinterpret_cast<A*>((i+1)%nsiz);
        }
        newd[nsiz-siz-1] = reinterpret_cast<A*>(0);
        home->reuse(advisors, sizeof(A*)*siz);
        advisors = newd;
        siz = nsiz;
      }
    }
    int a0 = reinterpret_cast<ptrdiff_t>(advisors[0]);
    if (a0 != 0) {
      advisors[0] = advisors[a0];
    }
    advisors[a0] = a;
  }


  template <class A>
  size_t
  Council<A>::dispose(Space *home) {
    for (int i = siz; i--; )
      if (active(advisors[i]))
        (void) advisors[i]->dispose(home);
    home->reuse(advisors, sizeof(A*)*siz);
    return sizeof(*this);
  }

  template <class A>
  forceinline bool
  Council<A>::active(A* a) const {
    return 
      (reinterpret_cast<ptrdiff_t>(a) > siz) &&
      !a->disposed();
  }

  template <class A>
  int
  Council<A>::compact(Space *home) const {
    if (siz == 0) {
      return 0;
    }

    A** left  = &(advisors[0]);
    A** right = left+siz-1;
    A** lo = left-1;
    A** hi = right+1;

    while (true) {
      while (!active(*(++lo)))
        if (lo == right) break;
      while ( active(*(--hi)))
        if (hi ==  left) break;
      if (lo >= hi) break;
      std::swap(*lo,*hi);
    }

    for (A** i = lo-1; i >= left; --i) {
      if (reinterpret_cast<ptrdiff_t>(*i) > siz) {
        assert((*i)->disposed());
        home->reuse(*i, (*i)->size());
      }
      *i = reinterpret_cast<A*>((i-left)+1);
    }
    if (!active(*hi)) {
      *hi = reinterpret_cast<A*>(0);
    }

    return (right-lo)+1;
  }
  //@}
}

// STATISTICS: kernel-other
