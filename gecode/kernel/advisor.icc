/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Mikael Lagerkvist <Lagerkvist@gecode.org>
 *
 *  Copyright:
 *     Mikael Lagerkvist, 2006
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

namespace Gecode {
  /**
   * \defgroup TaskAdvisor Programming advisors
   *
   * \ingroup TaskActor
   */

  //@{

  /** \brief Council of advisors
   * 
   * This is a utility class that maintains a council (that is, a 
   * collection) of advisors. The class should be used as a member 
   * of the propagator that wants to use advisors.
   *
   * Lifetime of an advisor is controlled by its council.
   *
   */
  class Council {
    int siz;
    Advisor** advisors;
  public:
    /** \brief Construct advisor collection
     *
     * \param reserve When given a number larger than 0, this allows
     * the propagator to suggest pre-allocation of a fixed number of
     * slots for advisors.
     */
    Council(Space* home, unsigned int reserve = 1);

    /** \brief Copy constructor
     * 
     */
    Council(Space* home, Propagator* p, bool share, Council& dac);
    /// Add advisor \a for propagator \a p to collection
    void add(Space* home, Propagator* p, Advisor* a);
    /// Dispose council
    size_t dispose(Space *home);
  private:
    /** \brief Is the Advisor* \a d an active advisor?
     *
     * \todo static? macro?
     */
    bool active(Advisor* d) const;

    /** \brief Compact representation. 
     * 
     * Compact the storage to the end of the array. Returns memory for
     * disposed advisors.
     *
     * Returns number of used spots.
     */
    int compact(Space* home, Propagator* p) const;
  };


  inline
  Council::Council(Space* home, unsigned int reserve)
    : siz(reserve > 1 ? reserve : 1), 
      advisors(static_cast<Advisor**>(home->alloc(sizeof(Advisor*)*siz))) {
    // Set up free-linkage in array
    for (int i = siz; i--; ) 
      advisors[i] = reinterpret_cast<Advisor*>((i+1)%siz);
  }

  inline
  Council::Council(Space* home, Propagator* p,
                   bool share,
                   Council& dac)
    : siz(dac.compact(home, p)), 
      advisors(static_cast<Advisor**>(home->alloc(sizeof(Advisor*)*siz)))
  {

    for (int daci = dac.siz, i = siz; daci-- && i--; ) {
      assert(active(dac.advisors[daci]));
      advisors[i] = static_cast<Advisor*>(dac.advisors[daci]->copy(home, p, share));
      dac.advisors[daci]->forward(advisors[i]);
    }
  }

  
  forceinline void
  Council::add(Space *home, Propagator* p, Advisor* d) {
    if (reinterpret_cast<ptrdiff_t>(advisors[0])>siz) {
      compact(home, p);
      if (reinterpret_cast<ptrdiff_t>(advisors[0])>siz) {
        // @todo better resizing strategy
        int nsiz = static_cast<int>(1.5*static_cast<double>(siz))+1;
        Advisor** newd = static_cast<Advisor**>(home->alloc(sizeof(Advisor*)*nsiz));
        for (int pos = nsiz, oldpos = siz; pos-- && oldpos--; )
          newd[pos] = advisors[oldpos]; 
        for (int i = nsiz-siz-1; i--; ) {
          newd[i] = reinterpret_cast<Advisor*>((i+1)%nsiz);
        }
        newd[nsiz-siz-1] = reinterpret_cast<Advisor*>(0);
        home->reuse(advisors, sizeof(Advisor*)*siz);
        advisors = newd;
        siz = nsiz;
      }
    }
    int d0 = reinterpret_cast<ptrdiff_t>(advisors[0]);
    if (d0 != 0) {
      advisors[0] = advisors[d0];
    }
    advisors[d0] = d;
  }


  inline size_t
  Council::dispose(Space *home) {
    for (int i = siz; i--; ) {
      if (active(advisors[i])) {
        (void) advisors[i]->dispose(home);
      }
    }
    home->reuse(advisors, sizeof(Advisor*)*siz);
    return sizeof(*this);
  }

  forceinline bool
  Council::active(Advisor* d) const {
    return 
      reinterpret_cast<ptrdiff_t>(d) > siz &&
      !d->disposed();
  }

  inline int
  Council::compact(Space *home, Propagator* p) const {
    if (siz == 0) {
      return 0;
    }

    Advisor** left  = &(advisors[0]);
    Advisor** right = left+siz-1;
    Advisor** lo = left-1;
    Advisor** hi = right+1;

    while (true) {
      while (!active(*(++lo)))
        if (lo == right) break;
      while ( active(*(--hi)))
        if (hi ==  left) break;
      if (lo >= hi) break;
      std::swap(*lo,*hi);
    }

    for (Advisor** i = lo-1; i >= left; --i) {
      if (reinterpret_cast<ptrdiff_t>(*i) > siz) {
        assert((*i)->disposed());
        home->reuse(*i, (*i)->size());
      }
      *i = reinterpret_cast<Advisor*>((i-left)+1);
    }
    if (!active(*hi)) {
      *hi = reinterpret_cast<Advisor*>(0);
    }

    return (right-lo)+1;
  }
  //@}
}

// STATISTICS: kernel-other
