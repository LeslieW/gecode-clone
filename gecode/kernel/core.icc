/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Christian Schulte <schulte@gecode.org>
 *     Guido Tack <tack@gecode.org>
 *     Mikael Lagerkvist <lagerkvist@gecode.org>
 *
 *  Copyright:
 *     Christian Schulte, 2002
 *     Guido Tack, 2003
 *     Mikael Lagerkvist, 2006
 *
 *  Bugfixes provided by:
 *     Alexander Samoilov <alexander_samoilov@yahoo.com>
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

#include <algorithm>

namespace Gecode {

  class Space;

  /**
   * \defgroup FuncSupportShared Support for shared objects and handles
   *
   * Shared handles provide access to reference counted objects
   * used by entities inside spaces. In particular, they support
   * updates with and without sharing. An update with sharing
   * just updates the handle. An update without sharing creates
   * a single copy per space during updating.
   *
   * \ingroup FuncSupport
   */
  
  /**
   * \brief The shared object
   *
   * Shared objects must inherit from this base class. In addition
   * to the member functions from this class, object must add a
   * copy(void) member function returning a copy of the object.
   *
   * \ingroup FuncSupportShared
   */
  class SharedObject {
    friend class Space;
    template <class Object> friend class SharedHandle;
  private:
    /// The counter used for reference counting
    unsigned int use_cnt;
    /// The next shared object collected during copying
    SharedObject* next;
    /// The forwarding pointer used for forwarding
    SharedObject* fwd;
  public:
    /// Initialize but do not regard object as being used!
    SharedObject(void);
    /// Allocate memory from heap
    static void* operator new(size_t s);
    /// Free memory allocated from heap
    static void  operator delete(void* p);
  };
  
  /**
   * \brief The shared handle
   *
   * Shared handles must inherit from this base class where
   * \a Object must be a subclass of SharedObject. Shared
   * handles support that the handle has no object it currently
   * refers to.
   *
   * \ingroup FuncSupportShared
   */
  template <class Object>
  class SharedHandle {
  private:
    /// The shared object
    Object* o;
    /// Subscribe handle to object
    void subscribe(void);
    /// Cancel subscription of handle to object
    void cancel(void);
  public:
    /// Create shared handle with no object pointing to
    SharedHandle(void);
    /// Create shared handle that points to shared object \a so
    SharedHandle(Object* so);
    /// Copy constructor maintaining reference count
    SharedHandle(const SharedHandle& sh);
    /// Assignment operator mainitaining reference count
    SharedHandle& operator=(const SharedHandle& sh);
    /// Updating during cloning
    void update(Space* home, bool share, SharedHandle& sh);
    /// Destructor that maintains reference count
    ~SharedHandle(void);
    /// Access to the shared object
    Object* object(void) const;
    /// Modify shared object
    void object(Object* n);
  };


  /**
   * \defgroup TaskVarMEPC Generic modification events and propagation conditions
   *
   * Predefined modification events must be taken into account
   * by variable types.
   * \ingroup TaskVar
   */
  //@{
  /// Type for modification events
  typedef int ModEvent;

  /// Generic modification event: failed variable
  const ModEvent ME_GEN_FAILED   = -1;
  /// Generic modification event: no modification
  const ModEvent ME_GEN_NONE     =  0;
  /// Generic modification event: variable is assigned a value
  const ModEvent ME_GEN_ASSIGNED =  1;
  /// Generic modification event: maximal modification event
  const ModEvent ME_GEN_MAX      = 15;

  /// Type for propagation conditions
  typedef int PropCond;
  /// Propagation condition for an assigned variable
  const PropCond PC_GEN_ASSIGNED = 0;
  /// Propagation conditions must be between 0 and 15
  const PropCond PC_GEN_MAX      = 15;
  //@}


  /**
   * \brief %Variable type identifiers
   *
   * Each variable type must have a unique variable type identifier. The
   * kernel supports at most eight different variable type identifiers.
   *
   * If you want to add your own variable type, you have to make sure that
   * file is created in the subdirectory vti. The names of the file defines
   * the name of the variable type identifier (for example, if the name of
   * the file is INT, it defines the identifier VTI_INT).
   * \ingroup TaskVar
   */
  enum VarTypeId {
#include "gecode/vti.icc"
    VTI_LAST,     ///< Maximal variable type identifier plus one
    VTI_NOIDX = 0 ///< Used for variables without indexing structure
  };


  /*
   * These are the classes of interest
   *
   */
  class ActorLink;
  class Actor;
  class Propagator;
  class Advisor;
  class Space;
  template <VarTypeId VTI, PropCond PC, class MED> class Variable;


  /*
   * Variables
   *
   */

  /**
   * \brief Base-class for variable implementations
   *
   * Serves as base-class that can be used without having to know any
   * template arguments.
   * \ingroup TaskVar
   */
  class VarBase {};

  /**
   * \brief Base-class for variable type processor
   *
   * Serves as base-class that can be used without having to know any
   * template arguments.
   * \ingroup TaskVar
   */
  class VarTypeProcessorBase {
  public:
    /// Process modified variables linked from \a x
    virtual void process(Space* home, VarBase* x) = 0;
    /**
     * \brief Update copied variables linked from \a x
     *
     * The argument \a sub gives the memory area where subscriptions are
     * to be stored.
     */
    virtual void update(VarBase* x, ActorLink**& sub) = 0;
    /**
      * \brief Dispose variables
      *
      * If needed for the variable type, dispose a list of
      * variables, with \a x being the first variable on the
      * list.
      */
    virtual void dispose(Space* home, VarBase* x) = 0;
    /// Destructor (not really used)
    GECODE_KERNEL_EXPORT virtual ~VarTypeProcessorBase(void);
  };

  /**
   * \brief %Variable type processor
   *
   * Base class for variable type processor for variable type index \a VTI
   * and maximum propagation condition \a PC.
   * \ingroup TaskVar
   */
  template <VarTypeId VTI, PropCond PC, class MED>
  class VarTypeProcessor : public VarTypeProcessorBase {
  public:
    /// Constructor (registers processor with kernel)
    VarTypeProcessor(void);
    /**
     * \brief Update copied variables linked from \a x
     *
     * The argument \a sub gives the memory area where subscriptions are
     * to be stored.
     */
    virtual void update(VarBase* x, ActorLink**& sub);
    /**
      * \brief Dispose variables
      *
      * If needed for the variable type, dispose a list of
      * variables, with \a x being the first variable on the list.
      */
    virtual void dispose(Space* home, VarBase* x);
  };

  /**
   * \brief Propagator modification events
   *
   * Propagator modification events are used by propagators. A
   * propagator stores a modification event for each variable type.
   * They can be accessed through a variable or a view from a given
   * propagator. They can be constructed from a given modevent by
   * a variable or view.
   * \ingroup TaskActor
   */
  typedef int PropModEvent;


  /**
   * \brief Domain change information to be supplied to advisors
   *
   * Generically, this class only manages modification events. More
   * information is of course dependent on the particular variable
   * types and is managed by subclassing.
   *
   */
  class Delta {
    template <VarTypeId VTI, PropCond PC, class MED> friend class Variable;
  private:
    ModEvent me; ///< Store modification event
  public:
    /// Return modification event
    ModEvent modevent(void) const;
  };


  /**
   * \brief Base-class for variable implementations
   *
   * Implements variable implementation for variable type identifier
   * \a VTI and largest possible propagation condition \a PC.
   * \ingroup TaskVar
   */
  template <VarTypeId VTI, PropCond PC, class MED>
  class Variable : public VarBase {
    friend class Space;
    friend class Propagator;
    friend class VarTypeProcessor<VTI,PC,MED>;
  private:
    Variable* _next; ///< Either next modified or copied variable
    union {
      /**
       * \brief Combines the number of free entries with modification events
       *
       * The least four bits are reserved for the modification events, the
       * remaining 28 bits are for the number of free entries.
       *
       */
      unsigned int free_me;
      /// Store the forwarding pointer during copying
      Variable* fwd;
    } u;
#if GECODE_USE_ADVISORS
    static const PropCond PC_SIZE = PC + 3; ///< Number of slots for index struxture
#else
    static const PropCond PC_SIZE = PC + 2; ///< Number of slots for index struxture
#endif
    ActorLink** idx[PC_SIZE]; ///< Stores where entries start (idx[pc]}

    /// Manage number of free entries internally
    unsigned int free(void) const;
    /// Manage number of free entries internally
    void free(unsigned int n);
    /// Manage number of free entries internally
    void free_inc(void);
    /// Manage number of free entries internally
    void free_dec(void);

    /**
     * \brief Update copied variable \a x
     *
     * The argument \a sub gives the memory area where subscriptions are
     * to be stored.
     */
    void update(Variable* x, ActorLink**& sub);

    /// Enter propagator or advisor to subscription array
    void enter(Space* home, ActorLink* a, PropCond pc);
    /// Resize subscription array
    void resize(Space* home);
    /// Remove propagator or advisor from subscription array
    void remove(Space* home, ActorLink* a, PropCond pc);

    /// Execute advisors during notification
    bool advise(Space* home, ModEvent me, Delta& d);

  public:
    /// Creation
    Variable(Space* home);
    /// Creation of static instances
    Variable(void);

    /// \name Dependencies
    //@{
    /** \brief Subscribe propagator \a p with propagation condition \a pc to variable
     *
     * In case \a process is false, the propagator is just subscribed but
     * not processed for execution (this must be used when creating
     * subscriptions during propagation).
     *
     * In case the variable is assigned (that is, \a assigned is 
     * true), the subscribing propagator is processed for execution.
     * Otherwise, the propagator subscribes and is processed for execution
     * with modification event \a me provided that \a pc is different
     * from \a PC_GEN_ASSIGNED.
     */
    void subscribe(Space* home, Propagator* p, PropCond pc,
                   bool assigned, ModEvent me, bool process);
    /** \brief Cancel subscription of propagator \a p with propagation condition \a pc
     *
     * If the variables is assigned, \a assigned must be true.
     *
     */
    void cancel(Space* home, Propagator* p, PropCond pc,
                bool assigned);
    /** \brief Subscribe advisor \a a to variable
     *
     * The advisor \a a is only subscribed if \a assigned is false.
     *
     */
    void subscribe(Space* home, Advisor* a, bool assigned);
    /** \brief Cancel subscription of advisor \a a
     *
     * If the variable is assigned, \a assigned must be true.
     *
     */
    void cancel(Space* home, Advisor* p, bool assigned);
    /// Return degree (number of subscribed propagators and advisors)
    unsigned int degree(void) const;
    /**
     * \brief Notify that variable implementation has been modified with modification event \a me and domain change \a d
     *
     * Returns false if notification has failed.
     */
    bool notify(Space* home, ModEvent me, Delta& d);
    /**
     * \brief Notify that variable implementation has been assigned with domain change \a d
     *
     * This routine can only be used, if the variable implementation supports
     * a single modification event.
     *
     * Returns false if notification has failed.
     */
    bool notify(Space* home, Delta& d);
    //@}

    /// \name Processing modified variables
    //@{
    /// Check whether variable has been modified during propagation
    bool modified(void) const;
    //@}

    /// \name Cloning variables
    //@{
    /// Constructor for cloning
    Variable(Space* home, bool share, Variable& x);
    /// Is variable already copied
    bool copied(void) const;
    /// Use forward pointer if variable already copied
    Variable* forward(void) const;
    //@}

    /// \name Variable-dependent propagator support
    //@{
    /// Schedule propagator \a p with modification event \a me
    static void schedule(Space* home, Propagator* p, ModEvent me);
    /// Return modification event for variable from propagator \a p
    static ModEvent pme(const Propagator* p);
    /// Translate modification event \a me into propagator modification event
    static PropModEvent pme(ModEvent me);
    /// Combine modifications events \a me1 and \a me2
    static ModEvent combine(ModEvent me1, ModEvent me2);
    //@}

    /// \name Processing modified variables
    //@{
    /// Return next modified variable and reset (during processing)
    Variable* next(void);
    /// Return current modification event of variable
    ModEvent modevent(void) const;
    /// Set modification event to \a me
    void modevent(ModEvent me);
    /// Process subscribed propagators
    void process(Space* home, PropCond pc1, PropCond pc2, ModEvent me);
    /// Process subscribed propagators for assigned variable
    void process(Space* home);
    //@}

  public:
    /// \name Memory management
    //@{
    /// Allocate memory from space
    static void* operator new(size_t,Space*);
    /// Return memory to space
    static void  operator delete(void*,Space*);
    /// Needed for exceptions
    static void  operator delete(void*);
    //@}
  };




  /**
   * \defgroup TaskActorStatus Status of constraint propagation and branching commit
   * Note that the enum values starting with a double underscore should not
   * be used directly. Instead, use the provided functions with the same
   * name without leading underscores.
   *
   * \ingroup TaskActor
   */
  enum ExecStatus {
    __ES_SUBSUMED      = -2, ///< Internal: propagator is subsumed, do not use
    ES_FAILED          = -1, ///< Execution has resulted in failure
    ES_NOFIX           =  0, ///< Propagation has not computed fixpoint
    ES_OK              =  0, ///< Execution is okay
    ES_FIX             =  1, ///< Propagation has computed fixpoint
    __ES_FIX_PARTIAL   =  2, ///< Internal: propagator has computed partial fixpoint, do not use
    __ES_NOFIX_PARTIAL =  3  ///< Internal: propagator has computed no partial fixpoint, do not use
  };

  /**
   * \brief Classification of propagation cost
   * \ingroup TaskActor
   */
  enum PropCost {
    PC_CRAZY_LO     = 0, ///< Exponential complexity, cheap
    PC_CRAZY_HI     = 0, ///< Exponential complexity, expensive
    PC_CUBIC_LO     = 1, ///< Cubic complexity, cheap
    PC_CUBIC_HI     = 1, ///< Cubic complexity, expensive
    PC_QUADRATIC_LO = 2, ///< Quadratic complexity, cheap
    PC_QUADRATIC_HI = 2, ///< Quadratic complexity, expensive
    PC_LINEAR_HI    = 3, ///< Linear complexity, expensive
    PC_LINEAR_LO    = 4, ///< Linear complexity, cheap
    PC_TERNARY_HI   = 5, ///< Three variables, expensive
    PC_BINARY_HI    = 6, ///< Two variables, expensive
    PC_TERNARY_LO   = 6, ///< Three variables, cheap
    PC_BINARY_LO    = 7, ///< Two variables, cheap
    PC_UNARY_LO     = 7, ///< Only single variable, cheap
    PC_UNARY_HI     = 7, ///< Only single variable, expensive
    PC_MAX          = 7  ///< Maximal cost value
  };

  /**
   * \brief Double-linked list for actors
   *
   * Used to maintain which actors belong to a space and also
   * (for propagators) to organize actors in the queue of
   * waiting propagators.
   */
  class ActorLink {
    friend class Actor;
    friend class Propagator;
    friend class Advisor;
    friend class Branching;
    friend class Space;
    template <VarTypeId VTI, PropCond PC, class MED> friend class Variable;
  private:
    ActorLink* _next; ActorLink* _prev;
  public:
    //@{
    /// Routines for double-linked list
    ActorLink* prev(void) const; void prev(ActorLink*);
    ActorLink* next(void) const; void next(ActorLink*);
    //@}

    /// Initialize links (self-linked)
    void init(void);
    /// Remove from predecessor and successor
    void unlink(void);
    /// Insert \a al directly after this
    void head(ActorLink* al);
    /// Insert \a al directly before this
    void tail(ActorLink* al);
  };


  /**
   * \brief Base-class for both propagators and branchings
   * \ingroup TaskActor
   */
  class Actor : private ActorLink {
    friend class Space;
    friend class Propagator;
    friend class Advisor;
    friend class Branching;
    template <VarTypeId VTI, PropCond PC, class MED> friend class Variable;
  public:
    /// Create copy
    virtual Actor* copy(Space*,bool) = 0;

    /// \name Memory management
    //@{
    /// Report size occupied by additionally datastructures
    GECODE_KERNEL_EXPORT 
    virtual size_t allocated(void) const;
    /// Delete actor and return its size
    GECODE_KERNEL_EXPORT
    virtual size_t dispose(Space* home);
    /// Register actor for forced dispose when \a home is deleted
    void force(Space* home);
    /// Deregister actor for forced dispose
    void unforce(Space* home);
    /// Allocate memory from space
    static void* operator new(size_t s, Space* home);
    /// No-op for exceptions
    static void  operator delete(void* p, Space* home);
  private:
#ifndef __GNUC__
    /// Not used (uses dispose instead)
    static void  operator delete(void* p, size_t s);
#endif
    /// Not used
    static void* operator new(size_t s);
    //@}
#ifdef __GNUC__
  public:
    /// To avoid warnings from GCC
    GECODE_KERNEL_EXPORT virtual ~Actor(void);
    /// Not used (uses dispose instead)
    static void  operator delete(void* p, size_t s);
#endif
  };



  /**
   * \brief %Propagator \a p is subsumed
   *
   * The size of the propagator is \a s.
   *
   * Note that the propagator must be subsumed and also disposed. So
   * in general, there should be code such as 
   * \code return ES_SUBSUMED(this,dispose(home)) \endcode.
   * 
   * However, in case the propagator has nothing to dispose (all its
   * views are assigned and no external resources) it is sufficient
   * to do 
   * \code return ES_SUBSUMED(this,sizeof(*this)) \endcode.
   *
   * \warning Has a side-effect on the propagator. Overwrites
   *          the propagator modification events of a propagator.
   *          Use only directly with returning from propagation.
   * \ingroup TaskActorStatus
   */
  ExecStatus ES_SUBSUMED(Propagator* p, size_t s);
  /**
   * \brief %Propagator \a p is subsumed
   *
   * First disposes the propagator and then returns subsumtion.
   *
   * \warning Has a side-effect on the propagator. Overwrites
   *          the propagator modification events of a propagator.
   *          Use only directly with returning from propagation.
   * \ingroup TaskActorStatus
   */
  ExecStatus ES_SUBSUMED(Propagator* p, Space* home);
  /**
   * \brief %Propagator \a p has computed partial fixpoint
   *
   * %Set propagator modification events after processing of
   * variables to \a pme.
   * \warning Has a side-effect on the propagator. Overwrites
   *          the propagator modification events of a propagator.
   *          Use only directly with returning from propagation.
   * \ingroup TaskActorStatus
   */
  ExecStatus ES_FIX_PARTIAL(Propagator* p, PropModEvent pme);
  /**
   * \brief %Propagator \a p has not computed partial fixpoint
   *
   * %Set propagator modification events before processing of
   * variables to \a pme.
   * \warning Has a side-effect on the propagator. Overwrites
   *          the propagator modification events of a propagator.
   *          Use only directly with returning from propagation.
   * \ingroup TaskActorStatus
   */
  ExecStatus ES_NOFIX_PARTIAL(Propagator* p, PropModEvent pme);



  /**
   * \brief Base-class for propagators
   * \ingroup TaskActor
   */
  class Propagator : public Actor {
    friend class Space;
    template <VarTypeId VTI, PropCond PC, class MED> friend class Variable;
    friend ExecStatus ES_SUBSUMED(Propagator*, size_t);
    friend ExecStatus ES_SUBSUMED(Propagator*, Space*);
    friend ExecStatus ES_FIX_PARTIAL(Propagator*, PropModEvent);
    friend ExecStatus ES_NOFIX_PARTIAL(Propagator*, PropModEvent);
    friend class Advisor;
  private:
    union {
      PropModEvent pme;
      size_t       size;
    } u;
  protected:
    /// Constructor for creation
    Propagator(Space* home);
    /// Constructor for cloning \a p
    Propagator(Space* home, bool share, Propagator& p);

  public:
    /// \name Propagation
    //@{
    /**
     * \brief Propagation function
     *
     * The propagation function must return an execution status as
     * follows:
     *  - ES_FAILED: the propagator has detected failure
     *  - ES_NOFIX: the propagator has done propagation
     *  - ES_FIX: the propgator has done propagation and has computed
     *    a fixpoint. That is, running the propagator immediately
     *    again will do nothing.
     *
     * Apart from the above values, a propagator can return
     * the result from calling one of the functions 
     *  - ES_SUBSUMED: the propagator is subsumed and has been already
     *    deleted.
     *  - ES_NOFIX_PARTIAL: the propagator has consumed some of its
     *    propagation events.
     *  - ES_FIX_PARTIAL: the propagator has consumed some of its
     *    propagation events and with respect to these events is
     *    at fixpoint
     * For more details, see the individual functions.
     *
     */
    virtual ExecStatus propagate(Space* home) = 0;
    /// Cost function
    virtual PropCost cost(void) const  = 0;
    //@}
  };


  /** \brief Type-independent base-class for council of advisors
   * 
   * This is a utility class that maintains a council (that is, a 
   * collection) of advisors. The class should be used as a member 
   * of the propagator that wants to use advisors.
   *
   * Lifetime of an advisor is controlled by its council.
   *
   */
  class CouncilBase {
    friend class Advisor;
  protected:
    int       siz;      ///< Size of array for advisors
    Advisor** advisors; ///< Array of advisors
    /// Resize advisor array
    GECODE_KERNEL_EXPORT
    void resize(Space* home);
    /// Add advisor \a a to council
    void add(Space* home, Advisor* a);
    /// Test whether advisor \a a is active
    bool active(Advisor* a) const;
    /// Compact representation
    GECODE_KERNEL_EXPORT
    int compact(Space* home) const;
  public:
    /** \brief Construct advisor council
     *
     * \param reserve When given a number larger than 0, this allows
     * the propagator to suggest pre-allocation of a fixed number of
     * slots for advisors.
     */
    CouncilBase(Space* home, unsigned int reserve = 1);
    /// Copy constructor
    CouncilBase(Space* home, bool share, CouncilBase& c);
  };


  /** \brief Council of advisors
   * 
   * This is a utility class that maintains a council (that is, a 
   * collection) of advisors. The class should be used as a member 
   * of the propagator that wants to use advisors.
   *
   * Lifetime of an advisor is controlled by its council.
   *
   * \ingroup TaskActor
   */
  template <class A>
  class Council : public CouncilBase {
    friend class Advisor;
  public:
    /// Construct advisor council
    Council(Space* home, unsigned int reserve = 1);
    /// Copy constructor
    Council(Space* home, bool share, Council<A>& c);
    /// Dispose council
    size_t dispose(Space* home);
  };


  /**
   * \brief Base-class for advisors
   *
   * Advisors are subclassed for each kind of variable that they
   * support. The subclasses define the kinds of advise-methods
   * that might be called.
   *
   * \ingroup TaskActor
   */
  class Advisor : private ActorLink {
    friend ExecStatus ES_SUBSUMED(Advisor*, size_t);
    friend ExecStatus ES_SUBSUMED(Advisor*, Space*);
    template <VarTypeId VTI, PropCond PC, class MED> friend class Variable;
    friend class CouncilBase;
    template <class A> friend class Council;
  private:
    /// Set disposed flag and size
    void disposed(size_t size);
    /// Is the advisor disposed?
    bool disposed(void) const;
    /// Get size of disposed advisor
    size_t size(void) const;
  public:
    /// Constructor for creation
    Advisor(Space* home, Propagator* p, CouncilBase& c);
    /// Copying constructor
    Advisor(Space* home, bool share, Advisor& a);

    /// Return the advisor's propagator
    Propagator* propagator(void) const; 
    /**
     * \brief Advise function
     *
     * The advise function must return an execution status as
     * follows:
     *  - ES_FAILED: the advisor has detected failure
     *  - ES_NOFIX: the advisor's propagator does not need to be run
     *  - ES_FIX: the advisor's propagator must be run
     *
     * Apart from the above values, an advisor can return
     * the result from calling the function
     *  - ES_SUBSUMED: the advisor is subsumed
     * For more details, see the function documentation.
     *
     * The delta \a d describes how the variable has been changed
     * by an operation on the advisor's variable. Typically,
     * the delta information can only be utilized by either 
     * static or member functions of views as the actual delta 
     * information is both domain and view dependent.
     *
     */
    virtual ExecStatus advise(Space* home, const Delta& d) = 0;

    /// \name Memory management
    //@{
    virtual size_t dispose(Space* home);
    /// Allocate memory from space
    static void* operator new(size_t s, Space* home);
    /// No-op for exceptions
    static void  operator delete(void* p, Space* home);
    //@}
  private:
#ifndef __GNUC__
    /// Not used (uses dispose instead)
    static void  operator delete(void* p, size_t s);
#endif
    /// Not used
    static void* operator new(size_t s);
#ifdef __GNUC__
  public:
    /// To avoid warnings from GCC
    virtual ~Advisor(void) {}
    /// Not used (uses dispose instead)
    static void  operator delete(void* p, size_t s);
#endif
  };

  /**
   * \brief %Advisor \a p is subsumed
   *
   * The size of the advisor is \a s.
   *
   * Note that the advisor must be subsumed and also disposed. So
   * in general, there should be code such as 
   * \code return ES_SUBSUMED(this,dispose(home)) \endcode.
   * 
   * However, in case the advisor has nothing to dispose it is sufficient
   * to do 
   * \code return ES_SUBSUMED(this,sizeof(*this)) \endcode.
   *
   * \warning Has a side-effect on the advisor. Use only directly with
   *          returning from the advise member function.
   * \ingroup TaskActorStatus
   */
  ExecStatus ES_SUBSUMED(Advisor* a, size_t s);
  /**
   * \brief %Advisor \a p is subsumed
   *
   * First disposes the advisor and then returns subsumtion.
   *
   * \warning Has a side-effect on the advisor. Use only directly with
   *          returning from propagation.
   * \ingroup TaskActorStatus
   */
  ExecStatus ES_SUBSUMED(Advisor* a, Space* home);



  /*
   * Branchings
   *
   */

  class Branching;

  /**
   * \brief Branch description for batch recomputation
   *
   * Must be refined by inheritance such that the information stored
   * inside a branching description is sufficient to redo a tell
   * performed by a particular branching.
   *
   * \ingroup TaskActor
   */
  class BranchingDesc {
    friend class Space;
  private:
    const unsigned int id;  ///< Identity to match creating branching
    const unsigned int alt; ///< Number of alternatives
  protected:
    /// Initialize for particular branching \a b and alternatives \a a
    BranchingDesc(const Branching* b, const unsigned int a);
  public:
    /// Destructor
    GECODE_KERNEL_EXPORT virtual ~BranchingDesc(void);

    /// Return number of alternatives
    unsigned int alternatives(void) const;

    /// Report size occupied by branching description
    virtual size_t size(void) const = 0;
    /// Allocate memory from heap
    static void* operator new(size_t);
    /// Return memory to heap
    static void  operator delete(void*);
  };

  /**
   * \brief Base-class for branchings
   *
   * Note that branchings cannot be created inside a propagator
   * (no idea why one would like to that anyway). If you do that
   * the system will explode in a truly interesting way.
   *
   * \ingroup TaskActor
   */
  class Branching : public Actor {
    friend class Space;
    friend class BranchingDesc;
  private:
    unsigned int id; ///< Unique identity (to match to branching descriptions)
  protected:
    /// Constructor for creation
    Branching(Space* home);
    /// Constructor for cloning \a b
    Branching(Space* home, bool share, Branching& b);

  public:
    /// \name Branching
    //@{
    /**
     * \brief Check status of branching, return true if alternatives left
     *
     * This method is called when Space::status is called, it determines
     * whether to continue branching with this branching or move on to
     * the (possibly) next branching.
     *
     */
    virtual bool status(const Space* home) const = 0;
    /**
     * \brief Return branching description
     *
     * Note that this method can rely on the fact that it is called
     * immediately after a previous call to status. Hence, it is safe
     * to remember computation from status in order to speed up
     * description.
     *
     */
    virtual const BranchingDesc* description(const Space* home) const = 0;
    /**
     * \brief Commit for branching description \a d and alternative \a a
     *
     * The current branching in the space \a home performs a commit from
     * the information provided by the branching description \a d
     * and the alternative \a a.
     */
    virtual ExecStatus commit(Space* home, const BranchingDesc* d,
                              unsigned int a) = 0;
    //@}
  };



  /** 
   * \brief %Space status
   * \ingroup TaskSearch
   */
  enum SpaceStatus {
    SS_FAILED, ///< %Space is failed
    SS_SOLVED, ///< %Space is solved (no branching left)
    SS_BRANCH  ///< %Space must be branched (at least one branching left)
  };

  /**
   * \brief Computation spaces
   */
  class Space {
    friend class Actor;
    friend class Propagator;
    friend class Branching;
    friend class Advisor;
    template <VarTypeId VTI, PropCond PC, class MED> friend class Variable;
    template <VarTypeId VTI, PropCond PC, class MED> friend class VarTypeProcessor;
    template <class Object> friend class SharedHandle;
  private:
    MemoryManager   mm; ///< Performs memory management for space

    /// First actor for forced disposal
    Actor** d_fst;
    /// Current actor for forced disposal
    Actor** d_cur;
    /// Last actor for forced disposal
    Actor** d_lst;
    /// Resize disposal array
    GECODE_KERNEL_EXPORT void d_resize(void);

    /**
     * \name Processing variables
     */
    //@{
    /// Registered variable type processors
    GECODE_KERNEL_EXPORT
    static VarTypeProcessorBase* vtp[VTI_LAST];
    /// Information for handling variables
    class VarInfo {
    public:
      /// Modified or copied variables (entry points)
      VarBase* entry;
      /// Variables that require disposal
      VarBase* dispose;
    };
    /// Information for handling variables
    VarInfo vars[VTI_LAST];
    /// To keep variables during copying without index structure
    VarBase* vars_noidx;
    /// Process all modified variables by delegating to registered processors
    void process(void);
    //@}

    /**
     * \name Pool of waiting propagators
     */
    //@{
    /// Waiting propagators according to cost
    ActorLink pool[PC_MAX+1];
    /// Next cost level to check
    int pool_next;
    /// Put propagator \a p to pool
    void pool_put(Propagator* p);
    /// Get propagator \a p from pool
    bool pool_get(Propagator*& p);
    //@}

    /**
     * \brief Doubly linked list of all actors
     *
     * Propagators are stored at the beginning, branchings (if any) at
     * the end.
     */
    ActorLink a_actors;
    /**
     * \brief Points to the first branching to be used for status
     *
     * If equal to &a_actors, no branching does exist.
     *
     * If it is NULL, the space is failed.
     *
     */
    Branching* b_status;
    /**
     * \brief Points to the first branching to be used for commit
     *
     * Note that \a b_commit can point to an earlier branching
     * than \a b_status. This reflects the fact that the earlier
     * branching is already done (that is, status on that branching
     * returns false) but there might be still branching descriptions
     * referring to the earlier branching.
     *
     * If equal to &a_actors, no branching does exist.
     *
     */
    Branching* b_commit;
    /// Id of next branching to be created
    unsigned int branch_id;

    /// Number of subscriptions
    unsigned int n_sub;

    /// Linked list of shared objects
    SharedObject* shared;

    /// Used for default arguments
    GECODE_KERNEL_EXPORT static unsigned long int unused_uli;

    /// Perform propagation, return number of propagation steps
    GECODE_KERNEL_EXPORT unsigned long int propagate(void);

  public:
    /**
     * \name Processing propagators
     */
    //@{
    /// Process propagator \a p with modification event \a me
    template <VarTypeId VTI, class MED>
    void process(Propagator* p, ModEvent me);
    /// Process propagator \a p with modification event ME_GEN_ASSIGNED
    template <VarTypeId VTI, class MED>
    void process(Propagator* p);
    //@}


  public:
    /**
     * \brief Default constructor
     * \ingroup TaskIntScript
     */
    GECODE_KERNEL_EXPORT Space(void);
    /**
     * \brief Destructor
     * \ingroup TaskIntScript
     */
    GECODE_KERNEL_EXPORT virtual ~Space(void);
    /**
     * \brief Constructor for cloning
     *
     * Must copy and update all data structures (such as variables
     * and variable arrays) required by the subclass of Space.
     *
     * If \a share is true, share all data structures among copies.
     * Otherwise, make independent copies.
     * \ingroup TaskIntScript
     */
    GECODE_KERNEL_EXPORT Space(bool share, Space& s);
    /**
     * \brief Copying member function
     *
     * Must create a new object using the constructor for cloning.
     * \ingroup TaskIntScript
     */
    virtual Space* copy(bool share) = 0;
    /**
     * \brief Allocate memory from heap for new space
     * \ingroup TaskIntScript
     */
    static void* operator new(size_t);
    /**
     * \brief Free memory allocated from heap
     * \ingroup TaskIntScript
     */
    static void  operator delete(void*);




    /*
     * Member functions for search engines
     *
     */

    /**
     * \brief Query space status
     *
     * Propagates the space until fixpoint or failure and
     * increments \a pn by the number of propagator executions.
     *  - if the space is failed, SpaceStatus::SS_FAILED is returned.
     *  - if the space is not failed but the space has no branching left,
     *    SpaceStatus::SS_SOLVED is returned.
     *  - otherwise, SpaceStatus::SS_BRANCH is returned.
     * \ingroup TaskSearch
     */
    SpaceStatus status(unsigned long int& pn=unused_uli);

    /**
     * \brief Create new branching description for current branching
     *
     * This member function can only be called after the member function
     * Space::status on the same space has been called and in between
     * no non-const member function has been called on this space.
     *
     * Note that the above invariant obly pertains to calls of member
     * functions of the same space. If the invariant is violated, the
     * system is likely to crash (hopefully it does). In particular, if
     * applied to a space with no current branching, the system will
     * crash.
     *
     * \ingroup TaskSearch
     */
    const BranchingDesc* description(void) const;

    /**
     * \brief Clone space
     *
     * Propagates the space until fixpoint and increments \a pn by the
     * number of propagator executions. If propagation results in
     * a failed space, an exception of type SpaceFailed is thrown.
     *
     * Otherwise, a clone of the space is returned. If \a shared is true,
     * sharable datastructures are shared among the clone and the original
     * space. If \a shared is false, independent copies of the shared
     * datastructures must be created. This means that a clone with no
     * sharing can be used in a different thread without any interaction
     * with the original space.
     *
     * \ingroup TaskSearch
     */
    GECODE_KERNEL_EXPORT
    Space* clone(bool share=true, unsigned long int& pn=unused_uli);

    /**
     * \brief Commit branching description \a d and for alternative \a a
     *
     * The current branching in the space performs a commit from
     * the information provided by the branching description \a d
     * and the alternative \a a.
     *
     * Note that no propagation is perfomed (to support batch
     * recomputation), in order to perform propagation the member
     * function status must be used.
     *
     * Committing with branching descriptions must be carried
     * out in the same order as the branch descriptions have been
     * obtained by the member function Space::description().
     *
     * It is perfectly okay to add constraints interleaved with
     * branching descriptions (provided they are in the right order).
     * However, if propagation is performed by calling the member
     * function status and then new branching descriptions are
     * computed, these branching descriptions are different.
     *
     * Committing throws the following exceptions:
     *  - SpaceNoBranching, if the space has no current branching (it is
     *    already solved).
     *  - SpaceIllegalAlternative, if \a a is not smaller than the number
     *    of alternatives supported by the branching description \a d.
     *
     * \ingroup TaskSearch
     */
    GECODE_KERNEL_EXPORT
    void commit(const BranchingDesc* d, unsigned int a);

    /*
     * Status checking and failing outside actors
     *
     */

    /**
     * \brief Fail space
     *
     * This is useful for failing outside of actors. Never use inside
     * a propagate or commit member function. The system will crash!
     * \ingroup TaskActor
     */
    void fail(void);
    /**
     * \brief Check whether space is failed
     *
     * Note that this does not perform propagation. This is useful
     * for posting actors: only if a space is not yet failed, new
     * actors are allowed to be created.
     * \ingroup TaskActor
     */
    bool failed(void) const;
    /**
     * \brief Return number of propagators
     *
     * Note that this function takes linear time in the number of
     * propagators. The number is only accurate when the space is
     * stable (that is, at fixpoint and all propagation is done).
     *
     * Throws an exception of type SpaceFailed, if the space is failed.
     */
    GECODE_KERNEL_EXPORT
    unsigned int propagators(void) const;
    /**
     * \brief Return number of branchings
     *
     * Note that this function takes linear time in the number of branchings.
     *
     * Throws an exception of type SpaceFailed, if the space is failed.
     */
    GECODE_KERNEL_EXPORT
    unsigned int branchings(void) const;

    /**
     * \defgroup FuncMemSpace Space-memory management
     * \ingroup FuncMem
     */
    //@{
    /// Allocate memory on space heap
    void* alloc(size_t);
    /// Attempt to reuse memory previously allocated with alloc
    void  reuse(void*,size_t);
    /// Allocate from freelist-managed memory
    template <size_t> void* fl_alloc(void);
    /**
     * \brief Return freelist-managed memory to freelist
     *
     * The first list element to be retuned is \a f, the last is \a l.
     */
    template <size_t> void  fl_dispose(FreeList* f, FreeList* l);
    /**
     * \brief Return how much heap memory is allocated
     *
     * Note that is includes both the memory allocated for the space heap
     * as well as additional memory allocated by actors.
     */
    GECODE_KERNEL_EXPORT 
    size_t allocated(void) const;
    /// Return list of variables that need deletion
    template <VarTypeId VTI> VarBase* varsDisposeList(void);
    /// Set list of variables that need deletion
    template <VarTypeId VTI> void varsDisposeList(VarBase* v);
    //@}
  };




  /***
   *** MEMORY MANAGEMENT
   ***
   ***/

  /*
   * Heap allocated: Space, BranchDesc
   *
   */

  forceinline void*
  Space::operator new(size_t s) {
    return Memory::malloc(s);
  }
  forceinline void
  Space::operator delete(void* p) {
    Memory::free(p);
  }

  forceinline void
  BranchingDesc::operator delete(void* p) {
    Memory::free(p);
  }
  forceinline void*
  BranchingDesc::operator new(size_t s) {
    return Memory::malloc(s);
  }

  /*
   * Space allocation: general space heaps and free lists
   *
   */

  forceinline void*
  Space::alloc(size_t s) {
    return mm.alloc(s);
  }
  forceinline void
  Space::reuse(void* p, size_t s) {
    return mm.reuse(p,s);
  }

  template <size_t s>
  forceinline void*
  Space::fl_alloc(void) {
    return mm.template fl_alloc<s>();
  }
  template <size_t s>
  forceinline void
  Space::fl_dispose(FreeList* f, FreeList* l) {
    mm.template fl_dispose<s>(f,l);
  }

  template <VarTypeId VTI>
  forceinline VarBase*
  Space::varsDisposeList(void) {
    return vars[VTI].dispose;
  }

  template <VarTypeId VTI>
  forceinline void
  Space::varsDisposeList(VarBase* v) {
    vars[VTI].dispose=v;
  }

  /*
   * Space allocated entities: Actors, Variables, and Advisors
   *
   */

  forceinline void
  Actor::operator delete(void*, size_t) {}
  forceinline void
  Actor::operator delete(void*,Space*) {}
  forceinline void*
  Actor::operator new(size_t s, Space* home) {
    return home->alloc(s);
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline void
  Variable<VTI,PC,MED>::operator delete(void*) {}
  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline void
  Variable<VTI,PC,MED>::operator delete(void*, Space*) {}
  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline void*
  Variable<VTI,PC,MED>::operator new(size_t s, Space* home) {
    return home->alloc(s);
  }

  forceinline void
  Advisor::operator delete(void*, size_t) {}
  forceinline void
  Advisor::operator delete(void*,Space*) {}
  forceinline void*
  Advisor::operator new(size_t s, Space* home) {
    return home->alloc(s);
  }


  /*
   * Shared objects and handles
   *
   */
  forceinline
  SharedObject::SharedObject(void) 
    : use_cnt(0), fwd(NULL) {}
  forceinline void* 
  SharedObject::operator new(size_t s) {
    return Memory::malloc(s);
  }
  forceinline void
  SharedObject::operator delete(void* p) {
    Memory::free(p);
  }

  template<class Object>
  forceinline void 
  SharedHandle<Object>::subscribe(void) {
    if (o != NULL) o->use_cnt++;
  }
  template<class Object>
  forceinline void 
  SharedHandle<Object>::cancel(void) {
    if ((o != NULL) && (--o->use_cnt == 0))
      delete o;
    o = NULL;
  }
  template<class Object>
  forceinline 
  SharedHandle<Object>::SharedHandle(void) : o(NULL) {}
  template<class Object>
  forceinline 
  SharedHandle<Object>::SharedHandle(Object* so) : o(so) {
    subscribe();
  }
  template<class Object>
  forceinline 
  SharedHandle<Object>::SharedHandle(const SharedHandle& sh) : o(sh.o) {
    subscribe();
  }
  template<class Object>
  forceinline SharedHandle<Object>& 
  SharedHandle<Object>::operator=(const SharedHandle& sh) {
    if (&sh != this) {
      cancel(); o = sh.o; subscribe();
    }
    return *this;
  }
  template<class Object>
  forceinline void 
  SharedHandle<Object>::update(Space* home, bool share, SharedHandle& sh) {
    if (sh.o == NULL) {
      o = NULL;
    } else if (share) {
      o = sh.o; subscribe();
    } else if (sh.o->fwd != NULL) {
      o = static_cast<Object*>(sh.o->fwd); subscribe();
    } else {
      o = sh.o->copy(); 
      sh.o->fwd = o;
      sh.o->next = home->shared; 
      home->shared = sh.o;
      subscribe();
    }
  }
  template<class Object>
  forceinline 
  SharedHandle<Object>::~SharedHandle(void) {
    cancel();
  }
  template<class Object>
  forceinline Object* 
  SharedHandle<Object>::object(void) const {
    return o;
  }
  template<class Object>
  forceinline void 
  SharedHandle<Object>::object(Object* n) {
    if (n != o) {
      cancel(); o=n; subscribe();
    }
  }



  /*
   * ActorLinks as common superclass for propagators and branchings
   *
   */

  forceinline ActorLink*
  ActorLink::prev(void) const { return _prev; }
  forceinline ActorLink*
  ActorLink::next(void) const { return _next; }
  forceinline void
  ActorLink::prev(ActorLink* al) { _prev = al; }
  forceinline void
  ActorLink::next(ActorLink* al) { _next = al; }

  forceinline void
  ActorLink::unlink(void) {
    ActorLink* p = _prev; ActorLink* n = _next;
    p->_next = n; n->_prev = p;
  }
  forceinline void
  ActorLink::init(void) {
    _next = this; _prev =this;
  }
  forceinline void
  ActorLink::head(ActorLink* a) {
    // Inserts al at head of link-chain (that is, after this)
    ActorLink* n = _next;
    this->_next = a; a->_prev = this;
    a->_next = n; n->_prev = a;
  }
  forceinline void
  ActorLink::tail(ActorLink* a) {
    // Inserts al at tail of link-chain (that is, before this)
    ActorLink* p = _prev;
    a->_next = this; this->_prev = a;
    p->_next = a; a->_prev = p;
  }

  forceinline size_t
  Actor::dispose(Space*) {
    return sizeof(*this);
  }


  /*
   * Spaces
   *
   */

  forceinline const BranchingDesc*
  Space::description(void) const {
    return b_status->description(this);
  }

  forceinline bool
  Space::failed(void) const {
    return b_status == NULL;
  }

  /*
   * Main control for propagation and branching
   *  - a space only propagates and branches if requested by
   *    either a status, commit, or clone operation
   *  - for all of the operations the number of propagation
   *    steps performed is returned in the last (optional)
   *    reference argument
   *
   */
  forceinline SpaceStatus
  Space::status(unsigned long int& pn) {
    // Perform propagation and do not continue when failed
    pn += propagate();
    if (failed())
      return SS_FAILED;
    /*
     * Find the next branching that has still alternatives left
     *
     * It is important to note that branchings reporting to have no more
     * alternatives left can not be deleted. They can not be deleted
     * as there might be branching descriptions to be used in commit
     * that refer to one of these branchings.
     *
     * A branching reporting that no more alternatives exist will eventually
     * be deleted in commit. It will be deleted if the first branching
     * description is used in commit that does not refer to this branching.
     * As we insist that branching descriptions are used in order of
     * creation, all further branching descriptions cannot refer to this
     * branching.
     *
     */
    while (b_status != &a_actors) {
      if (b_status->status(this))
        return SS_BRANCH;
      b_status = static_cast<Branching*>(b_status->next());
    }
    // No branching with alternatives left, space is solved
    return SS_SOLVED;
  }


  /*
   * Advisors
   *
   */

  forceinline void
  CouncilBase::add(Space* home, Advisor* a) {
    if (reinterpret_cast<ptrdiff_t>(advisors[0])>siz)
      resize(home);
    int a0 = reinterpret_cast<ptrdiff_t>(advisors[0]);
    if (a0 != 0) {
      advisors[0] = advisors[a0];
    }
    advisors[a0] = a;
  }


  /*
   * Advisor class members
   *
   */

  forceinline 
  Advisor::Advisor(Space* home, Propagator* p, CouncilBase& c) {
    ActorLink::prev(NULL);
    ActorLink::next(p);
    c.add(home,this);
  }
  forceinline 
  Advisor::Advisor(Space* home, bool share, Advisor& a) {
    // Set forwarding pointer
    a.prev(this);
    ActorLink::prev(NULL);
    // Set propagator pointer
    ActorLink::next(a.next()->prev());
  }
  forceinline Propagator* 
  Advisor::propagator(void) const { 
    return static_cast<Propagator*>(ActorLink::next()); 
  }
  forceinline void 
  Advisor::disposed(size_t size) { 
    ActorLink::prev(reinterpret_cast<ActorLink*>((size << 1) | 1)); 
  }
  forceinline bool
  Advisor::disposed(void) const { 
    return reinterpret_cast<ptrdiff_t>(prev())&1 == 1;
  }
  forceinline size_t 
  Advisor::size(void) const { 
    assert(disposed());
    return reinterpret_cast<ptrdiff_t>(prev())>>1;
  }
  forceinline size_t
  Advisor::dispose(Space*) {
    disposed(sizeof(*this));
    return sizeof(*this);
  }

  forceinline ExecStatus
  ES_SUBSUMED(Advisor* a, size_t s) {
    a->disposed(s);
    return __ES_SUBSUMED;
  }
  forceinline ExecStatus
  ES_SUBSUMED(Advisor* a, Space* home) {
    a->dispose(home);
    // dispose will set the size correctly
    return __ES_SUBSUMED;
  }


  inline
  CouncilBase::CouncilBase(Space* home, unsigned int reserve)
    : siz(reserve > 1 ? reserve : 1), 
      advisors(static_cast<Advisor**>(home->alloc(sizeof(Advisor*)*siz))) {
    // Set up free-linkage in array
    for (int i = siz; i--; ) 
      advisors[i] = reinterpret_cast<Advisor*>((i+1)%siz);
  }

  inline
  CouncilBase::CouncilBase(Space* home, bool share, CouncilBase& c)
    : siz(c.compact(home)), 
      advisors(static_cast<Advisor**>(home->alloc(sizeof(Advisor*)*siz)))
  {}
  
  forceinline bool
  CouncilBase::active(Advisor* a) const {
    return ((reinterpret_cast<ptrdiff_t>(a) > siz) &&
            !a->disposed());
  }

  template <class A>
  forceinline
  Council<A>::Council(Space* home, unsigned int reserve)
    : CouncilBase(home,reserve) {}

  template <class A>
  forceinline
  Council<A>::Council(Space* home, bool share, Council<A>& c)
    : CouncilBase(home,share,c) {
    for (int ci = c.siz, i = siz; ci-- && i--; ) {
      assert(active(c.advisors[ci]));
      advisors[i] = new (home) A(home,share,
                                 *static_cast<A*>(c.advisors[ci]));
    }
  }
  
  template <class A>
  inline size_t
  Council<A>::dispose(Space* home) {
    for (int i = siz; i--; )
      if (active(advisors[i]))
        (void) static_cast<A*>(advisors[i])->dispose(home);
    home->reuse(advisors, sizeof(Advisor*)*siz);
    return sizeof(A);
  }


  /*
   * Variables
   *
   */

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline
  Variable<VTI,PC,MED>::Variable(Space*) :
    _next(reinterpret_cast<Variable<VTI,PC,MED>*>(1)) {
    u.free_me = 0;
    for (int i=PC_SIZE; i--; )
      idx[i] = NULL;
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline
  Variable<VTI,PC,MED>::Variable(void) :
    _next(reinterpret_cast<Variable<VTI,PC,MED>*>(1)) {
    u.free_me = 0;
    for (int i=PC_SIZE; i--; )
      idx[i] = NULL;
  }


  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline unsigned int
  Variable<VTI,PC,MED>::degree(void) const {
    return static_cast<unsigned int>(idx[PC_SIZE-1] - idx[0]);
  }



  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline ModEvent
  Variable<VTI,PC,MED>::modevent(void) const {
    return u.free_me & 15;
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline void
  Variable<VTI,PC,MED>::modevent(ModEvent me) {
    u.free_me = (u.free_me & ~15) | me;
  }
  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline unsigned int
  Variable<VTI,PC,MED>::free(void) const {
    return u.free_me >> 4;
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline void
  Variable<VTI,PC,MED>::free(unsigned int n) {
    u.free_me = (u.free_me & 15) | (n << 4);
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline void
  Variable<VTI,PC,MED>::free_inc(void) {
    u.free_me += (1 << 4);
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline void
  Variable<VTI,PC,MED>::free_dec(void) {
    u.free_me -= (1 << 4);
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline bool
  Variable<VTI,PC,MED>::modified(void) const {
    return _next != reinterpret_cast<Variable<VTI,PC,MED>*>(1);
  }



  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline Variable<VTI,PC,MED>*
  Variable<VTI,PC,MED>::next(void) {
    Variable<VTI,PC,MED>* n = _next;
    _next = reinterpret_cast<Variable<VTI,PC,MED>*>(1);
    return n;
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline bool
  Variable<VTI,PC,MED>::copied(void) const {
    return _next != reinterpret_cast<Variable<VTI,PC,MED>*>(1);
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline
  Variable<VTI,PC,MED>::Variable(Space* home, bool, Variable<VTI,PC,MED>& x)
    : _next(reinterpret_cast<Variable<VTI,PC,MED>*>(1)) {
    VarBase** reg;
    if (x.idx[0] == NULL) {
      // Variable needs no index structure
      u.free_me = 0;
      for (int i=PC_SIZE; i--; )
        idx[i] = NULL;
      reg = &home->vars_noidx;
    } else {
      // Recover original value in copy
      u.free_me = x.u.free_me;
      reg = &home->vars[VTI].entry;
    }
    // Set forwarding pointer
    x.u.fwd = this;
    // Register original
    x._next = static_cast<Variable<VTI,PC,MED>*>(*reg); *reg = &x;
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline Variable<VTI,PC,MED>*
  Variable<VTI,PC,MED>::forward(void) const {
    return u.fwd;
  }

  /*
   * Propagator modification events
   *
   */

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline ModEvent
  Variable<VTI,PC,MED>::pme(const Propagator* p) {
    return static_cast<ModEvent>((p->u.pme >> (VTI << 2)) & 15);
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline PropModEvent
  Variable<VTI,PC,MED>::pme(ModEvent me) {
    return static_cast<PropModEvent>(me << (VTI << 2));
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline ModEvent
  Variable<VTI,PC,MED>::combine(ModEvent me1, ModEvent me2) {
    MED med;
    return me2^med(me1,me2);
  }

  /*
   * Delta information for advisors
   *
   */
  forceinline ModEvent
  Delta::modevent(void) const {
    return me;
  };


  /*
   * Propagators
   *
   */
  forceinline void
  Actor::force(Space* home) {
    if (home->d_cur == home->d_lst)
      home->d_resize();
    *(home->d_cur++) = this;
  }
  forceinline void
  Actor::unforce(Space* home) {
    // Check wether array has already been discarded as space
    // deletion is already in progress
    Actor** f = home->d_fst;
    if (f != NULL) {
      while (this != *f)
        f++;
      *f = *(--home->d_cur);
    }
  }


  forceinline
  Propagator::Propagator(Space* home) {
    u.pme = 0;
    home->a_actors.head(this);
  }

  forceinline
  Propagator::Propagator(Space*, bool, Propagator& p) {
    u.pme = 0;
    // Set forwarding pointer
    p.prev(this);
  }


  /*
   * Branchings
   *
   */

  forceinline
  Branching::Branching(Space* home) {
    // Propagators are put at the tail of the link of actors
    id = home->branch_id++;
    // If no branching available, make it the first one
    if (home->b_status == &(home->a_actors)) {
      home->b_status = this;
      if (home->b_commit == &(home->a_actors))
        home->b_commit = this;
    }
    home->a_actors.tail(this);
  }

  forceinline
  Branching::Branching(Space*, bool, Branching& b)
    : id(b.id)  {
    // Set forwarding pointer
    b.prev(this);
  }



  /*
   * Branching descriptions
   *
   */

  forceinline
  BranchingDesc::BranchingDesc(const Branching* b, const unsigned int a)
    : id(b->id), alt(a) {}

  forceinline unsigned int
  BranchingDesc::alternatives(void) const {
    return alt;
  }

  forceinline
  BranchingDesc::~BranchingDesc(void) {}





  /*
   * Propagator pools
   *
   */

  forceinline void
  Space::pool_put(Propagator* p) {
    int c = p->cost();
    p->unlink(); pool[c].tail(p);
    if (c > pool_next)
      pool_next = c;
  }

  forceinline void
  Space::fail(void) {
    b_status = NULL;
  }

  template <VarTypeId VTI, class MED>
  forceinline void
  Space::process(Propagator* p) {
    // The new event is ME_GEN_ASSIGNED
    PropModEvent old_pme = p->u.pme;
    // Compute old modification event
    ModEvent old_me = old_pme & (ME_GEN_MAX << (VTI << 2));
    // Check whether old event is already ME_GEN_ASSIGNED
    if (old_me == (ME_GEN_ASSIGNED << (VTI << 2)))
      return;
    // Update event
    p->u.pme ^= old_me ^ (ME_GEN_ASSIGNED << (VTI << 2));
    // Put propagator into right queue
    pool_put(p);
  }

  template <VarTypeId VTI, class MED>
  forceinline void
  Space::process(Propagator* p, ModEvent new_me) {
    MED med;
    PropModEvent old_pme = p->u.pme;
    // Compute the old modification event
    ModEvent old_me = ((old_pme >> (VTI << 2)) & ME_GEN_MAX);
    // Get the new modification event (xor-ed with the old one)
    ModEvent com_me = med(new_me,old_me);
    // Event has not changed, do not nothing
    if (com_me == 0)
      return;
    // Update modification event for propagator (use xor)
    p->u.pme ^= (com_me << (VTI << 2));
    // Put propagator into right queue
    pool_put(p);
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline void
  Variable<VTI,PC,MED>::schedule(Space* home, Propagator* p, ModEvent me) {
    home->process<VTI,MED>(p,me);
  }

  forceinline ExecStatus
  ES_SUBSUMED(Propagator* p, size_t s) {
    p->u.size = s; return __ES_SUBSUMED;
  }
  forceinline ExecStatus
  ES_SUBSUMED(Propagator* p, Space* home) {
    p->u.size = p->dispose(home); return __ES_SUBSUMED;
  }

  forceinline ExecStatus
  ES_FIX_PARTIAL(Propagator* p, PropModEvent pme) {
    p->u.pme = pme; return __ES_FIX_PARTIAL;
  }

  forceinline ExecStatus
  ES_NOFIX_PARTIAL(Propagator* p, PropModEvent pme) {
    p->u.pme = pme; return __ES_NOFIX_PARTIAL;
  }


  /*
   * Subscribing to a variable
   *
   */

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline void
  Variable<VTI,PC,MED>::enter(Space* home, ActorLink* a, PropCond pc) {
    // Count one new subscription
    home->n_sub += 1;
    if (free() == 0)
      resize(home);
    free_dec();
    // Enter subscription
    --idx[0];
    for (PropCond i = 0; i < pc; i++)
      *(idx[i]) = *(--idx[i+1]);
    *idx[pc]=a;
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  void
  Variable<VTI,PC,MED>::resize(Space* home) {
    assert(free() == 0);
    if (idx[0] == NULL) {
      // Create fresh dependency array
      free(4);
      ActorLink** prop = reinterpret_cast<ActorLink**>
        (home->alloc(4*sizeof(ActorLink*))) + 4;
      for (PropCond i = PC_SIZE; i--; )
        idx[i] = prop;
    } else {
      // Resize dependency array
      unsigned int n = static_cast<unsigned int>(idx[PC_SIZE-1] - idx[0]);
      // Find out whether the area is most likely in the special area
      // reserved for subscriptions. If yes, just resize mildly otherwise
      // more agressively
      ActorLink** s = reinterpret_cast<ActorLink**>
        (home->mm.subscriptions());
      unsigned int m = 
        ((s <= idx[0]) && (idx[0] < s+home->n_sub)) ?
        (n+4) : ((n+1)*3>>1);
      ActorLink** prop = reinterpret_cast<ActorLink**>
        (home->alloc(m*sizeof(ActorLink*))) + m-n;
      free(m-n);
      // Copy entries
      memcpy(prop, idx[0], n*sizeof(ActorLink*));
      home->reuse(idx[0], n*sizeof(ActorLink*));
      // Update index pointers
      ptrdiff_t o = prop - idx[0];
      idx[0] = prop;
      for (PropCond i = PC_SIZE-1; i > 0; i--)
        idx[i] += o;
    }
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline void
  Variable<VTI,PC,MED>::subscribe(Space* home, Propagator* p, PropCond pc,
                                  bool assigned, ModEvent me, bool process) {
    if (assigned) {
      // Do not subscribe, just process the propagator
      if (process)
        home->process<VTI,MED>(p);
    } else {
      enter(home,p,pc);
      // Process propagator
      if (process && (pc != PC_GEN_ASSIGNED))
        home->process<VTI,MED>(p,me);
    }
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline void
  Variable<VTI,PC,MED>::subscribe(Space* home, Advisor* a, bool assigned) {
#if GECODE_USE_ADVISORS
    if (!assigned)
      enter(home,a,PC+1);
#endif
  }


  /*
   * Cancelling a subscription
   *
   */

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline void
  Variable<VTI,PC,MED>::remove(Space* home, ActorLink* a, PropCond pc) {
    ActorLink** f = idx[pc];
#if GECODE_AUDIT
    while (f < idx[pc+1])
      if (*f == a)
        goto found;
      else
        f++;
    GECODE_NEVER;
  found: ;
#else
    while (*f != a) f++;
#endif
    *f=*idx[pc];
    for (PropCond i=pc; i>0; i--)
      *(idx[i]++)=*(idx[i-1]);
    idx[0]++;
    free_inc();
    home->n_sub -= 1;
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline void
  Variable<VTI,PC,MED>::cancel(Space* home, Propagator* p, PropCond pc,
                               bool assigned) {
    if (!assigned)
      remove(home,p,pc);
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline void
  Variable<VTI,PC,MED>::cancel(Space* home, Advisor* a, bool assigned) {
#if GECODE_USE_ADVISORS
    if (!assigned)
      remove(home,a,PC+1);
#endif
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline bool
  Variable<VTI,PC,MED>::advise(Space* home, ModEvent me, Delta& d) {
#if GECODE_USE_ADVISORS
    ActorLink** a = idx[PC+1];
    ActorLink** e = idx[PC+2];
    if (a != e) {
      d.me = me;
      do {
        switch (static_cast<Advisor*>(*a)->advise(home, d)) {
        case ES_FIX:
        case __ES_SUBSUMED: 
          break;
        case ES_FAILED:     
          return false;
        case ES_NOFIX:
          schedule(home,static_cast<Advisor*>(*a)->propagator(),me);
          break;
        default:
          GECODE_NEVER;
        }
        a++;
      } while (a != e);
    }
#endif
    return true;
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline bool
  Variable<VTI,PC,MED>::notify(Space* home, ModEvent new_me, Delta& d) {
    if (modified()) {
      MED med;
      u.free_me ^= med(new_me,modevent());
    } else {
      _next = static_cast<Variable<VTI,PC,MED>*>(home->vars[VTI].entry);
      home->vars[VTI].entry = this;
      modevent(new_me);
    }
    return advise(home,new_me,d);
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline bool
  Variable<VTI,PC,MED>::notify(Space* home, Delta& d) {
    assert(!modified());
    _next = static_cast<Variable<VTI,PC,MED>*>(home->vars[VTI].entry);
    home->vars[VTI].entry = this;
    return advise(home,ME_GEN_ASSIGNED,d);
  }




  /*
   * PROCESSING
   *
   */

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline void
  Variable<VTI,PC,MED>::update(Variable<VTI,PC,MED>* x, ActorLink**& sub) {
    // this refers to the variable to be updated (clone)
    // x refers to the original
    // Recover from copy (also overwrites forwarding pointer)
    x->u.free_me = u.free_me;
    ActorLink** f = x->idx[0];
    int n = static_cast<int>(x->idx[PC_SIZE-1] - f);
    u.free_me = 0;
    ActorLink** t = sub;
    sub += n;
    idx[0] = t;
    ptrdiff_t o = t - f;
    for (PropCond i = PC_SIZE-1; i>0; i--)
      idx[i] = x->idx[i]+o;
    while ((n-4) >= 0) {
      n -= 4;
      t[0]=f[0]->prev(); t[1]=f[1]->prev();
      t[2]=f[2]->prev(); t[3]=f[3]->prev();
      t += 4; f += 4;
    }
    if ((n-2) >= 0) {
      n -= 2;
      t[0]=f[0]->prev(); t[1]=f[1]->prev();
      t += 2; f += 2;
    }
    if (n > 0) {
      t[0]=f[0]->prev();
    }
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  VarTypeProcessor<VTI,PC,MED>::VarTypeProcessor(void) {
    Space::vtp[VTI] = this;
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  void
  VarTypeProcessor<VTI,PC,MED>::update(VarBase* vb, ActorLink**& sub) {
    Variable<VTI,PC,MED>* x = static_cast<Variable<VTI,PC,MED>*>(vb);
    do {
      x->forward()->update(x,sub); x = x->next();
    } while (x != NULL);
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  void
  VarTypeProcessor<VTI,PC,MED>::dispose(Space*, VarBase*) {}

  /*
   * Processing a single modified variable
   *
   */
  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline void
  Variable<VTI,PC,MED>::process(Space* home,
                                PropCond pc1, PropCond pc2, ModEvent me) {
    ActorLink** b = idx[pc1];
    ActorLink** p = idx[pc2+1];
    while (p-- > b)
      home->process<VTI,MED>(static_cast<Propagator*>(*p),me);
  }

  template <VarTypeId VTI, PropCond PC, class MED>
  forceinline void
  Variable<VTI,PC,MED>::process(Space* home) {
#if GECODE_USE_ADVISORS
    {
      ActorLink** b = idx[0];
      ActorLink** p = idx[PC+1];
      while (p-- > b)
        home->process<VTI,MED>(static_cast<Propagator*>(*p));
    }
    // Entries in index structure are disabled. However they
    // must still work for cloning (idx[0]) and degree (idx[PC+2])
    {
      ActorLink** b = idx[0];
      ActorLink** p = idx[PC+2];
      home->n_sub -= (p-b);
      // Information needed to release the dependency array
      unsigned int n = free() + (p-b);
      home->reuse(p-n,n*sizeof(ActorLink*));
      for (int i=PC+3; i--; )
        idx[i] = NULL;
    }
#else
    // Entries in index structure are disabled. However they
    // must still work for cloning (idx[0]) and degree (idx[PC+1])
    ActorLink** b = idx[0];    idx[0] = NULL;
    ActorLink** p = idx[PC+1]; idx[PC+1] = NULL;
    home->n_sub -= p-b;
    // Information needed to release the dependency array
    unsigned int n = free() + (p-b);
    ActorLink** s = p-n;
    while (p-- > b)
      home->process<VTI,MED>(static_cast<Propagator*>(*p));
    home->reuse(s,n*sizeof(ActorLink*));
#endif
  }


}

// STATISTICS: kernel-core
