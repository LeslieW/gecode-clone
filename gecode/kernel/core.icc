/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Christian Schulte <schulte@gecode.org>
 *     Guido Tack <tack@gecode.org>
 *     Mikael Lagerkvist <lagerkvist@gecode.org>
 *
 *  Copyright:
 *     Christian Schulte, 2002
 *     Guido Tack, 2003
 *     Mikael Lagerkvist, 2006
 *
 *  Bugfixes provided by:
 *     Alexander Samoilov <alexander_samoilov@yahoo.com>
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  Permission is hereby granted, free of charge, to any person obtaining
 *  a copy of this software and associated documentation files (the
 *  "Software"), to deal in the Software without restriction, including
 *  without limitation the rights to use, copy, modify, merge, publish,
 *  distribute, sublicense, and/or sell copies of the Software, and to
 *  permit persons to whom the Software is furnished to do so, subject to
 *  the following conditions:
 *
 *  The above copyright notice and this permission notice shall be
 *  included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include <algorithm>

namespace Gecode {

  class Space;

  /**
   * \defgroup FuncSupportShared Support for shared objects and handles
   *
   * Shared handles provide access to reference-counted objects
   * used by entities inside spaces. In particular, they support
   * updates with and without sharing. An update with sharing
   * just updates the handle. An update without sharing creates
   * a single copy per space during updating.
   *
   * \ingroup FuncSupport
   */
  
  /**
   * \brief The shared handle
   *
   * Shared handles must inherit from this base class where
   * \a Object must be a subclass of SharedObject. Shared
   * handles support that the handle has no object it currently
   * refers to.
   *
   * \ingroup FuncSupportShared
   */
  class SharedHandle {
  public:
    /**
     * \brief The shared object
     *
     * Shared objects must inherit from this base class. 
     *
     * \ingroup FuncSupportShared
     */
    class Object {
      friend class Space;
      friend class SharedHandle;
    private:
      /// The counter used for reference counting
      unsigned int use_cnt;
      /// The next shared object collected during copying
      Object* next;
      /// The forwarding pointer used for forwarding
      Object* fwd;
    public:
      /// Initialize
      Object(void);
      /// Return fresh copy for unshared update
      virtual Object* copy(void) const = 0;
      /// Delete shared object
      virtual ~Object(void);
      /// Allocate memory from heap
      static void* operator new(size_t s);
      /// Free memory allocated from heap
      static void  operator delete(void* p);
    };
  private:
    /// The shared object
    Object* o;
    /// Subscribe handle to object
    void subscribe(void);
    /// Cancel subscription of handle to object
    void cancel(void);
  public:
    /// Create shared handle with no object pointing to
    SharedHandle(void);
    /// Create shared handle that points to shared object \a so
    SharedHandle(Object* o);
    /// Copy constructor maintaining reference count
    SharedHandle(const SharedHandle& sh);
    /// Assignment operator mainitaining reference count
    SharedHandle& operator=(const SharedHandle& sh);
    /// Updating during cloning
    void update(Space* home, bool share, SharedHandle& sh);
    /// Destructor that maintains reference count
    ~SharedHandle(void);
  protected:
    /// Access to the shared object
    Object* object(void) const;
    /// Modify shared object
    void object(Object* n);
  };


  /**
   * \defgroup TaskVarMEPC Generic modification events and propagation conditions
   *
   * Predefined modification events must be taken into account
   * by variable types.
   * \ingroup TaskVar
   */
  //@{
  /// Type for modification events
  typedef int ModEvent;

  /// Generic modification event: failed variable
  const ModEvent ME_GEN_FAILED   = -1;
  /// Generic modification event: no modification
  const ModEvent ME_GEN_NONE     =  0;
  /// Generic modification event: variable is assigned a value
  const ModEvent ME_GEN_ASSIGNED =  1;

  /// Type for propagation conditions
  typedef int PropCond;
  /// Propagation condition to be ignored (convenience)
  const PropCond PC_GEN_NONE     = -1;
  /// Propagation condition for an assigned variable
  const PropCond PC_GEN_ASSIGNED = 0;
  //@}

  /**
   * \brief Propagator modification events
   *
   * Propagator modification events are used by propagators. A
   * propagator stores a modification event for each variable type.
   * They can be accessed through a variable or a view from a given
   * propagator. They can be constructed from a given modevent by
   * a variable or view.
   * \ingroup TaskActor
   */
  typedef int PropModEvent;

}

#include "gecode/kernel/var-type.icc"

namespace Gecode {

  /*
   * These are the classes of interest
   *
   */
  class ActorLink;
  class Actor;
  class Propagator;
  class Advisor;
  template <class A> class Council;
  template <class A> class Advisors;
  template <class VIC> class VarImp;


  /*
   * Variable implementations
   *
   */

  /**
   * \brief Base-class for variable implementations
   *
   * Serves as base-class that can be used without having to know any
   * template arguments.
   * \ingroup TaskVar
   */
  class VarImpBase {
    friend class Space;
  protected:
    /// Either next modified or next copied variable
    VarImpBase* _next; 
    /// Combine processing and update information
    union {
      /**
       * \brief Combines the number of free entries with modification events
       *
       * The least bits are reserved for the modification events, the
       * remaining bits are for the number of free entries.
       *
       */
      unsigned int free_me;
      /// Store the forwarding pointer during copying
      VarImpBase* fwd;
    } u;
    /// Return next modified variable and reset (during processing)
    VarImpBase* next(void);
  };

  /**
   * \brief Base class for %Variable type disposer
   *
   * Controls disposal of variable implementations.
   * \ingroup TaskVar
   */
  class GECODE_VTABLE_EXPORT VarDisposerBase {
  public:
    /**
      * \brief Dispose variables
      *
      * If needed for the variable type, dispose a list of
      * variables, with \a x being the first variable in the list.
      */
    GECODE_KERNEL_EXPORT virtual void dispose(Space* home, VarImpBase* x);
    /// Destructor (not really used)
    GECODE_KERNEL_EXPORT virtual ~VarDisposerBase(void);
  };

  /**
   * \brief %Variable type disposer
   *
   * Controls disposal of variables.
   * \ingroup TaskVar
   */
  template <class VarType>
  class VarDisposer : public VarDisposerBase {
  public:
    /// Constructor (registers disposer with kernel)
    VarDisposer(void);
    /**
      * \brief Dispose variables
      *
      * If needed for the variable type, dispose a list of
      * variables, with \a x being the first variable in the list.
      */
    virtual void dispose(Space* home, VarImpBase* x);
  };

  /**
   * \brief Domain change information to be supplied to advisors
   *
   * Generically, this class only manages modification events. More
   * information is of course dependent on the particular variable
   * types and is managed by subclassing.
   *
   */
  class Delta {
    template <class VIC> friend class VarImp;
  private:
    ModEvent me; ///< Store modification event
  public:
    /// Return modification event
    ModEvent modevent(void) const;
  };


  /**
   * \brief Base-class for variable implementations
   *
   * Implements variable implementation for variable implementation
   * configuration of type \a VIC.
   * \ingroup TaskVar
   */
  template <class VIC>
  class VarImp : public VarImpBase {
    friend class Space;
    friend class Propagator;
    template <class VarType> friend class VarDisposer;
  private:
    /// Index for processing and update
    static const int idx_pu = VIC::idx_pu;
    /// Index for disposal
    static const int idx_d = VIC::idx_d;
    /// Maximal propagation condition
    static const Gecode::PropCond pc_max = VIC::pc_max;
    /// Start of bits for propagator modification event
    static const int pme_bits_fst = VIC::pme_bits_fst;
    /// Number of bits for propagator modification event
    static const int me_bits_num = VIC::me_bits_num;
    /// Bitmask for propagator modification event
    static const int me_bits_mask = VIC::me_bits_mask;
    
    /// Stores where entries start (idx[pc])
    ActorLink** idx[pc_max+3];

    /// Manage number of free entries internally
    unsigned int free(void) const;
    /// Manage number of free entries internally
    void free(unsigned int n);
    /// Manage number of free entries internally
    void free_inc(void);
    /// Manage number of free entries internally
    void free_dec(void);

    /**
     * \brief Update copied variable \a x
     *
     * The argument \a sub gives the memory area where subscriptions are
     * to be stored.
     */
    void update(VarImp* x, ActorLink**& sub);

    /// Enter propagator or advisor to subscription array
    void enter(Space* home, ActorLink* a, PropCond pc);
    /// Resize subscription array
    void resize(Space* home);
    /// Remove propagator or advisor from subscription array
    void remove(Space* home, ActorLink* a, PropCond pc);
    /// Execute advisors during notification
    bool advise(Space* home, const Delta* d);

  protected:
    /// Return reference to variables (process and update)
    static VarImp<VIC>* vars_pu(Space* home);
    /// Set reference to variables (process and update)
    static void vars_pu(Space* home, VarImp<VIC>* x);
    /// Return reference to variables (dispose)
    static VarImp<VIC>* vars_d(Space* home);
    /// Set reference to variables (dispose)
    static void vars_d(Space* home, VarImp<VIC>* x);

  public:
    /// Creation
    VarImp(Space* home);
    /// Creation of static instances
    VarImp(void);

    /// \name Dependencies
    //@{
    /** \brief Subscribe propagator \a p with propagation condition \a pc to variable
     *
     * In case \a process is false, the propagator is just subscribed but
     * not processed for execution (this must be used when creating
     * subscriptions during propagation).
     *
     * In case the variable is assigned (that is, \a assigned is 
     * true), the subscribing propagator is processed for execution.
     * Otherwise, the propagator subscribes and is processed for execution
     * with modification event \a me provided that \a pc is different
     * from \a PC_GEN_ASSIGNED.
     */
    void subscribe(Space* home, Propagator* p, PropCond pc,
                   bool assigned, ModEvent me, bool process);
    /** \brief Cancel subscription of propagator \a p with propagation condition \a pc
     *
     * If the variable is assigned, \a assigned must be true.
     *
     */
    void cancel(Space* home, Propagator* p, PropCond pc,
                bool assigned);
    /** \brief Subscribe advisor \a a to variable
     *
     * The advisor \a a is only subscribed if \a assigned is false.
     *
     */
    void subscribe(Space* home, Advisor* a, bool assigned);
    /** \brief Cancel subscription of advisor \a a
     *
     * If the variable is assigned, \a assigned must be true.
     *
     */
    void cancel(Space* home, Advisor* p, bool assigned);
    /// Return degree (number of subscribed propagators and advisors)
    unsigned int degree(void) const;
    /**
     * \brief Notify that variable implementation has been modified with modification event \a me and domain change \a d
     *
     * Returns false if notification has failed.
     */
    bool notify(Space* home, ModEvent me, Delta* d);
    /**
     * \brief Notify that variable implementation has been assigned with domain change \a d
     *
     * This routine can only be used, if the variable implementation supports
     * a single modification event.
     *
     * Returns false if notification has failed.
     */
    bool notify(Space* home, Delta* d);
    //@}

    /// \name Processing modified variables
    //@{
    /// Check whether variable has been modified during propagation
    bool modified(void) const;
    //@}

    /// \name Cloning variables
    //@{
    /// Constructor for cloning
    VarImp(Space* home, bool share, VarImp& x);
    /// Is variable already copied
    bool copied(void) const;
    /// Use forward pointer if variable already copied
    VarImp* forward(void) const;
    //@}

    /// \name Variable implementation-dependent propagator support
    //@{
    /// Schedule propagator \a p with modification event \a me
    static void schedule(Space* home, Propagator* p, ModEvent me);
    /// Return modification event for variable from propagator \a p
    static ModEvent pme(const Propagator* p);
    /// Translate modification event \a me into propagator modification event
    static PropModEvent pme(ModEvent me);
    /// Combine modifications events \a me1 and \a me2
    static ModEvent combine(ModEvent me1, ModEvent me2);
    //@}

    /// \name Processing modified variables
    //@{
    /// Return next modified variable and reset (during processing)
    VarImp* next(void);
    /// Return current modification event of variable
    ModEvent modevent(void) const;
    /// Process subscribed propagators
    void process(Space* home, PropCond pc1, PropCond pc2, ModEvent me);
    /// Process subscribed propagators for assigned variable
    void process(Space* home);
    //@}

  public:
    /// \name Memory management
    //@{
    /// Allocate memory from space
    static void* operator new(size_t,Space*);
    /// Return memory to space
    static void  operator delete(void*,Space*);
    /// Needed for exceptions
    static void  operator delete(void*);
    //@}
    
  };


  namespace Reflection {
    class ActorSpec;
    class BranchSpec;
    class VarMap;
    class SpecIter;
  }

  /**
   * \defgroup TaskActorStatus Status of constraint propagation and branching commit
   * Note that the enum values starting with a double underscore should not
   * be used directly. Instead, use the provided functions with the same
   * name without leading underscores.
   *
   * \ingroup TaskActor
   */
  enum ExecStatus {
    __ES_SUBSUMED       = -2, ///< Internal: propagator is subsumed, do not use
    ES_FAILED           = -1, ///< Execution has resulted in failure
    ES_NOFIX            =  0, ///< Propagation has not computed fixpoint
    ES_OK               =  0, ///< Execution is okay
    ES_FIX              =  1, ///< Propagation has computed fixpoint
    __ES_FIX_PARTIAL    =  2, ///< Internal: propagator has computed partial fixpoint, do not use
    __ES_NOFIX_PARTIAL  =  3, ///< Internal: propagator has computed no partial fixpoint, do not use
    ES_STABLE           =  4  ///< Used for step(): space is already stable
  };

  /**
   * \brief Classification of propagation cost
   * \ingroup TaskActor
   */
  enum PropCost {
    PC_CRAZY_LO     = 0, ///< Exponential complexity, cheap
    PC_CRAZY_HI     = 0, ///< Exponential complexity, expensive
    PC_CUBIC_LO     = 1, ///< Cubic complexity, cheap
    PC_CUBIC_HI     = 1, ///< Cubic complexity, expensive
    PC_QUADRATIC_LO = 2, ///< Quadratic complexity, cheap
    PC_QUADRATIC_HI = 2, ///< Quadratic complexity, expensive
    PC_LINEAR_HI    = 3, ///< Linear complexity, expensive
    PC_LINEAR_LO    = 4, ///< Linear complexity, cheap
    PC_TERNARY_HI   = 5, ///< Three variables, expensive
    PC_BINARY_HI    = 6, ///< Two variables, expensive
    PC_TERNARY_LO   = 6, ///< Three variables, cheap
    PC_BINARY_LO    = 7, ///< Two variables, cheap
    PC_UNARY_LO     = 7, ///< Only single variable, cheap
    PC_UNARY_HI     = 7, ///< Only single variable, expensive
    PC_MAX          = 7  ///< Maximal cost value
  };

  /**
   * \brief Double-linked list for actors
   *
   * Used to maintain which actors belong to a space and also
   * (for propagators) to organize actors in the queue of
   * waiting propagators.
   */
  class ActorLink {
    friend class Actor;
    friend class Propagator;
    friend class Advisor;
    friend class Branching;
    friend class Space;
    template <class VIC> friend class VarImp;
  private:
    ActorLink* _next; ActorLink* _prev;
  public:
    //@{
    /// Routines for double-linked list
    ActorLink* prev(void) const; void prev(ActorLink*);
    ActorLink* next(void) const; void next(ActorLink*);
    ActorLink** next_ref(void);
    //@}

    /// Initialize links (self-linked)
    void init(void);
    /// Remove from predecessor and successor
    void unlink(void);
    /// Insert \a al directly after this
    void head(ActorLink* al);
    /// Insert \a al directly before this
    void tail(ActorLink* al);
  };


  /**
   * \brief Base-class for both propagators and branchings
   * \ingroup TaskActor
   */
  class GECODE_VTABLE_EXPORT Actor : private ActorLink {
    friend class Space;
    friend class Propagator;
    friend class Advisor;
    friend class Branching;
    friend class Reflection::SpecIter;
    template <class VIC> friend class VarImp;
    template <class A> friend class Council;
  public:
    /// Create copy
    virtual Actor* copy(Space*,bool) = 0;

    /// \name Memory management
    //@{
    /// Report size occupied by additionally datastructures
    GECODE_KERNEL_EXPORT 
    virtual size_t allocated(void) const;
    /// Delete actor and return its size
    GECODE_KERNEL_EXPORT
    virtual size_t dispose(Space* home);
    /// Register actor for forced dispose when \a home is deleted
    void force(Space* home);
    /// Deregister actor for forced dispose
    void unforce(Space* home);
    /// Allocate memory from space
    static void* operator new(size_t s, Space* home);
    /// No-op for exceptions
    static void  operator delete(void* p, Space* home);
    /// Return specification for this actor given a variable map \a m
    GECODE_KERNEL_EXPORT
    virtual Reflection::ActorSpec& spec(Space* home, Reflection::VarMap& m);
    /// Return specification given a variable map \a m and \a name
    GECODE_KERNEL_EXPORT
    Reflection::ActorSpec& spec(Space* home, Reflection::VarMap& m,
                                const Support::Symbol& name);
  private:
#ifndef __GNUC__
    /// Not used (uses dispose instead)
    static void  operator delete(void* p, size_t s);
#endif
    /// Not used
    static void* operator new(size_t s);
    //@}
#ifdef __GNUC__
  public:
    /// To avoid warnings from GCC
    GECODE_KERNEL_EXPORT virtual ~Actor(void);
    /// Not used (uses dispose instead)
    static void  operator delete(void* p, size_t s);
#endif
  };



  /**
   * \brief %Propagator \a p is subsumed
   *
   * The size of the propagator is \a s.
   *
   * Note that the propagator must be subsumed and also disposed. So
   * in general, there should be code such as 
   * \code return ES_SUBSUMED(this,dispose(home)) \endcode.
   * 
   * However, in case the propagator has nothing to dispose (all its
   * views are assigned and no external resources) it is sufficient
   * to do 
   * \code return ES_SUBSUMED(this,sizeof(*this)) \endcode.
   *
   * \warning Has a side-effect on the propagator. Overwrites
   *          the propagator modification events of a propagator.
   *          Use only directly with returning from propagation.
   * \ingroup TaskActorStatus
   */
  ExecStatus ES_SUBSUMED(Propagator* p, size_t s);
  /**
   * \brief %Propagator \a p is subsumed
   *
   * First disposes the propagator and then returns subsumtion.
   *
   * \warning Has a side-effect on the propagator. Overwrites
   *          the propagator modification events of a propagator.
   *          Use only directly with returning from propagation.
   * \ingroup TaskActorStatus
   */
  ExecStatus ES_SUBSUMED(Propagator* p, Space* home);
  /**
   * \brief %Propagator \a p has computed partial fixpoint
   *
   * %Set propagator modification events after processing of
   * variables to \a pme.
   * \warning Has a side-effect on the propagator. Overwrites
   *          the propagator modification events of a propagator.
   *          Use only directly with returning from propagation.
   * \ingroup TaskActorStatus
   */
  ExecStatus ES_FIX_PARTIAL(Propagator* p, PropModEvent pme);
  /**
   * \brief %Propagator \a p has not computed partial fixpoint
   *
   * %Set propagator modification events before processing of
   * variables to \a pme.
   * \warning Has a side-effect on the propagator. Overwrites
   *          the propagator modification events of a propagator.
   *          Use only directly with returning from propagation.
   * \ingroup TaskActorStatus
   */
  ExecStatus ES_NOFIX_PARTIAL(Propagator* p, PropModEvent pme);



  /**
   * \brief Base-class for propagators
   * \ingroup TaskActor
   */
  class GECODE_VTABLE_EXPORT Propagator : public Actor {
    friend class Space;
    template <class VIC> friend class VarImp;
    friend ExecStatus ES_SUBSUMED(Propagator*, size_t);
    friend ExecStatus ES_SUBSUMED(Propagator*, Space*);
    friend ExecStatus ES_FIX_PARTIAL(Propagator*, PropModEvent);
    friend ExecStatus ES_NOFIX_PARTIAL(Propagator*, PropModEvent);
    friend class Advisor;
    template <class A> friend class Council;
  private:
    union {
      /// A set of modification events (used during propagation)
      PropModEvent pme;
      /// The size of the propagator (used during subsumption)
      size_t size;
      /// A list of advisors (used during cloning)
      Gecode::ActorLink* advisors;
    } u;
  protected:
    /// Constructor for creation
    Propagator(Space* home);
    /// Constructor for cloning \a p
    Propagator(Space* home, bool share, Propagator& p);

  public:
    /// \name Propagation
    //@{
    /**
     * \brief Propagation function
     *
     * The propagation function must return an execution status as
     * follows:
     *  - ES_FAILED: the propagator has detected failure
     *  - ES_NOFIX: the propagator has done propagation
     *  - ES_FIX: the propgator has done propagation and has computed
     *    a fixpoint. That is, running the propagator immediately
     *    again will do nothing.
     *
     * Apart from the above values, a propagator can return
     * the result from calling one of the functions 
     *  - ES_SUBSUMED: the propagator is subsumed and has been already
     *    deleted.
     *  - ES_NOFIX_PARTIAL: the propagator has consumed some of its
     *    propagation events.
     *  - ES_FIX_PARTIAL: the propagator has consumed some of its
     *    propagation events and with respect to these events is
     *    at fixpoint
     * For more details, see the individual functions.
     *
     */
    virtual ExecStatus propagate(Space* home) = 0;
    /// Cost function
    virtual PropCost cost(void) const  = 0;
    /**
     * \brief Advise function
     *
     * The advisor is passed as argument \a a.
     *
     * A propagator must specialize this advise function, if it
     * uses advisors. The advise function must return an execution
     * status as follows:
     *  - ES_FAILED: the advisor has detected failure
     *  - ES_NOFIX: the advisor's propagator (that is, this propagator) 
     *    does not need to be run
     *  - ES_FIX: the advisor's propagator (that is, this propagator)
     *    must be run
     *
     * Apart from the above values, an advisor can return
     * the result from calling the function
     *  - ES_SUBSUMED_NOFIX: the advisor is subsumed, the advisor's
     *    propagator does not need to be run
     *  - ES_SUBSUMED_FIX: the advisor is subsumed, the advisor's
     *    propagator does not need to be run
     * For more details, see the function documentation.
     *
     * The delta \a d describes how the variable has been changed
     * by an operation on the advisor's variable. Typically,
     * the delta information can only be utilized by either 
     * static or member functions of views as the actual delta 
     * information is both domain and view dependent.
     *
     */
    GECODE_KERNEL_EXPORT
    virtual ExecStatus advise(Space* home, Advisor* a, const Delta* d);
    //@}
  };

  /** 
   * \brief Council of advisors
   * 
   * This is a utility class that maintains a council (that is, a 
   * collection) of advisors. The class should be used as a member 
   * of the propagator that wants to use advisors.
   *
   * Lifetime of an advisor is controlled by its council.
   *
   * \warning A propagator can only have at most one council!
   *
   * \ingroup TaskActor
   */
  template <class A>
  class Council {
    friend class Advisor;
    friend class Advisors<A>;
  private:
    /// Starting point for a linked list of advisors
    mutable ActorLink* advisors;
  public:
    /// Default constructor
    Council(void);
    /// Construct advisor council
    Council(Space* home);
    /// Test whether council has advisor left
    bool empty(void) const;
    /// Update during cloning (copies all advisors)
    void update(Space* home, bool share, Council<A>& c);
    /// Dispose council
    void dispose(Space* home);
  };


  /**
   * \brief Class to iterate over advisors of a council
   *
   */
  template <class A>
  class Advisors {
  private:
    /// The current advisor
    ActorLink* a;
  public:
    /// Initialize
    Advisors(Council<A>& c);
    /// Test whether there advisors left
    bool operator()(void) const;
    /// Move iterator to next advisor
    void operator++(void);
    /// Return advisor
    A* advisor(void) const;
  };


  /**
   * \brief Base-class for advisors
   *
   * Advisors are typically subclassed for each propagator that
   * wants to use advisors. The actual member function that
   * is executed when a variable is changed, must be implemented
   * by the advisor's propagator.
   *
   * \ingroup TaskActor
   */
  class Advisor : private ActorLink {
    template <class VIC> friend class VarImp;
    template <class A> friend class Council;
    template <class A>  friend class Advisors;
  private:
    /// Is the advisor disposed?
    bool disposed(void) const;
  protected:
    /// Return the advisor's propagator
    Propagator* propagator(void) const; 
  public:
    /// Constructor for creation
    template <class A>
    Advisor(Space* home, Propagator* p, Council<A>& c);
    /// Copying constructor
    Advisor(Space* home, bool share, Advisor& a);

    /// \name Memory management
    //@{
    /// Dispose the advisor
    template <class A>
    void dispose(Space* home, Council<A>& c);
    /// Allocate memory from space
    static void* operator new(size_t s, Space* home);
    /// No-op for exceptions
    static void  operator delete(void* p, Space* home);
    //@}
  private:
#ifndef __GNUC__
    /// Not used (uses dispose instead)
    static void  operator delete(void* p, size_t s);
#endif
    /// Not used
    static void* operator new(size_t s);
  };

  /**
   * \brief %Advisor \a a is subsumed
   *
   * Disposes the advisor and: 
   *  - returns subsumption.
   *  - returns that the propagator of \a a need not be run.
   *
   * \warning Has a side-effect on the advisor. Use only directly when
   *          returning from advise.
   * \ingroup TaskActorStatus
   */
  template <class A>
  ExecStatus ES_SUBSUMED_FIX(A* a, Space* home, Council<A>& c);
  /**
   * \brief %Advisor \a a is subsumed
   *
   * Disposes the advisor and: 
   *  - returns subsumption.
   *  - returns that the propagator of \a a must be run.
   *
   * \warning Has a side-effect on the advisor. Use only directly when
   *          returning from advise.
   * \ingroup TaskActorStatus
   */
  template <class A>
  ExecStatus ES_SUBSUMED_NOFIX(A* a, Space* home, Council<A>& c);



  /*
   * Branchings
   *
   */

  class Branching;

  /**
   * \brief Branch description for batch recomputation
   *
   * Must be refined by inheritance such that the information stored
   * inside a branching description is sufficient to redo a tell
   * performed by a particular branching.
   *
   * \ingroup TaskActor
   */
  class BranchingDesc {
    friend class Space;
  private:
    unsigned int _id;  ///< Identity to match creating branching
    unsigned int _alt; ///< Number of alternatives
  protected:
    /// Initialize for particular branching \a b and alternatives \a a
    BranchingDesc(const Branching* b, const unsigned int a);
  public:
    /// Return number of alternatives
    unsigned int alternatives(void) const;
    /// Return id of the creating branching
    unsigned int id(void) const;
    /// Report size occupied by branching description
    virtual size_t size(void) const = 0;
    /// Destructor
    GECODE_KERNEL_EXPORT virtual ~BranchingDesc(void);
    /// Allocate memory from heap
    static void* operator new(size_t);
    /// Return memory to heap
    static void  operator delete(void*);
  };

  /**
   * \brief Base-class for branchings
   *
   * Note that branchings cannot be created inside a propagator
   * (no idea why one would like to do that anyway). If you do that
   * the system will explode in a truly interesting way.
   *
   * \ingroup TaskActor
   */
  class GECODE_VTABLE_EXPORT Branching : public Actor {
    friend class Space;
    friend class BranchingDesc;
    friend class Reflection::SpecIter;
  private:
    unsigned int id; ///< Unique identity (to match to branching descriptions)
  protected:
    /// Constructor for creation
    Branching(Space* home);
    /// Constructor for cloning \a b
    Branching(Space* home, bool share, Branching& b);

  public:
    /// \name Branching
    //@{
    /**
     * \brief Check status of branching, return true if alternatives left
     *
     * This method is called when Space::status is called, it determines
     * whether to continue branching with this branching or move on to
     * the (possibly) next branching.
     *
     */
    virtual bool status(const Space* home) const = 0;
    /**
     * \brief Return branching description
     *
     * Note that this method can rely on the fact that it is called
     * immediately after a previous call to status. Hence, it is safe
     * to remember computation from status in order to speed up
     * description.
     *
     */
    virtual const BranchingDesc* description(const Space* home) const = 0;
    /**
     * \brief Commit for branching description \a d and alternative \a a
     *
     * The current branching in the space \a home performs a commit from
     * the information provided by the branching description \a d
     * and the alternative \a a.
     */
    virtual ExecStatus commit(Space* home, const BranchingDesc* d,
                              unsigned int a) = 0;
    //@}
    
    /// \name Reflection
    //@{
    virtual GECODE_KERNEL_EXPORT Reflection::BranchSpec
    branchSpec(Space* home, Reflection::VarMap& m, const BranchingDesc* d);
    //@}
  };



  /** 
   * \brief %Space status
   * \ingroup TaskSearch
   */
  enum SpaceStatus {
    SS_FAILED, ///< %Space is failed
    SS_SOLVED, ///< %Space is solved (no branching left)
    SS_BRANCH  ///< %Space must be branched (at least one branching left)
  };

  /**
   * \brief Computation spaces
   */
  class GECODE_VTABLE_EXPORT Space {
    friend class Actor;
    friend class Propagator;
    friend class Branching;
    friend class Advisor;
    friend class Reflection::SpecIter;
    template <class VIC> friend class VarImp;
    template <class VarType> friend class VarDisposer;
    friend class SharedHandle;
  private:
    /// Performs memory management for space
    MemoryManager mm; 
    /**
     * \brief Doubly linked list of all actors
     *
     * Propagators are stored at the beginning, branchings (if any) at
     * the end.
     */
    ActorLink a_actors;
    /**
     * \brief Points to the first branching to be used for status
     *
     * If equal to &a_actors, no branching does exist.
     *
     * If it is NULL, the space is failed.
     *
     */
    Branching* b_status;
    /**
     * \brief Points to the first branching to be used for commit
     *
     * Note that \a b_commit can point to an earlier branching
     * than \a b_status. This reflects the fact that the earlier
     * branching is already done (that is, status on that branching
     * returns false) but there might be still branching descriptions
     * referring to the earlier branching.
     *
     * If equal to &a_actors, no branching does exist.
     *
     */
    Branching* b_commit;
    /// Id of next branching to be created
    unsigned int branch_id;
    /**
     * \name Pool of waiting propagators
     */
    //@{
    /// Next cost level to check
    int pool_next;
    /// Waiting propagators according to cost
    ActorLink pool[PC_MAX+1];
    /// Put propagator \a p to pool
    void pool_put(Propagator* p);
    /// Get propagator \a p from pool
    bool pool_get(Propagator*& p);
    //@}
    /**
     * \name Process, update, and dispose variables
     */
    //@{
    /// Registered variable type disposers
    GECODE_KERNEL_EXPORT static VarDisposerBase* vd[AllVarConf::idx_d];
    /// Entries for processing and updating variables
    VarImpBase* _vars_pu[AllVarConf::idx_pu];
    /// Entries for disposing variables
    VarImpBase* _vars_d[AllVarConf::idx_d];
    /// Return reference to variables (process and update)
    template <class VIC> VarImpBase* vars_pu(void) const;
    /// Set reference to variables (process and update)
    template <class VIC> void vars_pu(VarImpBase* x);
    /// Return reference to variables (dispose)
    template <class VIC> VarImpBase* vars_d(void) const;
    /// Set reference to variables (dispose)
    template <class VIC> void vars_d(VarImpBase* x);
    /// Process all modified variables
    void process(void);
    /// Update all cloned variables
    void update(ActorLink** sub);
    //@}

    union {
      /// Number of subscriptions (not during copying)
      unsigned int n_sub;
      /// Keep variables during copying without index structure
      VarImpBase* vars_noidx;
    } pu;

    /// First actor for forced disposal
    Actor** d_fst;
    /// Current actor for forced disposal
    Actor** d_cur;
    /// Last actor for forced disposal
    Actor** d_lst;
    /// Resize disposal array
    GECODE_KERNEL_EXPORT void d_resize(void);

    /// Linked list of shared objects
    SharedHandle::Object* shared;

    /// Used for default arguments
    GECODE_KERNEL_EXPORT static unsigned long int unused_uli;

    /// Perform propagation, return false if failed
    GECODE_KERNEL_EXPORT bool propagate(unsigned long int& pn);

    /**
     * \name Processing propagators
     */
    //@{
    /// Process propagator \a p with modification event \a me
    template <class VIC> void process(Propagator* p, ModEvent me);
    /// Process propagator \a p with modification event ME_GEN_ASSIGNED
    template <class VIC> void process(Propagator* p);
    //@}

  public:
    /**
     * \brief Default constructor
     * \ingroup TaskModelScript
     */
    GECODE_KERNEL_EXPORT Space(void);
    /**
     * \brief Destructor
     * \ingroup TaskModelScript
     */
    GECODE_KERNEL_EXPORT virtual ~Space(void);
    /**
     * \brief Constructor for cloning
     *
     * Must copy and update all data structures (such as variables
     * and variable arrays) required by the subclass of Space.
     *
     * If \a share is true, share all data structures among copies.
     * Otherwise, make independent copies.
     * \ingroup TaskModelScript
     */
    GECODE_KERNEL_EXPORT Space(bool share, Space& s);
    /**
     * \brief Copying member function
     *
     * Must create a new object using the constructor for cloning.
     * \ingroup TaskModelScript
     */
    virtual Space* copy(bool share) = 0;
    /**
     * \brief Allocate memory from heap for new space
     * \ingroup TaskModelScript
     */
    static void* operator new(size_t);
    /**
     * \brief Free memory allocated from heap
     * \ingroup TaskModelScript
     */
    static void  operator delete(void*);


    /*
     * Member functions for search engines
     *
     */

    /**
     * \brief Query space status
     *
     * Propagates the space until fixpoint or failure and
     * increments \a pn by the number of propagator executions.
     *  - if the space is failed, SpaceStatus::SS_FAILED is returned.
     *  - if the space is not failed but the space has no branching left,
     *    SpaceStatus::SS_SOLVED is returned.
     *  - otherwise, SpaceStatus::SS_BRANCH is returned.
     * \ingroup TaskSearch
     */
    SpaceStatus status(unsigned long int& pn=unused_uli);

    /**
     * \brief Create new branching description for current branching
     *
     * This member function can only be called after the member function
     * Space::status on the same space has been called and in between
     * no non-const member function has been called on this space.
     *
     * Note that the above invariant obly pertains to calls of member
     * functions of the same space. If the invariant is violated, the
     * system is likely to crash (hopefully it does). In particular, if
     * applied to a space with no current branching, the system will
     * crash.
     *
     * \ingroup TaskSearch
     */
    const BranchingDesc* description(void) const;

    /**
     * \brief Clone space
     *
     * Propagates the space until fixpoint and increments \a pn by the
     * number of propagator executions. If propagation results in
     * a failed space, an exception of type SpaceFailed is thrown.
     *
     * Otherwise, a clone of the space is returned. If \a shared is true,
     * sharable datastructures are shared among the clone and the original
     * space. If \a shared is false, independent copies of the shared
     * datastructures must be created. This means that a clone with no
     * sharing can be used in a different thread without any interaction
     * with the original space.
     *
     * \ingroup TaskSearch
     */
    GECODE_KERNEL_EXPORT
    Space* clone(bool share=true, unsigned long int& pn=unused_uli);

    /**
     * \brief Commit branching description \a d and for alternative \a a
     *
     * The current branching in the space performs a commit from
     * the information provided by the branching description \a d
     * and the alternative \a a.
     *
     * Note that no propagation is perfomed (to support batch
     * recomputation), in order to perform propagation the member
     * function status must be used.
     *
     * Committing with branching descriptions must be carried
     * out in the same order as the branch descriptions have been
     * obtained by the member function Space::description().
     *
     * It is perfectly okay to add constraints interleaved with
     * branching descriptions (provided they are in the right order).
     * However, if propagation is performed by calling the member
     * function status and then new branching descriptions are
     * computed, these branching descriptions are different.
     *
     * Committing throws the following exceptions:
     *  - SpaceNoBranching, if the space has no current branching (it is
     *    already solved).
     *  - SpaceIllegalAlternative, if \a a is not smaller than the number
     *    of alternatives supported by the branching description \a d.
     *
     * \ingroup TaskSearch
     */
    GECODE_KERNEL_EXPORT
    void commit(const BranchingDesc* d, unsigned int a);

    /**
     * \brief Fail space
     *
     * This is useful for failing outside of actors. Never use inside
     * a propagate or commit member function. The system will crash!
     * \ingroup TaskActor
     */
    void fail(void);
    /**
     * \brief Check whether space is failed
     *
     * Note that this does not perform propagation. This is useful
     * for posting actors: only if a space is not yet failed, new
     * actors are allowed to be created.
     * \ingroup TaskActor
     */
    bool failed(void) const;
    /**
     * \brief Return if space is stable (at fixpoint or failed)
     * \ingroup TaskActor
     */
    GECODE_KERNEL_EXPORT bool stable(void) const;
    /**
     * \brief Perform single propagation step
     * \ingroup TaskActor
     */
    GECODE_KERNEL_EXPORT ExecStatus step(void);
    /**
     * \brief Return number of propagators
     *
     * Note that this function takes linear time in the number of
     * propagators. The number is only accurate when the space is
     * stable (that is, at fixpoint and all propagation is done).
     *
     * Throws an exception of type SpaceFailed, if the space is failed.
     */
    GECODE_KERNEL_EXPORT unsigned int propagators(void) const;
    /**
     * \brief Return number of branchings
     *
     * Note that this function takes linear time in the number of branchings.
     *
     * Throws an exception of type SpaceFailed, if the space is failed.
     */
    GECODE_KERNEL_EXPORT unsigned int branchings(void) const;

    /**
     * \name Reflection
     */
    //@{
    /// Return iterator over specifications of the propagators in this space
    GECODE_KERNEL_EXPORT
    Reflection::SpecIter actorSpecs(Reflection::VarMap& m);
    /// Enter variables into \a m
    GECODE_KERNEL_EXPORT
    virtual void getVars(Reflection::VarMap& m);
    /// Get reflection for BranchingDesc \a d
    GECODE_KERNEL_EXPORT
    Reflection::BranchSpec branchSpec(Reflection::VarMap& m,
                                      const BranchingDesc* d);
    //@}

    /**
     * \defgroup FuncMemSpace Space-memory management
     * \ingroup FuncMem
     */
    //@{
    /// Allocate memory on space heap
    void* alloc(size_t);
    /// Attempt to reuse memory previously allocated with alloc
    void  reuse(void*,size_t);
    /// Allocate from freelist-managed memory
    template <size_t> void* fl_alloc(void);
    /**
     * \brief Return freelist-managed memory to freelist
     *
     * The first list element to be retuned is \a f, the last is \a l.
     */
    template <size_t> void  fl_dispose(FreeList* f, FreeList* l);
    /**
     * \brief Return how much heap memory is allocated
     *
     * Note that is includes both the memory allocated for the space heap
     * as well as additional memory allocated by actors.
     */
    GECODE_KERNEL_EXPORT 
    size_t allocated(void) const;
    //@}
  };




  /***
   *** MEMORY MANAGEMENT
   ***
   ***/

  /*
   * Heap allocated: Space, BranchDesc
   *
   */

  forceinline void*
  Space::operator new(size_t s) {
    return Memory::malloc(s);
  }
  forceinline void
  Space::operator delete(void* p) {
    Memory::free(p);
  }

  forceinline void
  BranchingDesc::operator delete(void* p) {
    Memory::free(p);
  }
  forceinline void*
  BranchingDesc::operator new(size_t s) {
    return Memory::malloc(s);
  }

  /*
   * Space allocation: general space heaps and free lists
   *
   */

  forceinline void*
  Space::alloc(size_t s) {
    return mm.alloc(s);
  }
  forceinline void
  Space::reuse(void* p, size_t s) {
    return mm.reuse(p,s);
  }

  template <size_t s>
  forceinline void*
  Space::fl_alloc(void) {
    return mm.template fl_alloc<s>();
  }
  template <size_t s>
  forceinline void
  Space::fl_dispose(FreeList* f, FreeList* l) {
    mm.template fl_dispose<s>(f,l);
  }

  template <class VIC>
  forceinline VarImpBase*
  Space::vars_pu(void) const {
    return _vars_pu[VIC::idx_pu];
  }
  template <class VIC>
  forceinline void
  Space::vars_pu(VarImpBase* x) {
    _vars_pu[VIC::idx_pu] = x;
  }

  template <class VIC>
  forceinline VarImpBase*
  Space::vars_d(void) const {
    return _vars_d[VIC::idx_d];
  }
  template <class VIC>
  forceinline void
  Space::vars_d(VarImpBase* x) {
    _vars_d[VIC::idx_d] = x;
  }


  /*
   * Space allocated entities: Actors, variable implementations, and advisors
   *
   */

  forceinline void
  Actor::operator delete(void*, size_t) {}
  forceinline void
  Actor::operator delete(void*,Space*) {}
  forceinline void*
  Actor::operator new(size_t s, Space* home) {
    return home->alloc(s);
  }

  template <class VIC>
  forceinline void
  VarImp<VIC>::operator delete(void*) {}
  template <class VIC>
  forceinline void
  VarImp<VIC>::operator delete(void*, Space*) {}
  template <class VIC>
  forceinline void*
  VarImp<VIC>::operator new(size_t s, Space* home) {
    return home->alloc(s);
  }

#ifndef __GNUC__
  forceinline void
  Advisor::operator delete(void*, size_t) {}
#endif
  forceinline void
  Advisor::operator delete(void*,Space*) {}
  forceinline void*
  Advisor::operator new(size_t s, Space* home) {
    return home->alloc(s);
  }


  /*
   * Shared objects and handles
   *
   */
  forceinline void* 
  SharedHandle::Object::operator new(size_t s) {
    return Memory::malloc(s);
  }
  forceinline void
  SharedHandle::Object::operator delete(void* p) {
    Memory::free(p);
  }

  forceinline
  SharedHandle::Object::Object(void) 
    : use_cnt(0), fwd(NULL) {}
  forceinline
  SharedHandle::Object::~Object(void) {
    assert(use_cnt == 0);
  }

  forceinline void 
  SharedHandle::subscribe(void) {
    if (o != NULL) o->use_cnt++;
  }
  forceinline void 
  SharedHandle::cancel(void) {
    if ((o != NULL) && (--o->use_cnt == 0))
      delete o;
    o = NULL;
  }
  forceinline 
  SharedHandle::SharedHandle(void) : o(NULL) {}
  forceinline 
  SharedHandle::SharedHandle(SharedHandle::Object* so) : o(so) {
    subscribe();
  }
  forceinline 
  SharedHandle::SharedHandle(const SharedHandle& sh) : o(sh.o) {
    subscribe();
  }
  forceinline SharedHandle& 
  SharedHandle::operator=(const SharedHandle& sh) {
    if (&sh != this) {
      cancel(); o = sh.o; subscribe();
    }
    return *this;
  }
  forceinline void 
  SharedHandle::update(Space* home, bool share, SharedHandle& sh) {
    if (sh.o == NULL) {
      o = NULL;
    } else if (share) {
      o = sh.o; subscribe();
    } else if (sh.o->fwd != NULL) {
      o = sh.o->fwd; subscribe();
    } else {
      o = sh.o->copy(); 
      sh.o->fwd = o;
      sh.o->next = home->shared; 
      home->shared = sh.o;
      subscribe();
    }
  }
  forceinline 
  SharedHandle::~SharedHandle(void) {
    cancel();
  }
  forceinline SharedHandle::Object* 
  SharedHandle::object(void) const {
    return o;
  }
  forceinline void 
  SharedHandle::object(SharedHandle::Object* n) {
    if (n != o) {
      cancel(); o=n; subscribe();
    }
  }



  /*
   * ActorLinks as common superclass for propagators and branchings
   *
   */

  forceinline ActorLink*
  ActorLink::prev(void) const { return _prev; }
  forceinline ActorLink*
  ActorLink::next(void) const { return _next; }
  forceinline ActorLink**
  ActorLink::next_ref(void) { return &_next; }
  forceinline void
  ActorLink::prev(ActorLink* al) { _prev = al; }
  forceinline void
  ActorLink::next(ActorLink* al) { _next = al; }

  forceinline void
  ActorLink::unlink(void) {
    ActorLink* p = _prev; ActorLink* n = _next;
    p->_next = n; n->_prev = p;
  }
  forceinline void
  ActorLink::init(void) {
    _next = this; _prev =this;
  }
  forceinline void
  ActorLink::head(ActorLink* a) {
    // Inserts al at head of link-chain (that is, after this)
    ActorLink* n = _next;
    this->_next = a; a->_prev = this;
    a->_next = n; n->_prev = a;
  }
  forceinline void
  ActorLink::tail(ActorLink* a) {
    // Inserts al at tail of link-chain (that is, before this)
    ActorLink* p = _prev;
    a->_next = this; this->_prev = a;
    p->_next = a; a->_prev = p;
  }

  forceinline size_t
  Actor::dispose(Space*) {
    return sizeof(*this);
  }


  /*
   * Spaces
   *
   */

  forceinline const BranchingDesc*
  Space::description(void) const {
    return b_status->description(this);
  }

  forceinline bool
  Space::failed(void) const {
    return b_status == NULL;
  }


  /*
   * Main control for propagation and branching
   *  - a space only propagates and branches if requested by
   *    either a status, commit, or clone operation
   *  - for all of the operations the number of propagation
   *    steps performed is returned in the last (optional)
   *    reference argument
   *
   */
  forceinline SpaceStatus
  Space::status(unsigned long int& pn) {
    // Perform propagation and do not continue when failed
    if (failed() || !propagate(pn))
      return SS_FAILED;
    /*
     * Find the next branching that has still alternatives left
     *
     * It is important to note that branchings reporting to have no more
     * alternatives left can not be deleted. They can not be deleted
     * as there might be branching descriptions to be used in commit
     * that refer to one of these branchings.
     *
     * A branching reporting that no more alternatives exist will eventually
     * be deleted in commit. It will be deleted if the first branching
     * description is used in commit that does not refer to this branching.
     * As we insist that branching descriptions are used in order of
     * creation, all further branching descriptions cannot refer to this
     * branching.
     *
     */
    while (b_status != &a_actors) {
      if (b_status->status(this))
        return SS_BRANCH;
      b_status = static_cast<Branching*>(b_status->next());
    }
    // No branching with alternatives left, space is solved
    return SS_SOLVED;
  }


  /*
   * Advisors
   *
   */
  template <class A>
  forceinline 
  Advisor::Advisor(Space*, Propagator* p, Council<A>& c) {
    assert(p != NULL);
    // Store propagator and forwarding in prev()
    ActorLink::prev(p);
    // Link to next advisor in next()
    ActorLink::next(c.advisors); c.advisors = static_cast<A*>(this);
  }
  forceinline 
  Advisor::Advisor(Space*, bool, Advisor&) {}
  forceinline bool
  Advisor::disposed(void) const { 
    return prev() == NULL;
  }
  forceinline Propagator* 
  Advisor::propagator(void) const { 
    assert(!disposed());
    return static_cast<Propagator*>(ActorLink::prev()); 
  }
  template <class A>
  forceinline void
  Advisor::dispose(Space*,Council<A>&) {
    assert(!disposed());
    ActorLink::prev(NULL); 
    // Shorten chains of disposed advisors by one, if possible
    Advisor* n = static_cast<Advisor*>(next());
    if ((n != NULL) && n->disposed())
      next(n->next());
  }

  template <class A>
  forceinline ExecStatus
  ES_SUBSUMED_FIX(A* a, Space* home, Council<A>& c) {
    a->dispose(home,c);
    return ES_FIX;
  }
  template <class A>
  forceinline ExecStatus
  ES_SUBSUMED_NOFIX(A* a, Space* home, Council<A>& c) {
    a->dispose(home,c);
    return ES_NOFIX;
  }

  template <class A>
  forceinline
  Council<A>::Council(void) {}

  template <class A>
  forceinline
  Council<A>::Council(Space*) 
    : advisors(NULL) {}

  template <class A>
  forceinline bool
  Council<A>::empty(void) const {
    ActorLink* a = advisors;
    while ((a != NULL) && static_cast<A*>(a)->disposed())
      a = a->next();
    advisors = a;
    return a == NULL;
  }

  template <class A>
  forceinline void
  Council<A>::update(Space* home, bool share, Council<A>& c) {
    // Skip all disposed advisors
    {
      ActorLink* a = c.advisors;
      while ((a != NULL) && static_cast<A*>(a)->disposed())
        a = a->next();
      c.advisors = a;
    }
    // Are there any advisors to be cloned?
    if (c.advisors != NULL) {
      // The propagator in from-space
      Propagator* p_f = static_cast<A*>(c.advisors)->propagator();
      // The propagator in to-space
      Propagator* p_t = static_cast<Propagator*>(p_f->prev());
      // Advisors in from-space
      ActorLink** a_f = &c.advisors;
      // Advisors in to-space
      A* a_t = NULL;
      while (*a_f != NULL) {
        if (static_cast<A*>(*a_f)->disposed()) {
          *a_f = (*a_f)->next();
        } else {
          // Run specific copying part
          A* a = new (home) A(home,share,*static_cast<A*>(*a_f));
          // Set propagator pointer
          a->prev(p_t);
          // Set forwarding pointer
          (*a_f)->prev(a);
          // Link
          a->next(a_t);
          a_t = a;
          a_f = (*a_f)->next_ref();
        }
      }
      advisors = a_t;
      // Enter advisor link for reset
      assert(p_f->u.advisors == NULL);
      p_f->u.advisors = c.advisors;
    }
  }
  
  template <class A>
  forceinline void
  Council<A>::dispose(Space* home) {
    ActorLink* a = advisors;
    while (a != NULL) {
      if (!static_cast<A*>(a)->disposed())
        static_cast<A*>(a)->dispose(home,*this); 
      a = a->next();
    }
  }

  
  template <class A>
  forceinline
  Advisors<A>::Advisors(Council<A>& c)
    : a(c.advisors) {
    while ((a != NULL) && static_cast<A*>(a)->disposed())
      a = a->next();
  }
  template <class A>
  forceinline bool
  Advisors<A>::operator()(void) const {
    return a != NULL;
  }
  template <class A>
  forceinline void
  Advisors<A>::operator++(void) {
    do {
      a = a->next();
    } while ((a != NULL) && static_cast<A*>(a)->disposed());
  }
  template <class A>
  forceinline A*
  Advisors<A>::advisor(void) const {
    return static_cast<A*>(a);
  }


  /*
   * Variable implementations
   *
   */

  template <class VIC>
  forceinline
  VarImp<VIC>::VarImp(Space*) {
    _next = reinterpret_cast<VarImpBase*>(1);
    u.free_me = 0;
    u.fwd     = NULL;
    for (int i=pc_max+3; i--; )
      idx[i] = NULL;
  }

  template <class VIC>
  forceinline
  VarImp<VIC>::VarImp(void) {
    _next = reinterpret_cast<VarImpBase*>(1);
    u.free_me = 0;
    u.fwd     = NULL;
    for (int i=pc_max+3; i--; )
      idx[i] = NULL;
  }


  template <class VIC>
  forceinline unsigned int
  VarImp<VIC>::degree(void) const {
    return static_cast<unsigned int>(idx[pc_max+2] - idx[0]);
  }



  template <class VIC>
  forceinline ModEvent
  VarImp<VIC>::modevent(void) const {
    return static_cast<ModEvent>(u.free_me & me_bits_mask);
  }

  template <class VIC>
  forceinline unsigned int
  VarImp<VIC>::free(void) const {
    return u.free_me >> me_bits_num;
  }

  template <class VIC>
  forceinline void
  VarImp<VIC>::free(unsigned int n) {
    u.free_me = (u.free_me & me_bits_mask) | (n << me_bits_num);
  }

  template <class VIC>
  forceinline void
  VarImp<VIC>::free_inc(void) {
    u.free_me += 1 << me_bits_num;
  }

  template <class VIC>
  forceinline void
  VarImp<VIC>::free_dec(void) {
    u.free_me -= 1 << me_bits_num;
  }

  template <class VIC>
  forceinline bool
  VarImp<VIC>::modified(void) const {
    return _next != reinterpret_cast<VarImpBase*>(1);
  }



  forceinline VarImpBase*
  VarImpBase::next(void) {
    VarImpBase* n = _next;
    _next = reinterpret_cast<VarImpBase*>(1);
    return n;
  }

  template <class VIC>
  forceinline VarImp<VIC>*
  VarImp<VIC>::vars_pu(Space* home) {
    return static_cast<VarImp<VIC>*>(home->vars_pu<VIC>());
  }

  template <class VIC>
  forceinline void
  VarImp<VIC>::vars_pu(Space* home, VarImp<VIC>* x) {
    home->vars_pu<VIC>(x);
  }

  template <class VIC>
  forceinline VarImp<VIC>*
  VarImp<VIC>::vars_d(Space* home) {
    return static_cast<VarImp<VIC>*>(home->vars_d<VIC>());
  }

  template <class VIC>
  forceinline void
  VarImp<VIC>::vars_d(Space* home, VarImp<VIC>* x) {
    home->vars_d<VIC>(x);
  }

  template <class VIC>
  forceinline VarImp<VIC>*
  VarImp<VIC>::next(void) {
    return static_cast<VarImp<VIC>*>(VarImpBase::next());
  }

  template <class VIC>
  forceinline bool
  VarImp<VIC>::copied(void) const {
    return _next != reinterpret_cast<VarImpBase*>(1);
  }

  template <class VIC>
  forceinline
  VarImp<VIC>::VarImp(Space* home, bool, VarImp<VIC>& x) {
    _next = reinterpret_cast<VarImpBase*>(1);
    VarImpBase** reg;
    if (x.idx[0] == NULL) {
      // Variable implementation needs no index structure
      u.free_me = 0;
      u.fwd     = NULL;
      for (int i=pc_max+3; i--; )
        idx[i] = NULL;
      reg = &home->pu.vars_noidx;
    } else {
      // Recover original value in copy
      u.free_me = x.u.free_me;
      reg = &home->_vars_pu[VIC::idx_pu];
    }
    // Set forwarding pointer
    x.u.fwd = this;
    // Register original
    x._next = *reg; *reg = &x;
  }

  template <class VIC>
  forceinline VarImp<VIC>*
  VarImp<VIC>::forward(void) const {
    return static_cast<VarImp<VIC>*>(u.fwd);
  }

  /*
   * Propagator modification events
   *
   */

  template <class VIC>
  forceinline ModEvent
  VarImp<VIC>::pme(const Propagator* p) {
    return static_cast<ModEvent>((p->u.pme >> pme_bits_fst) & me_bits_mask);
  }

  template <class VIC>
  forceinline PropModEvent
  VarImp<VIC>::pme(ModEvent me) {
    return static_cast<PropModEvent>(me << pme_bits_fst);
  }

  template <class VIC>
  forceinline ModEvent
  VarImp<VIC>::combine(ModEvent me1, ModEvent me2) {
    return me2^VIC::mec(me1,me2);
  }

  /*
   * Delta information for advisors
   *
   */
  forceinline ModEvent
  Delta::modevent(void) const {
    return me;
  }


  /*
   * Propagators
   *
   */
  forceinline void
  Actor::force(Space* home) {
    if (home->d_cur == home->d_lst)
      home->d_resize();
    *(home->d_cur++) = this;
  }
  forceinline void
  Actor::unforce(Space* home) {
    // Check wether array has already been discarded as space
    // deletion is already in progress
    Actor** f = home->d_fst;
    if (f != NULL) {
      while (this != *f)
        f++;
      *f = *(--home->d_cur);
    }
  }


  forceinline
  Propagator::Propagator(Space* home) {
    u.advisors = NULL;
    assert(u.pme == 0 && u.size == 0);
    home->a_actors.head(this);
  }

  forceinline
  Propagator::Propagator(Space*, bool, Propagator& p) {
    u.advisors = NULL;
    assert(u.pme == 0 && u.size == 0);
    // Set forwarding pointer
    p.prev(this);
  }


  /*
   * Branchings
   *
   */

  forceinline
  Branching::Branching(Space* home) {
    // Propagators are put at the tail of the link of actors
    id = home->branch_id++;
    // If no branching available, make it the first one
    if (home->b_status == &(home->a_actors)) {
      home->b_status = this;
      if (home->b_commit == &(home->a_actors))
        home->b_commit = this;
    }
    home->a_actors.tail(this);
  }

  forceinline
  Branching::Branching(Space*, bool, Branching& b)
    : id(b.id)  {
    // Set forwarding pointer
    b.prev(this);
  }



  /*
   * Branching descriptions
   *
   */

  forceinline
  BranchingDesc::BranchingDesc(const Branching* b, const unsigned int a)
    : _id(b->id), _alt(a) {}

  forceinline unsigned int
  BranchingDesc::alternatives(void) const {
    return _alt;
  }

  forceinline unsigned int
  BranchingDesc::id(void) const {
    return _id;
  }

  forceinline
  BranchingDesc::~BranchingDesc(void) {}





  /*
   * Propagator pools
   *
   */

  forceinline void
  Space::pool_put(Propagator* p) {
    int c = p->cost();
    pool[c].tail(p);
    if (c > pool_next)
      pool_next = c;
  }

  forceinline void
  Space::fail(void) {
    b_status = NULL;
  }

  template <class VIC>
  forceinline void
  Space::process(Propagator* p) {
    // The new event is ME_GEN_ASSIGNED
    PropModEvent pme_old = p->u.pme;
    PropModEvent pme_mask = VIC::me_bits_mask << VIC::pme_bits_fst;
    // Compute old modification event
    ModEvent me_old = pme_old & pme_mask;
    // Check whether old event is already ME_GEN_ASSIGNED
    if (me_old == VIC::pme_assigned)
      return;
    // Update event
    p->u.pme ^= me_old ^ VIC::pme_assigned;
    // Put propagator into right queue
    p->unlink(); pool_put(p);
  }

  template <class VIC>
  forceinline void
  Space::process(Propagator* p, ModEvent me) {
    PropModEvent pme_old = p->u.pme;
    // Compute the old modification event
    ModEvent me_old = (pme_old >> VIC::pme_bits_fst) & VIC::me_bits_mask;
    // Get the new modification event (xor-ed with the old one)
    ModEvent me_com = VIC::mec(me,me_old);
    // Event has not changed, do not nothing
    if (me_com == 0)
      return;
    // Update modification event for propagator (use xor)
    p->u.pme ^= me_com << VIC::pme_bits_fst;
    // Put propagator into right queue
    p->unlink(); pool_put(p);
  }

  template <class VIC>
  forceinline void
  VarImp<VIC>::schedule(Space* home, Propagator* p, ModEvent me) {
    home->process<VIC>(p,me);
  }

  forceinline ExecStatus
  ES_SUBSUMED(Propagator* p, size_t s) {
    p->u.size = s; return __ES_SUBSUMED;
  }
  forceinline ExecStatus
  ES_SUBSUMED(Propagator* p, Space* home) {
    p->u.size = p->dispose(home); return __ES_SUBSUMED;
  }

  forceinline ExecStatus
  ES_FIX_PARTIAL(Propagator* p, PropModEvent pme) {
    p->u.pme = pme; return __ES_FIX_PARTIAL;
  }

  forceinline ExecStatus
  ES_NOFIX_PARTIAL(Propagator* p, PropModEvent pme) {
    p->u.pme = pme; return __ES_NOFIX_PARTIAL;
  }


  /*
   * Subscribing to a variable
   *
   */

  template <class VIC>
  forceinline void
  VarImp<VIC>::enter(Space* home, ActorLink* a, PropCond pc) {
    // Count one new subscription
    home->pu.n_sub += 1;
    if (free() == 0)
      resize(home);
    free_dec();
    // Enter subscription
    --idx[0];
    for (PropCond i = 0; i < pc; i++)
      *(idx[i]) = *(--idx[i+1]);
    *idx[pc]=a;
  }

  template <class VIC>
  void
  VarImp<VIC>::resize(Space* home) {
    assert(free() == 0);
    if (idx[0] == NULL) {
      // Create fresh dependency array
      free(4);
      ActorLink** prop = static_cast<ActorLink**>
        (home->alloc(4*sizeof(ActorLink*))) + 4;
      for (PropCond i = pc_max+3; i--; )
        idx[i] = prop;
    } else {
      // Resize dependency array
      unsigned int n = static_cast<unsigned int>(idx[pc_max+2] - idx[0]);
      // Find out whether the area is most likely in the special area
      // reserved for subscriptions. If yes, just resize mildly otherwise
      // more agressively
      ActorLink** s = static_cast<ActorLink**>
        (home->mm.subscriptions());
      unsigned int m = 
        ((s <= idx[0]) && (idx[0] < s+home->pu.n_sub)) ?
        (n+4) : ((n+1)*3>>1);
      ActorLink** prop = static_cast<ActorLink**>
        (home->alloc(m*sizeof(ActorLink*))) + m-n;
      free(m-n);
      // Copy entries
      memcpy(prop, idx[0], n*sizeof(ActorLink*));
      home->reuse(idx[0], n*sizeof(ActorLink*));
      // Update index pointers
      ptrdiff_t o = prop - idx[0];
      idx[0] = prop;
      for (PropCond i = pc_max+2; i > 0; i--)
        idx[i] += o;
    }
  }

  template <class VIC>
  forceinline void
  VarImp<VIC>::subscribe(Space* home, Propagator* p, PropCond pc,
                           bool assigned, ModEvent me, bool process) {
    if (assigned) {
      // Do not subscribe, just process the propagator
      if (process)
        home->process<VIC>(p);
    } else {
      enter(home,p,pc);
      // Process propagator
      if (process && (pc != PC_GEN_ASSIGNED))
        home->process<VIC>(p,me);
    }
  }

  template <class VIC>
  forceinline void
  VarImp<VIC>::subscribe(Space* home, Advisor* a, bool assigned) {
    if (!assigned)
      enter(home,a,pc_max+1);
  }


  /*
   * Cancelling a subscription
   *
   */

  template <class VIC>
  forceinline void
  VarImp<VIC>::remove(Space* home, ActorLink* a, PropCond pc) {
    /*
     * The entries are removed from front to back, so when iterating
     * over dependencies wile removing them it must be done in
     * forward direction.
     */
    ActorLink** f = idx[pc];
#ifdef GECODE_AUDIT
    while (f < idx[pc+1])
      if (*f == a)
        goto found;
      else
        f++;
    GECODE_NEVER;
  found: ;
#else
    while (*f != a) f++;
#endif
    *f=*idx[pc];
    for (PropCond i=pc; i>0; i--)
      *(idx[i]++)=*(idx[i-1]);
    idx[0]++;
    free_inc();
    home->pu.n_sub -= 1;
  }

  template <class VIC>
  forceinline void
  VarImp<VIC>::cancel(Space* home, Propagator* p, PropCond pc, bool assigned) {
    if (!assigned)
      remove(home,p,pc);
  }

  template <class VIC>
  forceinline void
  VarImp<VIC>::cancel(Space* home, Advisor* a, bool assigned) {
    if (!assigned)
      remove(home,a,pc_max+1);
  }

  template <class VIC>
  bool
  VarImp<VIC>::advise(Space* home, const Delta* d) {
    /*
     * An advisor that is executed might remove itself due to subsumtion.
     * As entries are removed from front to back, the advisors must
     * be iterated in forward direction.
     */
    ActorLink** la = idx[pc_max+1];
    ActorLink** le = idx[pc_max+2];
    assert (la != le);
    // An advisor that is run, might be removed during execution.
    // As removal is done from the back the advisors have to be executed
    // in inverse order.
    do {
      Advisor* a = static_cast<Advisor*>(*la);
      Propagator* p = a->propagator();
      switch (p->advise(home,a,d)) {
      case ES_FIX:
        break;
      case ES_FAILED:
        return false;
      case ES_NOFIX:
        schedule(home,p,d->me);
        break;
      default:
        GECODE_NEVER;
      }
    } while (++la < le);
    return true;
  }

  template <class VIC>
  forceinline bool
  VarImp<VIC>::notify(Space* home, ModEvent new_me, Delta* d) {
    if (modified()) {
      u.free_me ^= VIC::mec(new_me,static_cast<ModEvent>
                            (u.free_me & me_bits_mask));
    } else {
      _next = vars_pu(home); vars_pu(home,this);
      u.free_me = (u.free_me & ~me_bits_mask) | new_me;
    }
    if (idx[pc_max+1] != idx[pc_max+2]) {
      d->me = new_me;
      return advise(home,d);
    }
    return true;
  }

  template <class VIC>
  forceinline bool
  VarImp<VIC>::notify(Space* home, Delta* d) {
    assert(!modified());
    _next = vars_pu(home); vars_pu(home,this);
    if (idx[pc_max+1] != idx[pc_max+2]) {
      d->me = ME_GEN_ASSIGNED;
      return advise(home,d);
    }
    return true;
  }




  /*
   * PROCESSING
   *
   */

  template <class VIC>
  forceinline void
  VarImp<VIC>::update(VarImp<VIC>* x, ActorLink**& sub) {
    // this refers to the variable to be updated (clone)
    // x refers to the original
    // Recover from copy (also overwrites forwarding pointer)
    x->u.free_me = u.free_me;
    ActorLink** f = x->idx[0];
    int n = static_cast<int>(x->idx[pc_max+2] - f);
    u.free_me = 0;
    u.fwd     = NULL;
    ActorLink** t = sub;
    sub += n;
    idx[0] = t;
    ptrdiff_t o = t - f;
    for (PropCond i = pc_max+2; i>0; i--)
      idx[i] = x->idx[i]+o;
    while ((n-4) >= 0) {
      n -= 4;
      t[0]=f[0]->prev(); t[1]=f[1]->prev();
      t[2]=f[2]->prev(); t[3]=f[3]->prev();
      t += 4; f += 4;
    }
    if ((n-2) >= 0) {
      n -= 2;
      t[0]=f[0]->prev(); t[1]=f[1]->prev();
      t += 2; f += 2;
    }
    if (n > 0) {
      t[0]=f[0]->prev();
    }
  }

  template <class VarType>
  VarDisposer<VarType>::VarDisposer(void) {
    Space::vd[VarType::idx_d] = this;
  }

  template <class VarType>
  void
  VarDisposer<VarType>::dispose(Space* home, VarImpBase* _x) {
    VarType* x = static_cast<VarType*>(_x);
    do {
      x->dispose(home);
      x = static_cast<VarType*>(x->next_d());
    } while (x != NULL);
  }


  /*
   * Processing a single modified variable
   *
   */
  template <class VIC>
  forceinline void
  VarImp<VIC>::process(Space* home,
                         PropCond pc1, PropCond pc2, ModEvent me) {
    ActorLink** b = idx[pc1];
    ActorLink** p = idx[pc2+1];
    while (p-- > b)
      home->process<VIC>(static_cast<Propagator*>(*p),me);
  }

  template <class VIC>
  forceinline void
  VarImp<VIC>::process(Space* home) {
    {
      ActorLink** b = idx[0];
      ActorLink** p = idx[pc_max+1];
      while (p-- > b)
        home->process<VIC>(static_cast<Propagator*>(*p));
    }
    // Entries in index structure are disabled. However they
    // must still work for cloning (idx[0]) and degree (idx[PC+2])
    {
      ActorLink** b = idx[0];
      ActorLink** p = idx[pc_max+2];
      home->pu.n_sub -= (p-b);
      // Information needed to release the dependency array
      unsigned int n = free() + (p-b);
      home->reuse(p-n,n*sizeof(ActorLink*));
      for (int i=pc_max+3; i--; )
        idx[i] = NULL;
    }
  }

}

// STATISTICS: kernel-core
