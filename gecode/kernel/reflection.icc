/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Guido Tack <tack@gecode.org>
 *
 *  Copyright:
 *     Guido Tack, 2007
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  Permission is hereby granted, free of charge, to any person obtaining
 *  a copy of this software and associated documentation files (the
 *  "Software"), to deal in the Software without restriction, including
 *  without limitation the rights to use, copy, modify, merge, publish,
 *  distribute, sublicense, and/or sell copies of the Software, and to
 *  permit persons to whom the Software is furnished to do so, subject to
 *  the following conditions:
 *
 *  The above copyright notice and this permission notice shall be
 *  included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include <iostream>
#include <cstring>
#include <vector>
#include <string>
#include <map>

namespace Gecode { namespace Reflection {
  
  /// Exception for errors during reflection
  class ReflectionException : public Exception {
  public:
    /// Constructor
    ReflectionException(const char* what) : Exception("Reflection", what) {}
  };
  
  class ArrayArg;
  class IntArrayArg;
  class StringArg;
  
  /**
    * \brief View types of actor arguments
    *
    * \ingroup TaskIntReflect
    */
  class Type {
  private:
    /// Number of arguments
    int n;
    union {
      /// If n==0, this is the name of the view type
      char* n;
      /// If n>0, this is the tuple representing the type
      Type** t;
    } u;
  public:
    /// Construct singleton type with \a name
    Type(const char* name);
    /// Construct \a n -ary tuple type
    Type(int n);

    GECODE_KERNEL_EXPORT bool equal(Type* t);

    /// Destructor
    ~Type(void);

    /// Return whether this is a primitive type or a tuple of types
    bool primitive(void) const;
    /// Return arity of tuple type (or 0 for primitive type)
    int arity(void) const;
    
    /// Access element of tuple type
    Type* operator[](int) const;
    /// Access element of tuple type
    Type*& operator[](int);

    /// Return name of primitive type
    const char* name(void) const;
    
    /// Print string representation to \a os
    GECODE_KERNEL_EXPORT void print(std::ostream& os);

    /// Return string representation
    GECODE_KERNEL_EXPORT std::string toString(void);
  };


  /**
    * \brief Arguments for actor and variable specifications
    *
    * \ingroup TaskIntReflect
    */
  class Arg {
  public:
    /// Test if this represents an integer
    bool         isInt(void);
    /// Return the integer that this argument represents
    int          toInt(void);
    /// Test if this represents a variable
    bool         isVar(void);
    /// Return the variable number that this argument represents
    int          toVar(void);
    /// Test if this represents an array
    bool         isArray(void);
    /// Return the array that this argument represents
    ArrayArg*    toArray(void);
    /// Test if this represents an array
    bool         isIntArray(void);
    /// Return the array that this argument represents
    IntArrayArg* toIntArray(void);
    /// Test if this represents a string
    bool         isString(void);
    /// Return the string that this argument represents
    const char*  toString(void);
    /// Test if this represents a pair
    bool         isPair(void);
    /// Return the first component of the pair that this argument represents
    Arg*         first(void);
    /// Return the second component of the pair that this argument represents
    Arg*         second(void);
    /// Test if this represents a typed argument
    bool         isTypedArg(void);
    /// Return type of typed argument
    Type*        type(void);
    /// Return argument of typed argument
    Arg*         typedArg(void);
    /// Destructor
    GECODE_KERNEL_EXPORT virtual ~Arg(void);
  };
  
  /**
    * \brief Integer arguments
    * \ingroup TaskIntReflect
    */
  class IntArg : public Arg {
  public:
    /// Constructor
    IntArg(int i0);
    /// The integer represented by this argument
    int i;
  };

  /**
    * \brief %Variable arguments
    * \ingroup TaskIntReflect
    */
  class VarArg : public Arg {
  public:
    /// Constructor
    VarArg(int i0);
    /// The variable number represented by this argument
    int i;
  };

  /**
    * \brief Array arguments
    * \ingroup TaskIntReflect
    */
  class ArrayArg : public Arg {
  private:
    /// Size of the array
    int  n;
    /// The actual array
    Arg** a;
  public:
    /// Constructor
    ArrayArg(int n0);
    /// Destructor
    GECODE_KERNEL_EXPORT virtual ~ArrayArg(void);
    
    // const Arg*& operator[](int i) const;
    Arg*& operator[](int i);
    int size(void) const;
  };

  /**
    * \brief Integer array arguments
    * \ingroup TaskIntReflect
    */
  class IntArrayArg : public Arg {
  private:
    /// Size of the array
    int  n;
    /// The actual array
    int* a;    
  public:
    /// Constructor
    IntArrayArg(int n0);
    /// Construct from given array \a a
    template <class A> IntArrayArg(const A& a);
    /// Destructor
    GECODE_KERNEL_EXPORT virtual ~IntArrayArg(void);
    
    const int& operator[](int i) const;
    int& operator[](int i);
    int size(void) const;
  };

  /**
    * \brief Argument paired with a type
    * \ingroup TaskIntReflect
    */
  class TypedArg : public Arg {
  public:
    /// Constructor
    TypedArg(Type* t0, Arg* a0);
    /// Destructor
    GECODE_KERNEL_EXPORT virtual ~TypedArg(void);
    /// The type of this argument
    Type* t;
    /// The argument
    Arg* a;
  };

  /**
    * \brief String arguments
    * \ingroup TaskIntReflect
    */
  class StringArg : public Arg {
  public:
    /// Constructor
    StringArg(const char* s0);
    /// The string represented by this argument
    const char* s;
  };
  
  /**
    * \brief Pair arguments
    * \ingroup TaskIntReflect
    */
  class PairArg : public Arg {
  public:
    /// Constructor
    PairArg(Arg* a0, Arg* b0);
    /// Destructor
    GECODE_KERNEL_EXPORT virtual ~PairArg(void);
    /// The first component
    Arg* a;
    /// The second component
    Arg* b;
  };
  
  /**
    * \brief %Variable specification
    * \ingroup TaskIntReflect
    */
  class VarSpec {
  private:
    /// The variable type identifier for this variable
    int  _vti;

    class Domain {
    public:
      /// The name of this variable
      char* _n;
      /// A representation of the domain of this variable
      Arg* _dom;
      /// Reference count
      int r;
      /// Constructor
      Domain(Arg* domain);
      /// Destructor
      ~Domain(void);
    };
    /// A representation of the domain of this variable
    Domain* _dom;
  public:
    /// Construct specification for a variable
    VarSpec(int vti, Arg* domain);
    /// Copy constructor
    VarSpec(const VarSpec& s);
    /// Assignment operator
    const VarSpec& operator=(const VarSpec& s);
    /// Destructor
    ~VarSpec(void);
    /// Set the name for this variable
    void name(const char* n0);
    /// Get the name of this variable
    const char* name(void) const;
    /// Get the domain of this variable
    Arg* dom(void) const;
    // Get the variable type identifier for this variable
    int vti(void) const;
  };
  
  /**
    * \brief %Actor specification
    * \ingroup TaskIntReflect
    */
  class ActorSpec {
  private:
    class Arguments {
    public:
      /// The name of this actor
      char* _name;
      /// The size of the argument array
      int   size;
      /// The number of arguments of this actor
      int   n;
      /// The arguments of this actor
      Arg** a;
      /// Reference counter
      int r;
      /// Construct empty arguments
      Arguments(const char*);
      /// Destructor
      ~Arguments(void);
    };
    Arguments* _args;
  public:
    /// Construct actor specification with \a name
    ActorSpec(const char* name);
    /// Copy constructor
    ActorSpec(const ActorSpec& s);
    /// Assignment operator
    const ActorSpec& operator=(const ActorSpec& s);
    /// Destructor
    ~ActorSpec(void);
    
    /// Return argument \a i
    Arg* operator[](int i) const;
    /// Return number of arguments
    int noOfArgs(void) const;
    /// Add \a arg to the specification (as last argument)
    void add(Arg* arg);
    /// Return name
    const char* name(void) const;
  };
  
  /// Add \a a to specification \a spec
  ActorSpec& operator<<(ActorSpec& spec, Arg* a);
  /// Add \a i to specification \a spec
  ActorSpec& operator<<(ActorSpec& spec, int i);
  /// Add \a i to specification \a spec
  ActorSpec& operator<<(ActorSpec& spec, unsigned int i);
  /// Add \a d to specification \a spec, where \a d is cast into an integer
  ActorSpec& operator<<(ActorSpec& spec, double d);
  
  class VarMap;

  /**
    * \brief Iterating actor specifications
    *
    * Use this iterator to access specifications of all actors (propagators 
    * and branchings) of a space. The iterator also provides access to the
    * corresponding variables map.
    *
    * \ingroup TaskIntReflect
    */
  class SpecIter {
  private:
    /// The variable map used by this iterator
    VarMap&    m;
    /// The space for which to iterate the actors
    Space*     s;
    /// The current actor
    ActorLink *cur;
    /// The current ActorSpec
    ActorSpec* curSpec;
  public:
    /// Constructor
    SpecIter(Space*, VarMap&);
    /// Test whether iterator still has actor specifications or is done
    bool operator()(void) const;
    /// Move iterator to next actor
    void operator++(void);
    /// Return actor specification for current iterator position
    ActorSpec& actor(void) const;
  };

  /// Registry of constraint posting and variable creation functions
  class Registry {
  public:
    /// The type of constraint posting functions
    typedef void (*poster) (Space*, const VarMap&, const ActorSpec&);
    /// The type of variable creation functions
    typedef VarBase* (*varCreator) (Space*, VarSpec&);

    /// Create a new variable in \a home from \a spec and return it
    GECODE_KERNEL_EXPORT
    VarBase* createVar(Space* home, VarSpec& spec);

    /// Post constraint in \a home for \a spec using variables \a vars
    GECODE_KERNEL_EXPORT
    void post(Space* home, const VarMap& vm, const ActorSpec& spec);

    /// Register variable creation function for variable type identifier \a vti
    GECODE_KERNEL_EXPORT
    void add(int vti, varCreator vc);
    /// Register constraint posting function for constraint name \a id
    GECODE_KERNEL_EXPORT
    void add(const std::string& id, poster p);
    /// Print list of all registered posters to \a out
    GECODE_KERNEL_EXPORT void print(std::ostream& out);
  private:
    /// The registry of constraint posting functions
    std::map<std::string, poster> posters;
    /// The registry of variable creation functions
    std::map<int, varCreator> varCreators;
  };
  
  /// The registry object
  GECODE_KERNEL_EXPORT extern Registry registry;

  /** \brief Class used for registering propagators
    *
    * The registered Propagator class \a P has to provide two functions:
    *  - static std::string name(void)
    *  - static void post(Space*, const VarMap&, const ActorSpec&)
    */
  template <class P>
  class Registrar {
  public:
    /// Default constructor
    Registrar(void);
  };

#define GECODE_REGISTER1(P) \
  ::Gecode::Reflection::Registrar< P > GECODE_FRESH(r);
#define GECODE_REGISTER2(P1,P2) \
  ::Gecode::Reflection::Registrar< P1,P2 > GECODE_FRESH(r);
#define GECODE_REGISTER3(P1,P2,P3) \
  ::Gecode::Reflection::Registrar< P1,P2,P3 > GECODE_FRESH(r);
#define GECODE_REGISTER4(P1,P2,P3,P4) \
  ::Gecode::Reflection::Registrar< P1,P2,P3,P4 > GECODE_FRESH(r);

  /**************************************
   * Implementations
   **************************************/
  
  
  /*
   * Arguments
   *
   */
  
  forceinline bool
  Arg::isInt(void) {
    return (dynamic_cast<IntArg*>(this) != NULL);
  }
  forceinline int
  Arg::toInt(void) {
    return static_cast<IntArg*>(this)->i;
  }

  forceinline bool
  Arg::isVar(void) {
    return (dynamic_cast<VarArg*>(this) != NULL);
  }
  forceinline int
  Arg::toVar(void) {
    return static_cast<VarArg*>(this)->i;
  }

  forceinline bool
  Arg::isArray(void) {
    return (dynamic_cast<ArrayArg*>(this) != NULL);
  }
  forceinline ArrayArg*
  Arg::toArray(void) {
    return static_cast<ArrayArg*>(this);
  }
  forceinline bool
  Arg::isIntArray(void) {
    return (dynamic_cast<IntArrayArg*>(this) != NULL);
  }
  forceinline IntArrayArg*
  Arg::toIntArray(void) {
    return static_cast<IntArrayArg*>(this);
  }

  forceinline bool
  Arg::isString(void) {
    return (dynamic_cast<StringArg*>(this) != NULL);
  }
  forceinline const char*
  Arg::toString(void) {
    return static_cast<StringArg*>(this)->s;
  }

  forceinline bool
  Arg::isPair(void) {
    return (dynamic_cast<PairArg*>(this) != NULL);
  }
  forceinline Arg*
  Arg::first(void) {
    return static_cast<PairArg*>(this)->a;
  }
  forceinline Arg*
  Arg::second(void) {
    return static_cast<PairArg*>(this)->b;
  }

  forceinline bool
  Arg::isTypedArg(void) {
    return (dynamic_cast<TypedArg*>(this) != NULL);    
  }
  forceinline Type*
  Arg::type(void) {
    return static_cast<TypedArg*>(this)->t;
  }
  forceinline Arg*
  Arg::typedArg(void) {
    return static_cast<TypedArg*>(this)->a;
  }


  forceinline
  IntArg::IntArg(int i0) : i(i0) {}

  // forceinline const Arg*&
  // ArrayArg::operator[](int i) const {
  //   assert(i < n);
  //   return a[i];
  // }
  forceinline Arg*&
  ArrayArg::operator[](int i) {
    assert(i < n);
    return a[i];
  }
  forceinline int
  ArrayArg::size(void) const {
    return n;
  }
  forceinline
  ArrayArg::ArrayArg(int n0) : n(n0) {
    a = static_cast<Arg**>(Memory::malloc(sizeof(Arg*)*n));
  }

  forceinline const int&
  IntArrayArg::operator[](int i) const {
    assert(i < n);
    return a[i];
  }
  forceinline int&
  IntArrayArg::operator[](int i) {
    assert(i < n);
    return a[i];
  }
  forceinline int
  IntArrayArg::size(void) const {
    return n;
  }
  forceinline
  IntArrayArg::IntArrayArg(int n0) : n(n0) {
    a = static_cast<int*>(Memory::malloc(sizeof(int)*n));
  }
  template<class A>
  forceinline
  IntArrayArg::IntArrayArg(const A& a0) : n(a0.size()) {
    a = static_cast<int*>(Memory::malloc(sizeof(int)*n));
    for (int i=n; i--;)
      a[i] = a0[i];
  }

  forceinline
  StringArg::StringArg(const char* s0) : s(s0) {}

  forceinline
  PairArg::PairArg(Arg* a0, Arg* b0) : a(a0), b(b0) {}

  forceinline
  VarArg::VarArg(int i0) : i(i0) {}
  
  forceinline
  TypedArg::TypedArg(Type* t0, Arg* a0) : t(t0), a(a0) {}

  template <class View>
  forceinline TypedArg*
  typedSpec(Space* home, VarMap& m, View& v) {
    return new TypedArg(View::type(), v.spec(home, m));
  }

  /*
   * Variable specifications
   *
   */

  forceinline
  VarSpec::Domain::Domain(Arg* domain) : _n(NULL), _dom(domain), r(1) {}

  forceinline
  VarSpec::Domain::~Domain(void) {
    if (_n != NULL)
      Memory::free(_n);
    delete _dom;    
  }

  forceinline
  VarSpec::VarSpec(int vti, Arg* dom) 
  : _vti(vti), _dom(new Domain(dom)) {}

  forceinline
  VarSpec::VarSpec(const VarSpec& s) : _vti(s._vti), _dom(s._dom) {
    _dom->r++;
  }
  
  forceinline const VarSpec&
  VarSpec::operator=(const VarSpec& s) {
    if (this != &s) {
      if (--_dom->r == 0)
        delete _dom;
      _vti = s._vti;
      _dom = s._dom;
      _dom->r++;
    }
    return *this;
  }
  
  forceinline
  VarSpec::~VarSpec(void) {
    if (--_dom->r == 0)
      delete _dom;
  }

  forceinline void
  VarSpec::name(const char* n) {
    if (_dom->_n != NULL)
      Memory::free(_dom->_n);
    int size = strlen(n);
    _dom->_n = static_cast<char*>(Memory::malloc(size+1));
    memcpy(_dom->_n, n, size);
    _dom->_n[size] = 0;
  }

  forceinline const char*
  VarSpec::name(void) const {
    return _dom->_n;
  }

  forceinline int
  VarSpec::vti(void) const {
    return _vti;
  }

  forceinline Arg*
  VarSpec::dom(void) const {
    return _dom->_dom;
  }

  /*
   * Types
   *
   */

  forceinline
  Type::Type(const char* s) : n(0) {
    int size = strlen(s);
    u.n = (char*) Memory::malloc(size+1);
    memcpy(u.n, s, size);
    u.n[size] = 0;
  }
  
  forceinline
  Type::Type(int n0) : n(n0) {
    u.t = static_cast<Type**>(Memory::malloc(sizeof(Type*)*n));
    for (int i=n; i--;)
      u.t[i] = NULL;
  }
  
  forceinline
  Type::~Type(void) {
    if (n>0) {
      for (int i=n; i--;)
        delete u.t[i];
      Memory::free(u.t);
    } else {
      Memory::free(u.n);
    }
  }

  forceinline bool
  Type::primitive(void) const {
    return n == 0;
  }

  forceinline int
  Type::arity(void) const {
    return n;
  }
  
  forceinline Type*
  Type::operator[](int i) const {
    return u.t[i];
  }
  
  forceinline Type*&
  Type::operator[](int i) {
    return u.t[i];
  }

  forceinline const char*
  Type::name(void) const {
    return u.n;
  }


  /*
   * Actor specifications
   *
   */

  forceinline
  ActorSpec::Arguments::Arguments(const char* name)
   :  size(4), n(0), r(1) {
    a = static_cast<Arg**>(Memory::malloc(sizeof(Arg*)*size));
    int size = strlen(name);
    _name = (char*) Memory::malloc(size+1);
    memcpy(_name, name, size);
    _name[size] = 0;
  }

  forceinline
  ActorSpec::Arguments::~Arguments(void) {
    Memory::free(_name);
    for (int i=n; i--;)
      delete a[i];
    Memory::free(a);
  }

  forceinline
  ActorSpec::ActorSpec(const char* name) {
    _args = new Arguments(name);
  }

  forceinline
  ActorSpec::ActorSpec(const ActorSpec& s) : _args(s._args) {
    _args->r++;
  }
  
  forceinline
  const ActorSpec&
  ActorSpec::operator=(const ActorSpec& s) {
    if (this != &s) {
      if (--_args->r == 0)
        delete _args;
      _args = s._args;
      _args->r++;
    }
    return *this;
  }

  forceinline Arg*
  ActorSpec::operator[](int i) const {
    assert(i < _args->n);
    return _args->a[i];
  }

  forceinline int
  ActorSpec::noOfArgs(void) const {
    return _args->n;
  }

  forceinline const char*
  ActorSpec::name(void) const {
    return _args->_name;
  }

  forceinline
  ActorSpec::~ActorSpec(void) {
    if (--_args->r == 0)
      delete _args;
  }

  forceinline void
  ActorSpec::add(Arg* arg) {
    if (_args->n == _args->size) {
      // resize
      _args->size = _args->size * 3 / 2;
      Arg** newargs =
        static_cast<Arg**>(Memory::malloc(sizeof(Arg*)*_args->size));
      for (int i=_args->n; i--;)
        newargs[i] = _args->a[i];
      Memory::free(_args->a);
      _args->a = newargs;
    }
    _args->a[_args->n] = arg;
    _args->n++;
  }

  forceinline
  ActorSpec& operator<<(ActorSpec& spec, Arg* arg) {
    spec.add(arg);
    return spec;
  }
  
  forceinline
  ActorSpec& operator<<(ActorSpec& spec, int i) {
    return spec << new IntArg(i);
  }

  forceinline
  ActorSpec& operator<<(ActorSpec& spec, unsigned int i) {
    return spec << new IntArg(static_cast<int>(i));
  }

  forceinline
  ActorSpec& operator<<(ActorSpec& spec, double i) {
    return spec << new IntArg(static_cast<int>(i));
  }
  
  /*
   * Specification iterator
   *
   */
   
  forceinline bool
  SpecIter::operator()(void) const {
    return cur != &s->a_actors;
  }

  forceinline
  SpecIter::SpecIter(Space* s0, VarMap& m0) : m(m0), s(s0),
    curSpec(NULL) {
    cur = s->a_actors.next();
    if ((*this)())
      curSpec = &static_cast<Actor*>(cur)->spec(s,m);
  }

  forceinline void
  SpecIter::operator++(void) {
    delete curSpec;
    cur = cur->next();
    if ((*this)())
      curSpec = &static_cast<Actor*>(cur)->spec(s,m);
  }

  forceinline ActorSpec&
  SpecIter::actor(void) const {
    return *curSpec;
  }

  /** \brief String representation for View types, used for name mangling
    */
  template <class View>
  class TypeOf {
  public:
    /// Return string representation
    static std::string t(void) { return View::type()->toString(); }
  };
  
  /** \brief String representation for bool, used for name mangling
    */
  template <>
  class TypeOf<bool> {
  public:
    /// Return string representation
    static std::string t(void) { return std::string("bool"); }
  };

  /** \brief String representation for ints, used for name mangling
    */
  template <>
  class TypeOf<int> {
  public:
    /// Return string representation
    static std::string t(void) { return std::string("int"); }
  };

  /** \brief String representation for doubles, used for name mangling
    */
  template <>
  class TypeOf<double> {
  public:
    /// Return string representation
    static std::string t(void) { return std::string("double"); }
  };

}
  class IntSet;
namespace Reflection {

  /** \brief String representation for IntSets, used for name mangling
    */
  template <>
  class TypeOf<const IntSet> {
  public:
    /// Return string representation
    static std::string t(void) { return std::string("IntSet"); }    
  };

  /// Mangle name with type information
  template <class View0>
  forceinline std::string
  mangle(const char* name) {
    return std::string(name) + "<" + std::string(TypeOf<View0>::t())
           + ">";    
  }
  /// Mangle name with type information
  template <class View0, class View1>
  forceinline std::string
  mangle(const char* name) {
    return std::string(name) + "<" + TypeOf<View0>::t()
         + "," + TypeOf<View1>::t() + ">";
  }
  /// Mangle name with type information
  template <class View0, class View1, class View2>
  forceinline std::string
  mangle(const char* name) {
    return std::string(name) + "<" + TypeOf<View0>::t()
         + "," + TypeOf<View1>::t() + ","
         + TypeOf<View2>::t() + ">";
  }
  /// Mangle name with type information
  template <class View0, class View1, class View2, class View3>
  forceinline std::string
  mangle(const char* name) {
    return std::string(name) + "<" + TypeOf<View0>::t()
         + "," + TypeOf<View1>::t() + ","
         + "," + TypeOf<View2>::t() + ","
         + TypeOf<View3>::t() + ">";
  }
  
  template <class P>
  forceinline
  Registrar<P>::Registrar(void) {
    registry.add(P::name(), &P::post);
  }

}}

// STATISTICS: kernel-core
