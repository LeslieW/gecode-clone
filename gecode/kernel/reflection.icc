/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Guido Tack <tack@gecode.org>
 *
 *  Copyright:
 *     Guido Tack, 2007
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  Permission is hereby granted, free of charge, to any person obtaining
 *  a copy of this software and associated documentation files (the
 *  "Software"), to deal in the Software without restriction, including
 *  without limitation the rights to use, copy, modify, merge, publish,
 *  distribute, sublicense, and/or sell copies of the Software, and to
 *  permit persons to whom the Software is furnished to do so, subject to
 *  the following conditions:
 *
 *  The above copyright notice and this permission notice shall be
 *  included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include <iostream>
#include <cstring>

/**
 * \namespace Gecode::Reflection
 * \brief %Reflection support
 */

namespace Gecode { namespace Reflection {
  
  /// Exception for errors during reflection
  class ReflectionException : public Exception {
  public:
    /// Constructor
    ReflectionException(const char* what) : Exception("Reflection", what) {}
  };

  /// Exception: no reflection defined
  class NoReflectionDefinedException : public ReflectionException {
  public:
    NoReflectionDefinedException(void)
    : ReflectionException("No reflection defined") {}
  };
  
  class ArrayArg;
  class IntArrayArg;
  class StringArg;
  
  /**
    * \brief Arguments for actor and variable specifications
    *
    * \ingroup TaskModelReflect
    */
  class GECODE_KERNEL_EXPORT Arg {
  public:
    /// Test if this represents an integer
    bool         isInt(void);
    /// Return the integer that this argument represents
    int          toInt(void);
    /// Test if this represents a variable
    bool         isVar(void);
    /// Return the variable number that this argument represents
    int          toVar(void);
    /// Test if this represents an array
    bool         isArray(void);
    /// Return the array that this argument represents
    ArrayArg*    toArray(void);
    /// Test if this represents an array
    bool         isIntArray(void);
    /// Return the array that this argument represents
    IntArrayArg* toIntArray(void);
    /// Test if this represents a string
    bool         isString(void);
    /// Return the string that this argument represents
    Support::Symbol toString(void);
    /// Test if this represents a pair
    bool         isPair(void);
    /// Return the first component of the pair that this argument represents
    Arg*         first(void);
    /// Return the second component of the pair that this argument represents
    Arg*         second(void);
    /// Destructor
    virtual ~Arg(void);
  };
  
  /**
    * \brief Integer arguments
    * \ingroup TaskModelReflect
    */
  class GECODE_KERNEL_EXPORT IntArg : public Arg {
  public:
    /// Constructor
    IntArg(int i0);
    /// The integer represented by this argument
    int i;
  };

  /**
    * \brief %Variable arguments
    * \ingroup TaskModelReflect
    */
  class GECODE_KERNEL_EXPORT VarArg : public Arg {
  public:
    /// Constructor
    VarArg(int i0);
    /// The variable number represented by this argument
    int i;
  };

  /**
    * \brief Array arguments
    * \ingroup TaskModelReflect
    */
  class GECODE_KERNEL_EXPORT ArrayArg : public Arg {
  private:
    /// Size of the array
    int  n;
    /// The actual array
    Arg** a;
  public:
    /// Constructor
    ArrayArg(int n0);
    /// Destructor
    virtual ~ArrayArg(void);
    
    const Arg* operator[](int i) const;
    Arg*& operator[](int i);
    int size(void) const;
  };

  /**
    * \brief Integer array arguments
    * \ingroup TaskModelReflect
    */
  class GECODE_KERNEL_EXPORT IntArrayArg : public Arg {
  private:
    /// Size of the array
    int  n;
    /// The actual array
    int* a;    
  public:
    /// Constructor
    IntArrayArg(int n0);
    /// Construct from given array \a a
    template <class A> IntArrayArg(const A& a);
    /// Destructor
    virtual ~IntArrayArg(void);
    
    const int& operator[](int i) const;
    int& operator[](int i);
    int size(void) const;
  };

  /**
    * \brief Iterate over an IntArrayArg, interpreting consecutive
    * pairs of integers as ranges
    *
    * \ingroup TaskModelReflect
    */
  class GECODE_KERNEL_EXPORT IntArrayArgRanges {
  private:
    /// The array
    Reflection::IntArrayArg* a;
    /// The current position
    int n;
  public:
    /// Constructor
    IntArrayArgRanges(Reflection::IntArrayArg* a0);
    /// Test whether iterator is still at a valid range
    bool operator()(void);
    /// Move iterator to next range
    void operator++(void);
    /// Minimum of current range
    int min(void) const;
    /// Maximum of current range
    int max(void) const;
    /// Width of current range
    unsigned int width(void) const;
  };

  /**
    * \brief String arguments
    * \ingroup TaskModelReflect
    */
  class GECODE_KERNEL_EXPORT StringArg : public Arg {
  public:
    /// Constructor
    StringArg(const Support::Symbol& s0);
    /// The string represented by this argument
    Support::Symbol s;
  };
  
  /**
    * \brief Pair arguments
    * \ingroup TaskModelReflect
    */
  class GECODE_KERNEL_EXPORT PairArg : public Arg {
  public:
    /// Constructor
    PairArg(Arg* a0, Arg* b0);
    /// Destructor
    virtual ~PairArg(void);
    /// The first component
    Arg* a;
    /// The second component
    Arg* b;
  };
  
  /**
    * \brief %Variable specification
    * \ingroup TaskModelReflect
    */
  class GECODE_KERNEL_EXPORT VarSpec {
  private:
    class Domain;
    /// A representation of the domain of this variable
    Domain* _dom;
  public:
    /// Construct specification for a variable
    VarSpec(Support::Symbol vti, Arg* domain);
    /// Copy constructor
    VarSpec(const VarSpec& s);
    /// Assignment operator
    const VarSpec& operator=(const VarSpec& s);
    /// Destructor
    ~VarSpec(void);
    /// Set the name for this variable
    void name(const Support::Symbol& n0);
    /// Get the name of this variable
    Support::Symbol name(void) const;
    /// Return if variable has a name
    bool hasName(void) const;
    /// Get the domain of this variable
    Arg* dom(void) const;
    // Get the variable type identifier for this variable
    Support::Symbol vti(void) const;
  };
  
  /**
    * \brief %Actor specification
    * \ingroup TaskModelReflect
    */
  class GECODE_KERNEL_EXPORT ActorSpec {
  private:
    class Arguments;
    Arguments* _args;
    /// Resize argument array
    void resize(void);
  public:
    /// Construct actor specification with \a name
    ActorSpec(const Support::Symbol& name);
    /// Copy constructor
    ActorSpec(const ActorSpec& s);
    /// Assignment operator
    const ActorSpec& operator=(const ActorSpec& s);
    /// Destructor
    ~ActorSpec(void);
    
    /// Return argument \a i
    Arg* operator[](int i) const;
    /// Return number of arguments
    int noOfArgs(void) const;
    /// Add \a arg to the specification (as last argument)
    void add(Arg* arg);
    /// Return name
    Support::Symbol name(void) const;
    /// Return if name is not empty
    bool hasName(void) const;

    /// Add \a a to specification \a spec
    ActorSpec& operator<<(Arg* a);
    /// Add \a i to specification \a spec
    ActorSpec& operator<<(int i);
    /// Add \a i to specification \a spec
    ActorSpec& operator<<(unsigned int i);
    /// Add \a d to specification \a spec, where \a d is cast into an integer
    ActorSpec& operator<<(double d);
  };
    
  class VarMap;

  /**
    * \brief Iterating actor specifications
    *
    * Use this iterator to access specifications of all actors (propagators 
    * and branchings) of a space. The iterator also provides access to the
    * corresponding variables map.
    *
    * \ingroup TaskModelReflect
    */
  class GECODE_KERNEL_EXPORT SpecIter {
  private:
    /// The variable map used by this iterator
    VarMap*    m;
    /// The space for which to iterate the actors
    Space*     s;
    /// The current actor
    ActorLink *cur;
    /// The current ActorSpec
    ActorSpec* curSpec;
  public:
    /// Constructor
    SpecIter(Space*, VarMap&);
    /// Test whether iterator still has actor specifications or is done
    bool operator()(void) const;
    /// Move iterator to next actor
    void operator++(void);
    /// Return actor specification for current iterator position
    ActorSpec& actor(void) const;
  };

  /// Registry of constraint posting and variable creation functions
  class GECODE_KERNEL_EXPORT Registry {
  public:
    /// The type of constraint posting functions
    typedef void (*poster) (Space*, const VarMap&, const ActorSpec&);
    /// The type of variable creation functions
    typedef VarBase* (*varCreator) (Space*, VarSpec&);
    /// The type of variable domain constraint functions
    typedef void (*varConstrainer) (Space*, VarBase*, VarSpec&);

    /// Create a new variable in \a home from \a spec and return it
    VarBase* createVar(Space* home, VarSpec& spec);

    /// Constrain \a v to \a spec
    void constrainVar(Space* home, VarBase* v, VarSpec& spec);

    /// Post constraint in \a home for \a spec using variables \a vars
    void post(Space* home, const VarMap& vm, const ActorSpec& spec);

    /// Register variable creation function for \a vti
    void add(Support::Symbol vti, varCreator vc);
    /// Register variable domain constraining function for \a vti
    void add(Support::Symbol vti, varConstrainer vc);
    /// Register constraint posting function for constraint name \a id
    void add(const Support::Symbol& id, poster p);
    /// Print list of all registered posters to \a out
    void print(std::ostream& out);
  private:
    /// The registry of constraint posting functions
    Support::SymbolMap<poster> posters;
    /// The registry of variable creation functions
    Support::SymbolMap<varCreator> varCreators;
    /// The registry of variable creation functions
    Support::SymbolMap<varConstrainer> varConstrainers;
  };
  
  /// The registry object
  GECODE_KERNEL_EXPORT extern Registry registry;

  /** \brief Class used for registering propagators
    *
    * The registered Propagator class \a P has to provide two functions:
    *  - static Support::Symbol name(void)
    *  - static void post(Space*, const VarMap&, const ActorSpec&)
    */
  template <class P>
  class Registrar {
  public:
    /// Default constructor
    Registrar(void);
  };

#define GECODE_REGISTER1(P) \
  ::Gecode::Reflection::Registrar< P > GECODE_FRESH(r);
#define GECODE_REGISTER2(P1,P2) \
  ::Gecode::Reflection::Registrar< P1,P2 > GECODE_FRESH(r);
#define GECODE_REGISTER3(P1,P2,P3) \
  ::Gecode::Reflection::Registrar< P1,P2,P3 > GECODE_FRESH(r);
#define GECODE_REGISTER4(P1,P2,P3,P4) \
  ::Gecode::Reflection::Registrar< P1,P2,P3,P4 > GECODE_FRESH(r);
#define GECODE_REGISTER5(P1,P2,P3,P4,P5) \
  ::Gecode::Reflection::Registrar< P1,P2,P3,P4,P5 > GECODE_FRESH(r);
#define GECODE_REGISTER6(P1,P2,P3,P4,P5,P6) \
  ::Gecode::Reflection::Registrar< P1,P2,P3,P4,P5,P6 > GECODE_FRESH(r);

  /**************************************
   * Implementations
   **************************************/
  

  template<class A>
  IntArrayArg::IntArrayArg(const A& a0) : n(a0.size()) {
    a = static_cast<int*>(Memory::malloc(sizeof(int)*n));
    for (int i=n; i--;)
      a[i] = a0[i];
  }

  
  

  /** \brief String representation for View types, used for name mangling
    */
  template <class View>
  class TypeOf {
  public:
    /// Return string representation
    static Support::Symbol t(void) { return View::type(); }
  };
  
  /** \brief String representation for bool, used for name mangling
    */
  template <>
  class TypeOf<bool> {
  public:
    /// Return string representation
    static Support::Symbol t(void) { return Support::Symbol("bool"); }
  };

  /** \brief String representation for ints, used for name mangling
    */
  template <>
  class TypeOf<int> {
  public:
    /// Return string representation
    static Support::Symbol t(void) { return Support::Symbol("int"); }
  };

  /** \brief String representation for doubles, used for name mangling
    */
  template <>
  class TypeOf<double> {
  public:
    /// Return string representation
    static Support::Symbol t(void) { return Support::Symbol("double"); }
  };

}
  class IntSet;
namespace Reflection {

  /** \brief String representation for IntSets, used for name mangling
    */
  template <>
  class TypeOf<const IntSet> {
  public:
    /// Return string representation
    static Support::Symbol t(void) { return Support::Symbol("IntSet"); }    
  };

  /// Mangle name with type information
  template <class View0>
  Support::Symbol
  mangle(const Support::Symbol& name) {
    Support::Symbol mangled = name.copy();
    mangled += "<";
    mangled += TypeOf<View0>::t();
    mangled += ">";
    return mangled;
  }
  /// Mangle name with type information
  template <class View0, bool b>
  Support::Symbol
  mangle(const Support::Symbol& name) {
    Support::Symbol mangled = name.copy();
    mangled += "<";
    mangled += TypeOf<View0>::t();
    mangled += ",";
    mangled += (b ? "true" : "false");
    mangled += ">";
    return mangled;
  }
  /// Mangle name with type information
  template <class View0, class View1>
  Support::Symbol
  mangle(const Support::Symbol& name) {
    Support::Symbol mangled = name.copy();
    mangled += "<";
    mangled += TypeOf<View0>::t();
    mangled += ",";
    mangled += TypeOf<View1>::t();
    mangled += ">";
    return mangled;
  }
  /// Mangle name with type information
  template <class View0, class View1, bool b>
  Support::Symbol
  mangle(const Support::Symbol& name) {
    Support::Symbol mangled = name.copy();
    mangled += "<";
    mangled += TypeOf<View0>::t();
    mangled += ",";
    mangled += TypeOf<View1>::t();
    mangled += ",";
    mangled += (b ? "true" : "false");
    mangled += ">";
    return mangled;
  }
  /// Mangle name with type information
  template <class View0, class View1, class View2>
  Support::Symbol
  mangle(const Support::Symbol& name) {
    Support::Symbol mangled = name.copy();
    mangled += "<";
    mangled += TypeOf<View0>::t();
    mangled += ",";
    mangled += TypeOf<View1>::t();
    mangled += ",";
    mangled += TypeOf<View2>::t();
    mangled += ">";
    return mangled;
  }
  /// Mangle name with type information
  template <class View0, class View1, class View2, bool b>
  Support::Symbol
  mangle(const Support::Symbol& name) {
    Support::Symbol mangled = name.copy();
    mangled += "<";
    mangled += TypeOf<View0>::t();
    mangled += ",";
    mangled += TypeOf<View1>::t();
    mangled += ",";
    mangled += TypeOf<View2>::t();
    mangled += ",";
    mangled += (b ? "true" : "false");
    mangled += ">";
    return mangled;
  }
  /// Mangle name with type information
  template <class View0, class View1, class View2, class View3>
  Support::Symbol
  mangle(const Support::Symbol& name) {
    Support::Symbol mangled = name.copy();
    mangled += "<";
    mangled += TypeOf<View0>::t();
    mangled += ",";
    mangled += TypeOf<View1>::t();
    mangled += ",";
    mangled += TypeOf<View2>::t();
    mangled += ",";
    mangled += TypeOf<View3>::t();
    mangled += ">";
    return mangled;
  }
  /// Mangle name with type information
  template <class View0, class View1, class View2, class View3, bool b>
  Support::Symbol
  mangle(const Support::Symbol& name) {
    Support::Symbol mangled = name.copy();
    mangled += "<";
    mangled += TypeOf<View0>::t();
    mangled += ",";
    mangled += TypeOf<View1>::t();
    mangled += ",";
    mangled += TypeOf<View2>::t();
    mangled += ",";
    mangled += TypeOf<View3>::t();
    mangled += ",";
    mangled += (b ? "true" : "false");
    mangled += ">";
    return mangled;
  }
  
  template <class P>
  Registrar<P>::Registrar(void) {
    registry.add(P::name(), &P::post);
  }

}}

// STATISTICS: kernel-core
