/*
 *  CAUTION:
 *    This file has been automatically generated. Do not edit,
 *    edit the specification file "variable.vsl" and the following
 *    files instead:
 *     - gecode/int/var-imp-int.vis
 *     - gecode/int/var-imp-bool.vis
 *     - gecode/set/var-imp.vis
 *     - gecode/cpltset/var-imp.vis
 *
 *  This file contains generated code fragments which are
 *  copyrighted as follows:
 *
 *  Main author:
 *     Christian Schulte <schulte@gecode.org>
 *
 *  Copyright:
 *     Christian Schulte, 2007
 *
 *  The generated code fragments are part of Gecode, the generic
 *  constraint development environment:
 *     http://www.gecode.org
 *
 *  Permission is hereby granted, free of charge, to any person obtaining
 *  a copy of this software and associated documentation files (the
 *  "Software"), to deal in the Software without restriction, including
 *  without limitation the rights to use, copy, modify, merge, publish,
 *  distribute, sublicense, and/or sell copies of the Software, and to
 *  permit persons to whom the Software is furnished to do so, subject to
 *  the following conditions:
 *
 *  The above copyright notice and this permission notice shall be
 *  included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#ifdef GECODE_HAVE_INT_VARS
namespace Gecode { namespace Int { 
  /**
   * \defgroup TaskActorIntMEPC Integer modification events and propagation conditions
   * \ingroup TaskActorInt
   */
  //@{
  /// Domain operation has resulted in failure
  const Gecode::ModEvent ME_INT_FAILED = Gecode::ME_GEN_FAILED;
  /// Domain operation has not changed domain
  const Gecode::ModEvent ME_INT_NONE = Gecode::ME_GEN_NONE;
  /// Domain operation has resulted in a value (assigned variable)
  const Gecode::ModEvent ME_INT_VAL = Gecode::ME_GEN_ASSIGNED;
  /** 
   * \brief Domain operation has changed the minimum or maximum of the domain
   *
   * Note that this implies that the domain has not resulted in a value.
   *
   * If a propagator subscribes to this variable, it will be processed
   * assuming a ME_INT_BND modification event.
   */
  const Gecode::ModEvent ME_INT_BND = Gecode::ME_GEN_ASSIGNED + 1;
  /** 
   * \brief Domain operation has changed the domain
   *
   * Note that this implies that the domain has not resulted in a value
   * and that also the minimum and maximum of the domain have not changed.
   */
  const Gecode::ModEvent ME_INT_DOM = Gecode::ME_GEN_ASSIGNED + 2;
  /// Propagation condition to be ignored (convenience)
  const Gecode::PropCond PC_INT_NONE = Gecode::PC_GEN_NONE;
  /**
   * \brief Propagate when a view becomes assigned (single value)
   *
   * If a propagator \a p depends on a view \a x with propagation
   * condition PC_INT_VAL, then \a p is propagated when a domain
   * update operation on \a x returns the modification event ME_INT_VAL.
   */
  const Gecode::PropCond PC_INT_VAL = Gecode::PC_GEN_ASSIGNED;
  /**
   * \brief Propagate when minimum or maximum of a view changes
   *
   * If a propagator \a p depends on a view \a x with propagation
   * condition PC_INT_BND, then \a p is propagated when a domain
   * update operation on \a x returns the modification events ME_INT_VAL
   * or ME_INT_BND.
   */
  const Gecode::PropCond PC_INT_BND = Gecode::PC_GEN_ASSIGNED + 1;
  /**
   * \brief Propagate when domain changes
   *
   * If a propagator \a p depends on a view \a x with propagation
   * condition PC_INT_DOM, then \a p is propagated when a domain
   * update operation on \a x returns the modification event ME_INT_VAL,
   * ME_INT_BND, or ME_INT_DOM.
   */
  const Gecode::PropCond PC_INT_DOM = Gecode::PC_GEN_ASSIGNED + 2;
  //@}
}}
#endif
#ifdef GECODE_HAVE_INT_VARS
namespace Gecode { namespace Int { 
  /**
   * \defgroup TaskActorIntMEPC Integer modification events and propagation conditions
   * \ingroup TaskActorInt
   */
  //@{
  /// Domain operation has resulted in failure
  const Gecode::ModEvent ME_BOOL_FAILED = Gecode::ME_GEN_FAILED;
  /// Domain operation has not changed domain
  const Gecode::ModEvent ME_BOOL_NONE = Gecode::ME_GEN_NONE;
  /// Domain operation has resulted in a value (assigned variable)
  const Gecode::ModEvent ME_BOOL_VAL = Gecode::ME_GEN_ASSIGNED;
  /// Propagation condition to be ignored (convenience)
  const Gecode::PropCond PC_BOOL_NONE = Gecode::PC_GEN_NONE;
  /**
   * \brief Propagate when a view becomes assigned (single value)
   *
   * If a propagator \a p depends on a view \a x with propagation
   * condition PC_BOOL_VAL, then \a p is propagated when a domain
   * update operation on \a x returns the modification event ME_BOOL_VAL.
   */
  const Gecode::PropCond PC_BOOL_VAL = Gecode::PC_GEN_ASSIGNED;
  //@}
}}
#endif
#ifdef GECODE_HAVE_SET_VARS
namespace Gecode { namespace Set { 
  /**
   * \defgroup TaskActorSetMEPC Set modification events and propagation conditions
   * \ingroup TaskActorSet
   */
  //@{
  /// Domain operation has resulted in failure
  const Gecode::ModEvent ME_SET_FAILED = Gecode::ME_GEN_FAILED;
  /// Domain operation has not changed domain
  const Gecode::ModEvent ME_SET_NONE = Gecode::ME_GEN_NONE;
  /// Domain operation has resulted in a value (assigned variable)
  const Gecode::ModEvent ME_SET_VAL = Gecode::ME_GEN_ASSIGNED;
  /**
   * \brief Domain operation has changed the variable cardinality
   *
   * Note that this implies that the domain has not resulted in a value.
   */
  const Gecode::ModEvent ME_SET_CARD = Gecode::ME_GEN_ASSIGNED + 1;
  /**
   * \brief Domain operation has changed the least upper bound
   *
   * Note that this implies that the domain has not resulted in a value
   * and that also neither cardinality nor the greatest lower bound
   * have changed.
   */
  const Gecode::ModEvent ME_SET_LUB = Gecode::ME_GEN_ASSIGNED + 2;
  /**
   * \brief Domain operation has changed the greatest lower bound
   *
   * Note that this implies that the domain has not resulted in a value
   * and that also neither cardinality nor the least upper bound
   * have changed.
   */
  const Gecode::ModEvent ME_SET_GLB = Gecode::ME_GEN_ASSIGNED + 3;
  /**
   * \brief Domain operation has changed both greatest lower and least
   * upper bound
   *
   * Note that this implies that the domain has not resulted in a value
   * and that also the cardinality has not changed.
   */
  const Gecode::ModEvent ME_SET_BB = Gecode::ME_GEN_ASSIGNED + 4;
  /**
   * \brief Domain operation has changed the least upper bound and the cardinality
   *
   * Note that this implies that the domain has not resulted in a value
   * and that also the greatest lower bound has not changed.
   */
  const Gecode::ModEvent ME_SET_CLUB = Gecode::ME_GEN_ASSIGNED + 5;
  /**
   * \brief Domain operation has changed the greatest lower bound and the cardinality
   *
   * Note that this implies that the domain has not resulted in a value
   * and that also the least upper bound has not changed.
   */
  const Gecode::ModEvent ME_SET_CGLB = Gecode::ME_GEN_ASSIGNED + 6;
  /**
   * \brief Domain operation has changed both the greatest lower bound and
   * the least upper bound, as well as the cardinality
   *
   * Note that this implies that the domain has not resulted in a value.
   *
   * If a propagator subscribes to this variable, it will be processed
   * assuming a ME_SET_CBB modification event.
   *
   */
  const Gecode::ModEvent ME_SET_CBB = Gecode::ME_GEN_ASSIGNED + 7;
  /// Propagation condition to be ignored (convenience)
  const Gecode::PropCond PC_SET_NONE = Gecode::PC_GEN_NONE;
  /**
   * \brief Propagate when a view becomes assigned (single value)
   *
   * If a propagator \a p depends on a view \a x with propagation
   * condition PC_SET_VAL, then \a p is propagated when a domain
   * update operation on \a x returns the modification event ME_SET_VAL.
   */
  const Gecode::PropCond PC_SET_VAL = Gecode::PC_GEN_ASSIGNED;
  /**
   * \brief Propagate when the cardinality of a view changes
   *
   * If a propagator \a p depends on a view \a x with propagation
   * condition PC_SET_CARD, then \a p is propagated when a domain
   * update operation on \a x returns the modification event ME_SET_VAL,
   * ME_SET_CARD, ME_SET_CGLB, ME_SET_CLUB, or ME_SET_CBB.
   */
  const Gecode::PropCond PC_SET_CARD = Gecode::PC_GEN_ASSIGNED + 1;
  /**
   * \brief Propagate when the cardinality or the least upper bound
   * of a view changes
   *
   * If a propagator \a p depends on a view \a x with propagation
   * condition PC_SET_CLUB, then \a p is propagated when a domain
   * update operation on \a x returns the modification event ME_SET_VAL,
   * ME_SET_LUB, ME_SET_BB, ME_SET_CARD, ME_SET_CGLB, ME_SET_CLUB,
   * or ME_SET_CBB.
   */
  const Gecode::PropCond PC_SET_CLUB = Gecode::PC_GEN_ASSIGNED + 2;
  /**
   * \brief Propagate when the cardinality or the greatest lower bound
   * of a view changes
   *
   * If a propagator \a p depends on a view \a x with propagation
   * condition PC_SET_CGLB, then \a p is propagated when a domain
   * update operation on \a x returns the modification event ME_SET_VAL,
   * ME_SET_GLB, ME_SET_BB, ME_SET_CARD, ME_SET_CGLB, ME_SET_CLUB,
   * or ME_SET_CBB.
   */
  const Gecode::PropCond PC_SET_CGLB = Gecode::PC_GEN_ASSIGNED + 3;
  /**
   * \brief Propagate when any bound or the cardinality
   * of a view changes
   *
   * If a propagator \a p depends on a view \a x with propagation
   * condition PC_SET_ANY, then \a p is propagated when a domain
   * update operation on \a x returns any modification event but ME_SET_FAILED
   * and ME_SET_NONE.
   */
  const Gecode::PropCond PC_SET_ANY = Gecode::PC_GEN_ASSIGNED + 4;
  //@}
}}
#endif
#ifdef GECODE_HAVE_CPLTSET_VARS
namespace Gecode { namespace CpltSet { 
  /**
   * \defgroup TaskActorCpltSetMEPC CpltSet modification events and propagation conditions
   * \ingroup TaskActorCpltSet
   */
  //@{
  /// Domain operation has resulted in failure
  const Gecode::ModEvent ME_CPLTSET_FAILED = Gecode::ME_GEN_FAILED;
  /// Domain operation has not changed domain
  const Gecode::ModEvent ME_CPLTSET_NONE = Gecode::ME_GEN_NONE;
  /// Domain operation has resulted in a value (assigned variable)
  const Gecode::ModEvent ME_CPLTSET_VAL = Gecode::ME_GEN_ASSIGNED;
  /**
   * \brief Domain operation has modified set
   */
  const Gecode::ModEvent ME_CPLTSET_DOM = Gecode::ME_GEN_ASSIGNED + 1;
  /// Propagation condition to be ignored (convenience)
  const Gecode::PropCond PC_CPLTSET_NONE = Gecode::PC_GEN_NONE;
  /**
   * \brief Propagate when a view becomes assigned (single value)
   *
   * If a propagator \a p depends on a view \a x with propagation
   * condition PC_CPLTSET_VAL, then \a p is propagated when a domain
   * update operation on \a x returns the modification event ME_CPLTSET_VAL.
   */
  const Gecode::PropCond PC_CPLTSET_VAL = Gecode::PC_GEN_ASSIGNED;
 /**
   * \brief Propagate when the domain of a view changes
   *
   * If a propagator \a p depends on a view \a x with propagation
   * condition PC_CPLTSET_DOM, then \a p is propagated when a domain
   * update operation on \a x returns the modification event ME_CPLTSET_VAL or 
   * ME_CPLTSET_DOM.
   */
  const Gecode::PropCond PC_CPLTSET_DOM = Gecode::PC_GEN_ASSIGNED + 1;
  //@}
}}
#endif
#ifdef GECODE_HAVE_INT_VARS
namespace Gecode { namespace Int { 
  /// Configuration class for Int-variable implementations
  class IntVarImpConf {
  public:
    /// Index for update
    static const int idx_u = 0;
    /// Index for disposal
    static const int idx_d = -1;
    /// Maximal propagation condition
    static const Gecode::PropCond pc_max = PC_INT_DOM;
    /// Start of bits for modification event delta
    static const int med_bits_fst = 0;
    /// Number of bits for modification event delta
    static const int me_bits_num = 2;
    /// Bitmask for modification event
    static const int me_bits_mask = (1 << 2) - 1;
    /// End of bits for modification event delta
    static const int med_bits_lst = med_bits_fst + me_bits_num;
    /// Return difference when changing modification event \a me_o to \a me_n
    static Gecode::ModEvent mec(Gecode::ModEvent me_o, Gecode::ModEvent me_n);
    /// Variable type identifier for reflection
    static GECODE_KERNEL_EXPORT const Gecode::Support::Symbol vti;
  };
}}
#else
namespace Gecode { namespace Int { 
  /// Configuration class for Int-variable implementations
  class IntVarImpConf {
  public:
    /// Index for update
    static const int idx_u = -1;
    /// Index for disposal
    static const int idx_d = -1;
    /// End of bits for modification event delta
    static const int med_bits_lst = 0;
  };
}}
#endif
#ifdef GECODE_HAVE_INT_VARS
namespace Gecode { namespace Int { 
  /// Configuration class for Bool-variable implementations
  class BoolVarImpConf {
  public:
    /// Index for update
    static const int idx_u = Gecode::Int::IntVarImpConf::idx_u+1;
    /// Index for disposal
    static const int idx_d = Gecode::Int::IntVarImpConf::idx_d;
    /// Maximal propagation condition
    static const Gecode::PropCond pc_max = PC_BOOL_VAL;
    /// Start of bits for modification event delta
    static const int med_bits_fst = Gecode::Int::IntVarImpConf::med_bits_lst;
    /// Number of bits for modification event delta
    static const int me_bits_num = 1;
    /// Bitmask for modification event
    static const int me_bits_mask = (1 << 1) - 1;
    /// End of bits for modification event delta
    static const int med_bits_lst = med_bits_fst + me_bits_num;
    /// Return difference when changing modification event \a me_o to \a me_n
    static Gecode::ModEvent mec(Gecode::ModEvent me_o, Gecode::ModEvent me_n);
    /// Variable type identifier for reflection
    static GECODE_KERNEL_EXPORT const Gecode::Support::Symbol vti;
  };
}}
#else
namespace Gecode { namespace Int { 
  /// Configuration class for Bool-variable implementations
  class BoolVarImpConf {
  public:
    /// Index for update
    static const int idx_u = Gecode::Int::IntVarImpConf::idx_u;
    /// Index for disposal
    static const int idx_d = Gecode::Int::IntVarImpConf::idx_d;
    /// End of bits for modification event delta
    static const int med_bits_lst = Gecode::Int::IntVarImpConf::med_bits_lst;
  };
}}
#endif
#ifdef GECODE_HAVE_SET_VARS
namespace Gecode { namespace Set { 
  /// Configuration class for Set-variable implementations
  class SetVarImpConf {
  public:
    /// Index for update
    static const int idx_u = Gecode::Int::BoolVarImpConf::idx_u+1;
    /// Index for disposal
    static const int idx_d = Gecode::Int::BoolVarImpConf::idx_d;
    /// Maximal propagation condition
    static const Gecode::PropCond pc_max = PC_SET_ANY;
    /// Start of bits for modification event delta
    static const int med_bits_fst = Gecode::Int::BoolVarImpConf::med_bits_lst;
    /// Number of bits for modification event delta
    static const int me_bits_num = 4;
    /// Bitmask for modification event
    static const int me_bits_mask = (1 << 4) - 1;
    /// End of bits for modification event delta
    static const int med_bits_lst = med_bits_fst + me_bits_num;
    /// Return difference when changing modification event \a me_o to \a me_n
    static Gecode::ModEvent mec(Gecode::ModEvent me_o, Gecode::ModEvent me_n);
    /// Variable type identifier for reflection
    static GECODE_KERNEL_EXPORT const Gecode::Support::Symbol vti;
  };
}}
#else
namespace Gecode { namespace Set { 
  /// Configuration class for Set-variable implementations
  class SetVarImpConf {
  public:
    /// Index for update
    static const int idx_u = Gecode::Int::BoolVarImpConf::idx_u;
    /// Index for disposal
    static const int idx_d = Gecode::Int::BoolVarImpConf::idx_d;
    /// End of bits for modification event delta
    static const int med_bits_lst = Gecode::Int::BoolVarImpConf::med_bits_lst;
  };
}}
#endif
#ifdef GECODE_HAVE_CPLTSET_VARS

#ifndef GECODE_HAVE_VAR_DISPOSE
#define GECODE_HAVE_VAR_DISPOSE 1
#endif

namespace Gecode { namespace CpltSet { 
  /// Configuration class for CpltSet-variable implementations
  class CpltSetVarImpConf {
  public:
    /// Index for update
    static const int idx_u = Gecode::Set::SetVarImpConf::idx_u+1;
    /// Index for disposal
    static const int idx_d = Gecode::Set::SetVarImpConf::idx_d+1;
    /// Maximal propagation condition
    static const Gecode::PropCond pc_max = PC_CPLTSET_DOM;
    /// Start of bits for modification event delta
    static const int med_bits_fst = Gecode::Set::SetVarImpConf::med_bits_lst;
    /// Number of bits for modification event delta
    static const int me_bits_num = 2;
    /// Bitmask for modification event
    static const int me_bits_mask = (1 << 2) - 1;
    /// End of bits for modification event delta
    static const int med_bits_lst = med_bits_fst + me_bits_num;
    /// Return difference when changing modification event \a me_o to \a me_n
    static Gecode::ModEvent mec(Gecode::ModEvent me_o, Gecode::ModEvent me_n);
    /// Variable type identifier for reflection
    static GECODE_KERNEL_EXPORT const Gecode::Support::Symbol vti;
  };
}}
#else
namespace Gecode { namespace CpltSet { 
  /// Configuration class for CpltSet-variable implementations
  class CpltSetVarImpConf {
  public:
    /// Index for update
    static const int idx_u = Gecode::Set::SetVarImpConf::idx_u;
    /// Index for disposal
    static const int idx_d = Gecode::Set::SetVarImpConf::idx_d;
    /// End of bits for modification event delta
    static const int med_bits_lst = Gecode::Set::SetVarImpConf::med_bits_lst;
  };
}}
#endif

namespace Gecode {

  /// Configuration class for all variable implementations
  class AllVarConf {
  public:
    /// Index for update
    static const int idx_u = Gecode::CpltSet::CpltSetVarImpConf::idx_u+1;
    /// Index for dispose
    static const int idx_d = Gecode::CpltSet::CpltSetVarImpConf::idx_d+1;
    /// Return difference when changing modification event delta \a med_o to \a med_n
    static ModEventDelta medc(ModEventDelta med_o, ModEventDelta med_n);
  };

}

#ifdef GECODE_HAVE_INT_VARS
namespace Gecode { namespace Int { 
  forceinline Gecode::ModEvent
  IntVarImpConf::mec(Gecode::ModEvent me_o, Gecode::ModEvent me_n) {
    const int med = (
      (
        ((ME_INT_NONE ^ ME_INT_NONE) << 0) |  // [ME_INT_NONE][ME_INT_NONE]
        ((ME_INT_VAL ^ ME_INT_VAL) << 2) |  // [ME_INT_NONE][ME_INT_VAL]
        ((ME_INT_BND ^ ME_INT_BND) << 4) |  // [ME_INT_NONE][ME_INT_BND]
        ((ME_INT_DOM ^ ME_INT_DOM) << 6)    // [ME_INT_NONE][ME_INT_DOM]
      ) |
      (
        ((ME_INT_NONE ^ ME_INT_VAL) << 8) |  // [ME_INT_VAL][ME_INT_NONE]
        ((ME_INT_VAL ^ ME_INT_VAL) << 10) |  // [ME_INT_VAL][ME_INT_VAL]
        ((ME_INT_BND ^ ME_INT_VAL) << 12) |  // [ME_INT_VAL][ME_INT_BND]
        ((ME_INT_DOM ^ ME_INT_VAL) << 14)    // [ME_INT_VAL][ME_INT_DOM]
      ) |
      (
        ((ME_INT_NONE ^ ME_INT_BND) << 16) |  // [ME_INT_BND][ME_INT_NONE]
        ((ME_INT_VAL ^ ME_INT_VAL) << 18) |  // [ME_INT_BND][ME_INT_VAL]
        ((ME_INT_BND ^ ME_INT_BND) << 20) |  // [ME_INT_BND][ME_INT_BND]
        ((ME_INT_DOM ^ ME_INT_BND) << 22)    // [ME_INT_BND][ME_INT_DOM]
      ) |
      (
        ((ME_INT_NONE ^ ME_INT_DOM) << 24) |  // [ME_INT_DOM][ME_INT_NONE]
        ((ME_INT_VAL ^ ME_INT_VAL) << 26) |  // [ME_INT_DOM][ME_INT_VAL]
        ((ME_INT_BND ^ ME_INT_BND) << 28) |  // [ME_INT_DOM][ME_INT_BND]
        ((ME_INT_DOM ^ ME_INT_DOM) << 30)    // [ME_INT_DOM][ME_INT_DOM]
      )
    );
    return (((med >> (me_n << 3)) >> (me_o << 1)) & 3);
  }

}}
#endif
#ifdef GECODE_HAVE_INT_VARS
namespace Gecode { namespace Int { 
  forceinline Gecode::ModEvent
  BoolVarImpConf::mec(Gecode::ModEvent me_o, Gecode::ModEvent me_n) {
    return !me_o & me_n;
  }

}}
#endif
#ifdef GECODE_HAVE_SET_VARS
namespace Gecode { namespace Set { 
  forceinline Gecode::ModEvent
  SetVarImpConf::mec(Gecode::ModEvent me_o, Gecode::ModEvent me_n) {
    static const unsigned char med[ME_SET_CBB+1][ME_SET_CBB+1] = {
      {
        ME_SET_NONE ^ ME_SET_NONE, // [ME_SET_NONE][ME_SET_NONE]
        ME_SET_VAL ^ ME_SET_VAL, // [ME_SET_NONE][ME_SET_VAL]
        ME_SET_CARD ^ ME_SET_CARD, // [ME_SET_NONE][ME_SET_CARD]
        ME_SET_LUB ^ ME_SET_LUB, // [ME_SET_NONE][ME_SET_LUB]
        ME_SET_GLB ^ ME_SET_GLB, // [ME_SET_NONE][ME_SET_GLB]
        ME_SET_BB ^ ME_SET_BB, // [ME_SET_NONE][ME_SET_BB]
        ME_SET_CLUB ^ ME_SET_CLUB, // [ME_SET_NONE][ME_SET_CLUB]
        ME_SET_CGLB ^ ME_SET_CGLB, // [ME_SET_NONE][ME_SET_CGLB]
        ME_SET_CBB ^ ME_SET_CBB  // [ME_SET_NONE][ME_SET_CBB]
      },
      {
        ME_SET_NONE ^ ME_SET_VAL, // [ME_SET_VAL][ME_SET_NONE]
        ME_SET_VAL ^ ME_SET_VAL, // [ME_SET_VAL][ME_SET_VAL]
        ME_SET_CARD ^ ME_SET_VAL, // [ME_SET_VAL][ME_SET_CARD]
        ME_SET_LUB ^ ME_SET_VAL, // [ME_SET_VAL][ME_SET_LUB]
        ME_SET_GLB ^ ME_SET_VAL, // [ME_SET_VAL][ME_SET_GLB]
        ME_SET_BB ^ ME_SET_VAL, // [ME_SET_VAL][ME_SET_BB]
        ME_SET_CLUB ^ ME_SET_VAL, // [ME_SET_VAL][ME_SET_CLUB]
        ME_SET_CGLB ^ ME_SET_VAL, // [ME_SET_VAL][ME_SET_CGLB]
        ME_SET_CBB ^ ME_SET_VAL  // [ME_SET_VAL][ME_SET_CBB]
      },
      {
        ME_SET_NONE ^ ME_SET_CARD, // [ME_SET_CARD][ME_SET_NONE]
        ME_SET_VAL ^ ME_SET_VAL, // [ME_SET_CARD][ME_SET_VAL]
        ME_SET_CARD ^ ME_SET_CARD, // [ME_SET_CARD][ME_SET_CARD]
        ME_SET_LUB ^ ME_SET_CLUB, // [ME_SET_CARD][ME_SET_LUB]
        ME_SET_GLB ^ ME_SET_CGLB, // [ME_SET_CARD][ME_SET_GLB]
        ME_SET_BB ^ ME_SET_CBB, // [ME_SET_CARD][ME_SET_BB]
        ME_SET_CLUB ^ ME_SET_CLUB, // [ME_SET_CARD][ME_SET_CLUB]
        ME_SET_CGLB ^ ME_SET_CGLB, // [ME_SET_CARD][ME_SET_CGLB]
        ME_SET_CBB ^ ME_SET_CBB  // [ME_SET_CARD][ME_SET_CBB]
      },
      {
        ME_SET_NONE ^ ME_SET_LUB, // [ME_SET_LUB][ME_SET_NONE]
        ME_SET_VAL ^ ME_SET_VAL, // [ME_SET_LUB][ME_SET_VAL]
        ME_SET_CARD ^ ME_SET_CLUB, // [ME_SET_LUB][ME_SET_CARD]
        ME_SET_LUB ^ ME_SET_LUB, // [ME_SET_LUB][ME_SET_LUB]
        ME_SET_GLB ^ ME_SET_BB, // [ME_SET_LUB][ME_SET_GLB]
        ME_SET_BB ^ ME_SET_BB, // [ME_SET_LUB][ME_SET_BB]
        ME_SET_CLUB ^ ME_SET_CLUB, // [ME_SET_LUB][ME_SET_CLUB]
        ME_SET_CGLB ^ ME_SET_CBB, // [ME_SET_LUB][ME_SET_CGLB]
        ME_SET_CBB ^ ME_SET_CBB  // [ME_SET_LUB][ME_SET_CBB]
      },
      {
        ME_SET_NONE ^ ME_SET_GLB, // [ME_SET_GLB][ME_SET_NONE]
        ME_SET_VAL ^ ME_SET_VAL, // [ME_SET_GLB][ME_SET_VAL]
        ME_SET_CARD ^ ME_SET_CGLB, // [ME_SET_GLB][ME_SET_CARD]
        ME_SET_LUB ^ ME_SET_BB, // [ME_SET_GLB][ME_SET_LUB]
        ME_SET_GLB ^ ME_SET_GLB, // [ME_SET_GLB][ME_SET_GLB]
        ME_SET_BB ^ ME_SET_BB, // [ME_SET_GLB][ME_SET_BB]
        ME_SET_CLUB ^ ME_SET_CBB, // [ME_SET_GLB][ME_SET_CLUB]
        ME_SET_CGLB ^ ME_SET_CGLB, // [ME_SET_GLB][ME_SET_CGLB]
        ME_SET_CBB ^ ME_SET_CBB  // [ME_SET_GLB][ME_SET_CBB]
      },
      {
        ME_SET_NONE ^ ME_SET_BB, // [ME_SET_BB][ME_SET_NONE]
        ME_SET_VAL ^ ME_SET_VAL, // [ME_SET_BB][ME_SET_VAL]
        ME_SET_CARD ^ ME_SET_CBB, // [ME_SET_BB][ME_SET_CARD]
        ME_SET_LUB ^ ME_SET_BB, // [ME_SET_BB][ME_SET_LUB]
        ME_SET_GLB ^ ME_SET_BB, // [ME_SET_BB][ME_SET_GLB]
        ME_SET_BB ^ ME_SET_BB, // [ME_SET_BB][ME_SET_BB]
        ME_SET_CLUB ^ ME_SET_CBB, // [ME_SET_BB][ME_SET_CLUB]
        ME_SET_CGLB ^ ME_SET_CBB, // [ME_SET_BB][ME_SET_CGLB]
        ME_SET_CBB ^ ME_SET_CBB  // [ME_SET_BB][ME_SET_CBB]
      },
      {
        ME_SET_NONE ^ ME_SET_CLUB, // [ME_SET_CLUB][ME_SET_NONE]
        ME_SET_VAL ^ ME_SET_VAL, // [ME_SET_CLUB][ME_SET_VAL]
        ME_SET_CARD ^ ME_SET_CLUB, // [ME_SET_CLUB][ME_SET_CARD]
        ME_SET_LUB ^ ME_SET_CLUB, // [ME_SET_CLUB][ME_SET_LUB]
        ME_SET_GLB ^ ME_SET_CBB, // [ME_SET_CLUB][ME_SET_GLB]
        ME_SET_BB ^ ME_SET_CBB, // [ME_SET_CLUB][ME_SET_BB]
        ME_SET_CLUB ^ ME_SET_CLUB, // [ME_SET_CLUB][ME_SET_CLUB]
        ME_SET_CGLB ^ ME_SET_CBB, // [ME_SET_CLUB][ME_SET_CGLB]
        ME_SET_CBB ^ ME_SET_CBB  // [ME_SET_CLUB][ME_SET_CBB]
      },
      {
        ME_SET_NONE ^ ME_SET_CGLB, // [ME_SET_CGLB][ME_SET_NONE]
        ME_SET_VAL ^ ME_SET_VAL, // [ME_SET_CGLB][ME_SET_VAL]
        ME_SET_CARD ^ ME_SET_CGLB, // [ME_SET_CGLB][ME_SET_CARD]
        ME_SET_LUB ^ ME_SET_CBB, // [ME_SET_CGLB][ME_SET_LUB]
        ME_SET_GLB ^ ME_SET_CGLB, // [ME_SET_CGLB][ME_SET_GLB]
        ME_SET_BB ^ ME_SET_CBB, // [ME_SET_CGLB][ME_SET_BB]
        ME_SET_CLUB ^ ME_SET_CBB, // [ME_SET_CGLB][ME_SET_CLUB]
        ME_SET_CGLB ^ ME_SET_CGLB, // [ME_SET_CGLB][ME_SET_CGLB]
        ME_SET_CBB ^ ME_SET_CBB  // [ME_SET_CGLB][ME_SET_CBB]
      },
      {
        ME_SET_NONE ^ ME_SET_CBB, // [ME_SET_CBB][ME_SET_NONE]
        ME_SET_VAL ^ ME_SET_VAL, // [ME_SET_CBB][ME_SET_VAL]
        ME_SET_CARD ^ ME_SET_CBB, // [ME_SET_CBB][ME_SET_CARD]
        ME_SET_LUB ^ ME_SET_CBB, // [ME_SET_CBB][ME_SET_LUB]
        ME_SET_GLB ^ ME_SET_CBB, // [ME_SET_CBB][ME_SET_GLB]
        ME_SET_BB ^ ME_SET_CBB, // [ME_SET_CBB][ME_SET_BB]
        ME_SET_CLUB ^ ME_SET_CBB, // [ME_SET_CBB][ME_SET_CLUB]
        ME_SET_CGLB ^ ME_SET_CBB, // [ME_SET_CBB][ME_SET_CGLB]
        ME_SET_CBB ^ ME_SET_CBB  // [ME_SET_CBB][ME_SET_CBB]
      }
    };
    return static_cast<Gecode::ModEvent>(med[me_n][me_o]);
  }

}}
#endif
#ifdef GECODE_HAVE_CPLTSET_VARS
namespace Gecode { namespace CpltSet { 
  forceinline Gecode::ModEvent
  CpltSetVarImpConf::mec(Gecode::ModEvent me_o, Gecode::ModEvent me_n) {
    const int med = (
      (
        ((ME_CPLTSET_NONE ^ ME_CPLTSET_NONE) << 0) |  // [ME_CPLTSET_NONE][ME_CPLTSET_NONE]
        ((ME_CPLTSET_VAL ^ ME_CPLTSET_VAL) << 2) |  // [ME_CPLTSET_NONE][ME_CPLTSET_VAL]
        ((ME_CPLTSET_DOM ^ ME_CPLTSET_DOM) << 4)    // [ME_CPLTSET_NONE][ME_CPLTSET_DOM]
      ) |
      (
        ((ME_CPLTSET_NONE ^ ME_CPLTSET_VAL) << 8) |  // [ME_CPLTSET_VAL][ME_CPLTSET_NONE]
        ((ME_CPLTSET_VAL ^ ME_CPLTSET_VAL) << 10) |  // [ME_CPLTSET_VAL][ME_CPLTSET_VAL]
        ((ME_CPLTSET_DOM ^ ME_CPLTSET_VAL) << 12)    // [ME_CPLTSET_VAL][ME_CPLTSET_DOM]
      ) |
      (
        ((ME_CPLTSET_NONE ^ ME_CPLTSET_DOM) << 16) |  // [ME_CPLTSET_DOM][ME_CPLTSET_NONE]
        ((ME_CPLTSET_VAL ^ ME_CPLTSET_VAL) << 18) |  // [ME_CPLTSET_DOM][ME_CPLTSET_VAL]
        ((ME_CPLTSET_DOM ^ ME_CPLTSET_DOM) << 20)    // [ME_CPLTSET_DOM][ME_CPLTSET_DOM]
      )
    );
    return (((med >> (me_n << 3)) >> (me_o << 1)) & 3);
  }

}}
#endif
namespace Gecode {
  forceinline ModEventDelta
  AllVarConf::medc(ModEventDelta med_o, ModEventDelta med_n) {
    ModEventDelta med_c = 0;
#ifdef GECODE_HAVE_INT_VARS
    {
      // Compute the old modification event
      ModEvent me_o = (med_o >> Gecode::Int::IntVarImpConf::med_bits_fst) & Gecode::Int::IntVarImpConf::me_bits_mask;
      // Compute the new modification event
      ModEvent me_n = (med_n >> Gecode::Int::IntVarImpConf::med_bits_fst) & Gecode::Int::IntVarImpConf::me_bits_mask;
      // Compute combined event
      ModEvent me_c = Gecode::Int::IntVarImpConf::mec(me_o,me_n);
      // Add combined event
      med_c |= me_c << Gecode::Int::IntVarImpConf::med_bits_fst;
    }
#endif
#ifdef GECODE_HAVE_INT_VARS
    {
      // Compute the old modification event
      ModEvent me_o = (med_o >> Gecode::Int::BoolVarImpConf::med_bits_fst) & Gecode::Int::BoolVarImpConf::me_bits_mask;
      // Compute the new modification event
      ModEvent me_n = (med_n >> Gecode::Int::BoolVarImpConf::med_bits_fst) & Gecode::Int::BoolVarImpConf::me_bits_mask;
      // Compute combined event
      ModEvent me_c = Gecode::Int::BoolVarImpConf::mec(me_o,me_n);
      // Add combined event
      med_c |= me_c << Gecode::Int::BoolVarImpConf::med_bits_fst;
    }
#endif
#ifdef GECODE_HAVE_SET_VARS
    {
      // Compute the old modification event
      ModEvent me_o = (med_o >> Gecode::Set::SetVarImpConf::med_bits_fst) & Gecode::Set::SetVarImpConf::me_bits_mask;
      // Compute the new modification event
      ModEvent me_n = (med_n >> Gecode::Set::SetVarImpConf::med_bits_fst) & Gecode::Set::SetVarImpConf::me_bits_mask;
      // Compute combined event
      ModEvent me_c = Gecode::Set::SetVarImpConf::mec(me_o,me_n);
      // Add combined event
      med_c |= me_c << Gecode::Set::SetVarImpConf::med_bits_fst;
    }
#endif
#ifdef GECODE_HAVE_CPLTSET_VARS
    {
      // Compute the old modification event
      ModEvent me_o = (med_o >> Gecode::CpltSet::CpltSetVarImpConf::med_bits_fst) & Gecode::CpltSet::CpltSetVarImpConf::me_bits_mask;
      // Compute the new modification event
      ModEvent me_n = (med_n >> Gecode::CpltSet::CpltSetVarImpConf::med_bits_fst) & Gecode::CpltSet::CpltSetVarImpConf::me_bits_mask;
      // Compute combined event
      ModEvent me_c = Gecode::CpltSet::CpltSetVarImpConf::mec(me_o,me_n);
      // Add combined event
      med_c |= me_c << Gecode::CpltSet::CpltSetVarImpConf::med_bits_fst;
    }
#endif
    return med_c;
  }
}

// STATISTICS: kernel-var
