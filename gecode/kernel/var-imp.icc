/*
 *  CAUTION:
 *    This file has been automatically generated. Do not edit,
 *    edit the specification file "variable.vsl" instead.
 *
 *  This file contains generated code fragments which are
 *  copyrighted as follows:
 *
 *  Main author:
 *     Christian Schulte <schulte@gecode.org>
 *
 *  Copyright:
 *     Christian Schulte, 2007
 *
 *  The generated code fragments are part of Gecode, the generic
 *  constraint development environment:
 *     http://www.gecode.org
 *
 *  Permission is hereby granted, free of charge, to any person obtaining
 *  a copy of this software and associated documentation files (the
 *  "Software"), to deal in the Software without restriction, including
 *  without limitation the rights to use, copy, modify, merge, publish,
 *  distribute, sublicense, and/or sell copies of the Software, and to
 *  permit persons to whom the Software is furnished to do so, subject to
 *  the following conditions:
 *
 *  The above copyright notice and this permission notice shall be
 *  included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#ifdef GECODE_HAVE_INT_VARS
namespace Gecode { namespace Int { 
  /// Base-class for Int-variable implementations
  class IntVarImpBase : public Gecode::VarImp<Gecode::Int::IntVarImpConf> {
  protected:
    /// Constructor for cloning \a x
    IntVarImpBase(Space* home, bool share, IntVarImpBase& x);
  public:
    /// Constructor for creating static instance of variable
    IntVarImpBase(void);
    /// Constructor for creating variable
    IntVarImpBase(Space* home);
    /// \name Dependencies
    //@{
    /** \brief Subscribe propagator \a p with propagation condition \a pc to variable
     *
     * In case \a process is false, the propagator is just subscribed but
     * not processed for execution (this must be used when creating
     * subscriptions during propagation).
     *
     * In case the variable is assigned (that is, \a assigned is 
     * true), the subscribing propagator is processed for execution.
     * Otherwise, the propagator subscribes and is processed for execution
     * with modification event \a me provided that \a pc is different
     * from \a PC_GEN_ASSIGNED.
     */
    void subscribe(Space* home, Propagator* p, PropCond pc, bool assigned, bool process);
    /// Subscribe advisor \a a
    void subscribe(Space* home, Advisor* a, bool assigned);
    /// Notify that variable implementation has been modified with modification event \a me and delta information \a d
    ModEvent notify(Space* home, ModEvent me, Delta* d);
    //@}

  };


  forceinline
  IntVarImpBase::IntVarImpBase(void) {}

  forceinline
  IntVarImpBase::IntVarImpBase(Space* home)
    : Gecode::VarImp<Gecode::Int::IntVarImpConf>(home) {}

  forceinline
  IntVarImpBase::IntVarImpBase(Space* home, bool share, IntVarImpBase& x)
    : Gecode::VarImp<Gecode::Int::IntVarImpConf>(home,share,x) {}

  forceinline void
  IntVarImpBase::subscribe(Space* home, Propagator* p, PropCond pc, bool assigned, bool process) {
    Gecode::VarImp<Gecode::Int::IntVarImpConf>::subscribe(home,p,pc,assigned,ME_INT_BND,process);
  }
  forceinline void
  IntVarImpBase::subscribe(Space* home, Advisor* a, bool assigned) {
    Gecode::VarImp<Gecode::Int::IntVarImpConf>::subscribe(home,a,assigned);
  }

  forceinline ModEvent
  IntVarImpBase::notify(Space* home, ModEvent me, Delta* d) {
    if (me_failed(Gecode::VarImp<Gecode::Int::IntVarImpConf>::notify(home,me,d)))
      return ME_GEN_FAILED;
    switch (me) {
    case ME_INT_VAL:
      process(home);
      break;
    case ME_INT_BND:
      // Conditions: BND DOM 
      process(home,PC_INT_BND,PC_INT_DOM,ME_INT_BND);
      break;
    case ME_INT_DOM:
      // Conditions: DOM 
      process(home,PC_INT_DOM,PC_INT_DOM,ME_INT_DOM);
      break;
    default: GECODE_NEVER;
    }
    return me;
  }
}}
#endif
#ifdef GECODE_HAVE_INT_VARS
namespace Gecode { namespace Int { 
  /// Base-class for Bool-variable implementations
  class BoolVarImpBase : public Gecode::VarImp<Gecode::Int::BoolVarImpConf> {
  protected:
    /// Constructor for cloning \a x
    BoolVarImpBase(Space* home, bool share, BoolVarImpBase& x);
  public:
    /// Constructor for creating static instance of variable
    BoolVarImpBase(void);
    /// Constructor for creating variable
    BoolVarImpBase(Space* home);
    /// \name Dependencies
    //@{
    /** \brief Subscribe propagator \a p with propagation condition \a pc to variable
     *
     * In case \a process is false, the propagator is just subscribed but
     * not processed for execution (this must be used when creating
     * subscriptions during propagation).
     *
     * In case the variable is assigned (that is, \a assigned is 
     * true), the subscribing propagator is processed for execution.
     * Otherwise, the propagator subscribes and is processed for execution
     * with modification event \a me provided that \a pc is different
     * from \a PC_GEN_ASSIGNED.
     */
    void subscribe(Space* home, Propagator* p, PropCond pc, bool assigned, bool process);
    /// Subscribe advisor \a a
    void subscribe(Space* home, Advisor* a, bool assigned);
    /// Notify that variable implementation has been modified with modification event \a me and delta information \a d
    ModEvent notify(Space* home, ModEvent me, Delta* d);
    //@}

  };


  forceinline
  BoolVarImpBase::BoolVarImpBase(void) {}

  forceinline
  BoolVarImpBase::BoolVarImpBase(Space* home)
    : Gecode::VarImp<Gecode::Int::BoolVarImpConf>(home) {}

  forceinline
  BoolVarImpBase::BoolVarImpBase(Space* home, bool share, BoolVarImpBase& x)
    : Gecode::VarImp<Gecode::Int::BoolVarImpConf>(home,share,x) {}

  forceinline void
  BoolVarImpBase::subscribe(Space* home, Propagator* p, PropCond pc, bool assigned, bool process) {
    Gecode::VarImp<Gecode::Int::BoolVarImpConf>::subscribe(home,p,pc,assigned,ME_BOOL_VAL,process);
  }
  forceinline void
  BoolVarImpBase::subscribe(Space* home, Advisor* a, bool assigned) {
    Gecode::VarImp<Gecode::Int::BoolVarImpConf>::subscribe(home,a,assigned);
  }

  forceinline ModEvent
  BoolVarImpBase::notify(Space* home, ModEvent me, Delta* d) {
    if (me_failed(Gecode::VarImp<Gecode::Int::BoolVarImpConf>::notify(home,me,d)))
      return ME_GEN_FAILED;
    process(home);
    return me;
  }

}}
#endif
#ifdef GECODE_HAVE_SET_VARS
namespace Gecode { namespace Set { 
  /// Base-class for Set-variable implementations
  class SetVarImpBase : public Gecode::VarImp<Gecode::Set::SetVarImpConf> {
  protected:
    /// Constructor for cloning \a x
    SetVarImpBase(Space* home, bool share, SetVarImpBase& x);
  public:
    /// Constructor for creating static instance of variable
    SetVarImpBase(void);
    /// Constructor for creating variable
    SetVarImpBase(Space* home);
    /// \name Dependencies
    //@{
    /** \brief Subscribe propagator \a p with propagation condition \a pc to variable
     *
     * In case \a process is false, the propagator is just subscribed but
     * not processed for execution (this must be used when creating
     * subscriptions during propagation).
     *
     * In case the variable is assigned (that is, \a assigned is 
     * true), the subscribing propagator is processed for execution.
     * Otherwise, the propagator subscribes and is processed for execution
     * with modification event \a me provided that \a pc is different
     * from \a PC_GEN_ASSIGNED.
     */
    void subscribe(Space* home, Propagator* p, PropCond pc, bool assigned, bool process);
    /// Subscribe advisor \a a
    void subscribe(Space* home, Advisor* a, bool assigned);
    /// Notify that variable implementation has been modified with modification event \a me and delta information \a d
    ModEvent notify(Space* home, ModEvent me, Delta* d);
    //@}

  };


  forceinline
  SetVarImpBase::SetVarImpBase(void) {}

  forceinline
  SetVarImpBase::SetVarImpBase(Space* home)
    : Gecode::VarImp<Gecode::Set::SetVarImpConf>(home) {}

  forceinline
  SetVarImpBase::SetVarImpBase(Space* home, bool share, SetVarImpBase& x)
    : Gecode::VarImp<Gecode::Set::SetVarImpConf>(home,share,x) {}

  forceinline void
  SetVarImpBase::subscribe(Space* home, Propagator* p, PropCond pc, bool assigned, bool process) {
    Gecode::VarImp<Gecode::Set::SetVarImpConf>::subscribe(home,p,pc,assigned,ME_SET_CBB,process);
  }
  forceinline void
  SetVarImpBase::subscribe(Space* home, Advisor* a, bool assigned) {
    Gecode::VarImp<Gecode::Set::SetVarImpConf>::subscribe(home,a,assigned);
  }

  forceinline ModEvent
  SetVarImpBase::notify(Space* home, ModEvent me, Delta* d) {
    if (me_failed(Gecode::VarImp<Gecode::Set::SetVarImpConf>::notify(home,me,d)))
      return ME_GEN_FAILED;
    switch (me) {
    case ME_SET_VAL:
      process(home);
      break;
    case ME_SET_CARD:
      // Conditions: CARD CLUB CGLB ANY 
      process(home,PC_SET_CARD,PC_SET_ANY,ME_SET_CARD);
      break;
    case ME_SET_LUB:
      // Conditions: CLUB ANY 
      process(home,PC_SET_CLUB,PC_SET_CLUB,ME_SET_LUB);
      process(home,PC_SET_ANY,PC_SET_ANY,ME_SET_LUB);
      break;
    case ME_SET_GLB:
      // Conditions: CGLB ANY 
      process(home,PC_SET_CGLB,PC_SET_ANY,ME_SET_GLB);
      break;
    case ME_SET_BB:
      // Conditions: CLUB CGLB ANY 
      process(home,PC_SET_CLUB,PC_SET_ANY,ME_SET_BB);
      break;
    case ME_SET_CLUB:
      // Conditions: CARD CLUB CGLB ANY 
      process(home,PC_SET_CARD,PC_SET_ANY,ME_SET_CLUB);
      break;
    case ME_SET_CGLB:
      // Conditions: CARD CLUB CGLB ANY 
      process(home,PC_SET_CARD,PC_SET_ANY,ME_SET_CGLB);
      break;
    case ME_SET_CBB:
      // Conditions: CARD CLUB CGLB ANY 
      process(home,PC_SET_CARD,PC_SET_ANY,ME_SET_CBB);
      break;
    default: GECODE_NEVER;
    }
    return me;
  }
}}
#endif
#ifdef GECODE_HAVE_CPLTSET_VARS
namespace Gecode { namespace CpltSet { 
  /// Base-class for CpltSet-variable implementations
  class CpltSetVarImpBase : public Gecode::VarImp<Gecode::CpltSet::CpltSetVarImpConf> {
  private:
    /// Link to next variable, used for disposal
    CpltSetVarImpBase* _next_d;
  protected:
    /// Constructor for cloning \a x
    CpltSetVarImpBase(Space* home, bool share, CpltSetVarImpBase& x);
  public:
    /// Constructor for creating static instance of variable
    CpltSetVarImpBase(void);
    /// Constructor for creating variable
    CpltSetVarImpBase(Space* home);
    /// \name Dependencies
    //@{
    /** \brief Subscribe propagator \a p with propagation condition \a pc to variable
     *
     * In case \a process is false, the propagator is just subscribed but
     * not processed for execution (this must be used when creating
     * subscriptions during propagation).
     *
     * In case the variable is assigned (that is, \a assigned is 
     * true), the subscribing propagator is processed for execution.
     * Otherwise, the propagator subscribes and is processed for execution
     * with modification event \a me provided that \a pc is different
     * from \a PC_GEN_ASSIGNED.
     */
    void subscribe(Space* home, Propagator* p, PropCond pc, bool assigned, bool process);
    /// Subscribe advisor \a a
    void subscribe(Space* home, Advisor* a, bool assigned);
    /// Notify that variable implementation has been modified with modification event \a me and delta information \a d
    ModEvent notify(Space* home, ModEvent me, Delta* d);
    //@}
    /// Return link to next variable to be disposed
    CpltSetVarImpBase* next_d(void) const;

  };


  forceinline
  CpltSetVarImpBase::CpltSetVarImpBase(void) {}

  forceinline
  CpltSetVarImpBase::CpltSetVarImpBase(Space* home)
    : Gecode::VarImp<Gecode::CpltSet::CpltSetVarImpConf>(home) {
     _next_d = static_cast<CpltSetVarImpBase*>(vars_d(home)); vars_d(home,this);
  }

  forceinline
  CpltSetVarImpBase::CpltSetVarImpBase(Space* home, bool share, CpltSetVarImpBase& x)
    : Gecode::VarImp<Gecode::CpltSet::CpltSetVarImpConf>(home,share,x) {
     _next_d = static_cast<CpltSetVarImpBase*>(vars_d(home)); vars_d(home,this);
  }

  forceinline CpltSetVarImpBase*
  CpltSetVarImpBase::next_d(void) const {
    return _next_d;
  }


  forceinline void
  CpltSetVarImpBase::subscribe(Space* home, Propagator* p, PropCond pc, bool assigned, bool process) {
    Gecode::VarImp<Gecode::CpltSet::CpltSetVarImpConf>::subscribe(home,p,pc,assigned,ME_CPLTSET_DOM,process);
  }
  forceinline void
  CpltSetVarImpBase::subscribe(Space* home, Advisor* a, bool assigned) {
    Gecode::VarImp<Gecode::CpltSet::CpltSetVarImpConf>::subscribe(home,a,assigned);
  }

  forceinline ModEvent
  CpltSetVarImpBase::notify(Space* home, ModEvent me, Delta* d) {
    if (me_failed(Gecode::VarImp<Gecode::CpltSet::CpltSetVarImpConf>::notify(home,me,d)))
      return ME_GEN_FAILED;
    switch (me) {
    case ME_CPLTSET_VAL:
      process(home);
      break;
    case ME_CPLTSET_DOM:
      // Conditions: DOM 
      process(home,PC_CPLTSET_DOM,PC_CPLTSET_DOM,ME_CPLTSET_DOM);
      break;
    default: GECODE_NEVER;
    }
    return me;
  }
}}
#endif

namespace Gecode {

  forceinline void
  Space::process(void) {
#ifdef GECODE_HAVE_CPLTSET_VARS
    {
      using namespace Gecode::CpltSet;
      Gecode::VarImp<Gecode::CpltSet::CpltSetVarImpConf>* x = Gecode::VarImp<Gecode::CpltSet::CpltSetVarImpConf>::vars_pu(this);
      if (x != NULL) {
        Gecode::VarImp<Gecode::CpltSet::CpltSetVarImpConf>::vars_pu(this,NULL);
        do {
          switch (x->modevent()) {
          case ME_CPLTSET_VAL:
            x->process(this);
            break;
          case ME_CPLTSET_DOM:
            // Conditions: DOM 
            x->process(this,PC_CPLTSET_DOM,PC_CPLTSET_DOM,ME_CPLTSET_DOM);
            break;
          default: GECODE_NEVER;
          }
          x = x->next();
        } while (x != NULL);
      }
    }
#endif
#ifdef GECODE_HAVE_SET_VARS
    {
      using namespace Gecode::Set;
      Gecode::VarImp<Gecode::Set::SetVarImpConf>* x = Gecode::VarImp<Gecode::Set::SetVarImpConf>::vars_pu(this);
      if (x != NULL) {
        Gecode::VarImp<Gecode::Set::SetVarImpConf>::vars_pu(this,NULL);
        do {
          switch (x->modevent()) {
          case ME_SET_VAL:
            x->process(this);
            break;
          case ME_SET_CARD:
            // Conditions: CARD CLUB CGLB ANY 
            x->process(this,PC_SET_CARD,PC_SET_ANY,ME_SET_CARD);
            break;
          case ME_SET_LUB:
            // Conditions: CLUB ANY 
            x->process(this,PC_SET_CLUB,PC_SET_CLUB,ME_SET_LUB);
            x->process(this,PC_SET_ANY,PC_SET_ANY,ME_SET_LUB);
            break;
          case ME_SET_GLB:
            // Conditions: CGLB ANY 
            x->process(this,PC_SET_CGLB,PC_SET_ANY,ME_SET_GLB);
            break;
          case ME_SET_BB:
            // Conditions: CLUB CGLB ANY 
            x->process(this,PC_SET_CLUB,PC_SET_ANY,ME_SET_BB);
            break;
          case ME_SET_CLUB:
            // Conditions: CARD CLUB CGLB ANY 
            x->process(this,PC_SET_CARD,PC_SET_ANY,ME_SET_CLUB);
            break;
          case ME_SET_CGLB:
            // Conditions: CARD CLUB CGLB ANY 
            x->process(this,PC_SET_CARD,PC_SET_ANY,ME_SET_CGLB);
            break;
          case ME_SET_CBB:
            // Conditions: CARD CLUB CGLB ANY 
            x->process(this,PC_SET_CARD,PC_SET_ANY,ME_SET_CBB);
            break;
          default: GECODE_NEVER;
          }
          x = x->next();
        } while (x != NULL);
      }
    }
#endif
#ifdef GECODE_HAVE_INT_VARS
    {
      using namespace Gecode::Int;
      Gecode::VarImp<Gecode::Int::BoolVarImpConf>* x = Gecode::VarImp<Gecode::Int::BoolVarImpConf>::vars_pu(this);
      if (x != NULL) {
        Gecode::VarImp<Gecode::Int::BoolVarImpConf>::vars_pu(this,NULL);
        do {
          x->process(this); x = x->next();
        } while (x != NULL);
      }
    }
#endif
#ifdef GECODE_HAVE_INT_VARS
    {
      using namespace Gecode::Int;
      Gecode::VarImp<Gecode::Int::IntVarImpConf>* x = Gecode::VarImp<Gecode::Int::IntVarImpConf>::vars_pu(this);
      if (x != NULL) {
        Gecode::VarImp<Gecode::Int::IntVarImpConf>::vars_pu(this,NULL);
        do {
          switch (x->modevent()) {
          case ME_INT_VAL:
            x->process(this);
            break;
          case ME_INT_BND:
            // Conditions: BND DOM 
            x->process(this,PC_INT_BND,PC_INT_DOM,ME_INT_BND);
            break;
          case ME_INT_DOM:
            // Conditions: DOM 
            x->process(this,PC_INT_DOM,PC_INT_DOM,ME_INT_DOM);
            break;
          default: GECODE_NEVER;
          }
          x = x->next();
        } while (x != NULL);
      }
    }
#endif
  }
}
namespace Gecode {

  forceinline void
  Space::update(ActorLink** s) {
#ifdef GECODE_HAVE_INT_VARS
    {
      using namespace Gecode::Int;
      Gecode::VarImp<Gecode::Int::IntVarImpConf>* x = Gecode::VarImp<Gecode::Int::IntVarImpConf>::vars_pu(this);
      if (x != NULL) {
        Gecode::VarImp<Gecode::Int::IntVarImpConf>::vars_pu(this,NULL);
        do {
          x->forward()->update(x,s); x = x->next();
        } while (x != NULL);
      }
    }
#endif
#ifdef GECODE_HAVE_INT_VARS
    {
      using namespace Gecode::Int;
      Gecode::VarImp<Gecode::Int::BoolVarImpConf>* x = Gecode::VarImp<Gecode::Int::BoolVarImpConf>::vars_pu(this);
      if (x != NULL) {
        Gecode::VarImp<Gecode::Int::BoolVarImpConf>::vars_pu(this,NULL);
        do {
          x->forward()->update(x,s); x = x->next();
        } while (x != NULL);
      }
    }
#endif
#ifdef GECODE_HAVE_SET_VARS
    {
      using namespace Gecode::Set;
      Gecode::VarImp<Gecode::Set::SetVarImpConf>* x = Gecode::VarImp<Gecode::Set::SetVarImpConf>::vars_pu(this);
      if (x != NULL) {
        Gecode::VarImp<Gecode::Set::SetVarImpConf>::vars_pu(this,NULL);
        do {
          x->forward()->update(x,s); x = x->next();
        } while (x != NULL);
      }
    }
#endif
#ifdef GECODE_HAVE_CPLTSET_VARS
    {
      using namespace Gecode::CpltSet;
      Gecode::VarImp<Gecode::CpltSet::CpltSetVarImpConf>* x = Gecode::VarImp<Gecode::CpltSet::CpltSetVarImpConf>::vars_pu(this);
      if (x != NULL) {
        Gecode::VarImp<Gecode::CpltSet::CpltSetVarImpConf>::vars_pu(this,NULL);
        do {
          x->forward()->update(x,s); x = x->next();
        } while (x != NULL);
      }
    }
#endif
  }
}
// STATISTICS: kernel-var
