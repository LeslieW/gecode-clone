/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Christian Schulte <schulte@gecode.org>
 *     Guido Tack <tack@gecode.org>
 *
 *  Copyright:
 *     Christian Schulte, 2004
 *     Guido Tack, 2004
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  Permission is hereby granted, free of charge, to any person obtaining
 *  a copy of this software and associated documentation files (the
 *  "Software"), to deal in the Software without restriction, including
 *  without limitation the rights to use, copy, modify, merge, publish,
 *  distribute, sublicense, and/or sell copies of the Software, and to
 *  permit persons to whom the Software is furnished to do so, subject to
 *  the following conditions:
 *
 *  The above copyright notice and this permission notice shall be
 *  included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

namespace Gecode {

  /**
   * \defgroup TaskBranchViewVal Generic branching based on view and value selection
   *
   * Implements view-based branching for an array of views and value.
   * \ingroup TaskActor
   */

  //@{
  /// Status returned by member functions of view selection class
  enum ViewSelStatus {
    VSS_BEST,   ///< Current view is a best one
    VSS_BETTER, ///< Current view is better
    VSS_TIE,    ///< Current view is as good as
    VSS_WORSE   ///< Current view is worse
  };

  /// Position information
  class Pos {
  public:
    /// Position of view
    const int pos;
    /// Start position in view array
    const int start;
    /// Create position information
    Pos(int p, int s);
  };

  /**
   * \brief Generic branching by view selection
   *
   * Implements a baseclass for view-based branching for an array of views
   * (of type \a ViewSel::View). The behaviour is 
   * defined by the class \a ViewSel (which view is selected for branching).
   *
   * The class \a ViewSel must provide the following members:
   *  - A type definition for the type \a View.
   *  
   * The class \a ViewSel must implement member functions:
   *  - Gecode::ViewSelStatus init(const Space* \a home, \a View \a x)
   *    Initializes view selection with the \a View \a x. If \a x
   *    is known to be a best one, VSS_BEST should be returned.
   *    Otherwise, VSS_BETTER should be returned.
   *  - Gecode::ViewSelStatus select(const Space* \a home, \a View \a x)
   *    If \a x is better than the previously selected view,
   *    return VSS_BETTER. If it is a best view, return VSS_BEST. If it 
   *    is worse, return VSS_WORSE. If it is equally good, return VSS_TIE.
   *
   */
  template <class ViewSel>
  class ViewBranching : public Branching {
  protected:
    /// Views to branch on
    mutable ViewArray<typename ViewSel::View> x; 
    /// Unassigned views start at x[start]
    mutable int start;  
    /// View selection object
    mutable ViewSel viewsel;
    /// Return position information
    Pos pos(const Space* home) const;
    /**
     * \brief Return view according to position information \a p
     *
     * If used during a commit, \a c must be true (eliminates views).
     */
    typename ViewSel::View view(const Pos& p, bool c=false) const;
    /// Constructor for cloning \a b
    ViewBranching(Space* home, bool share, ViewBranching& b);
  public:
    /// Constructor for creation
    ViewBranching(Space* home, ViewArray<typename ViewSel::View>& x,
                  ViewSel& vi_s);
    /// Check status of branching, return true if alternatives left
    virtual bool status(const Space* home) const;
    /// Delete branching and return its size
    virtual size_t dispose(Space* home);
  };

  /**
   * \brief Base class for view selection
   */
  template <class _View>
  class ViewSelBase {
  public:
    /// View type
    typedef _View View;
    /// Default constructor
    ViewSelBase(void);
    /// Constructor for initialization
    ViewSelBase(Space* home, const VarBranchOptions& vbo);
    /// Updating during cloning
    void update(Space* home, bool share, ViewSelBase& vs);
    /// Delete view selection
    void dispose(Space* home);
  };

  /**
   * \brief Select first not assigned view
   */
  template <class View>
  class ViewSelByNone : public ViewSelBase<View> {
  public:
    /// Default constructor
    ViewSelByNone(void);
    /// Constructor for initialization
    ViewSelByNone(Space* home, const VarBranchOptions& vbo);
    /// Intialize with view \a x
    ViewSelStatus init(const Space* home, View x);
    /// Possibly select better view \a x
    ViewSelStatus select(const Space* home, View x);
    /// Type of this view selection (for reflection)
    static Support::Symbol type(void);
  };

  /**
   * \brief View selection class for view with smallest degree
   */
  template<class View>
  class ViewSelByDegreeMin : public ViewSelBase<View> {
  protected:
    /// So-far smallest degree
    unsigned int degree;
  public:
    /// Default constructor
    ViewSelByDegreeMin(void);
    /// Constructor for initialization
    ViewSelByDegreeMin(Space* home, const VarBranchOptions& vbo);
    /// Intialize with view \a x
    ViewSelStatus init(const Space* home, View x);
    /// Possibly select better view \a x
    ViewSelStatus select(const Space* home, View x);
    /// Type of this view selection (for reflection)
    static Support::Symbol type(void);
  };

  /**
   * \brief View selection class for view with largest degree
   */
  template<class View>
  class ViewSelByDegreeMax : public ViewSelBase<View> {
  protected:
    /// So-far largest degree
    unsigned int degree;
  public:
    /// Default constructor
    ViewSelByDegreeMax(void);
    /// Constructor for initialization
    ViewSelByDegreeMax(Space* home, const VarBranchOptions& vbo);
    /// Intialize with view \a x
    ViewSelStatus init(const Space* home, View x);
    /// Possibly select better view \a x
    ViewSelStatus select(const Space* home, View x);
    /// Type of this view selection (for reflection)
    static Support::Symbol type(void);
  };

  /**
   * \brief Virtualized view selection base class
   */
  template <class View>
  class ViewSelVirtualBase {
  public:
    /// Intialize with view \a x
    virtual ViewSelStatus init(const Space* home, View x) = 0;
    /// Possibly select better view \a x
    virtual ViewSelStatus select(const Space* home, View x) = 0;
    /// Create copy
    virtual ViewSelVirtualBase<View>* copy(Space* home, bool share) = 0;
    /// Delete view selection and return its size
    virtual size_t dispose(Space* home) = 0;
    /// \name Memory management
    //@{
    /// Allocate memory from space
    static void* operator new(size_t s, Space* home);
    /// No-op for exceptions
    static void  operator delete(void* p, Space* home);
    /// Needed for exceptions
    static void  operator delete(void*);
    //@}
  };

  /**
   * \brief Virtualized view selection
   */
  template <class ViewSel>
  class ViewSelVirtual : public ViewSelVirtualBase<typename ViewSel::View> {
  protected:
    /// Static view selection object
    ViewSel viewsel;
  public:
    /// Default constructor
    ViewSelVirtual(void);
    /// Constructor for initialization
    ViewSelVirtual(Space* home, const VarBranchOptions& vbo);
    /// Constructor for cloning \a vsv
    ViewSelVirtual(Space* home, bool share, ViewSelVirtual& vsv);
    /// Intialize with view \a x
    virtual ViewSelStatus init(const Space* home, typename ViewSel::View x);
    /// Possibly select better view \a x
    virtual ViewSelStatus select(const Space* home, typename ViewSel::View x);
    /// Create copy
    virtual ViewSelVirtualBase<typename ViewSel::View>* copy(Space* home, bool share);
    /// Delete view selection and returns its size
    virtual size_t dispose(Space* home);
  };

  /**
   * \brief View selection class for static tie breaking
   */
  template<class A, class B>
  class ViewSelTieBreakStatic {
  protected:
    /// First selection class
    A a;
    /// Second selection class
    B b;
  public:
    /// View type
    typedef typename A::View View;
    /// Default constructor
    ViewSelTieBreakStatic(void);
    /// Constructor for initialization
    ViewSelTieBreakStatic(Space* home, A& a, B& b);
    /// Intialize with view \a x
    ViewSelStatus init(const Space* home, typename A::View x);
    /// Possibly select better view \a x
    ViewSelStatus select(const Space* home, typename A::View x);
    /// Updating during cloning
    void update(Space* home, bool share, ViewSelTieBreakStatic& vs);
    /// Delete view selection
    void dispose(Space* home);
    /// Type of this view selection (for reflection)
    static Support::Symbol type(void);
  };

  /**
   * \brief View selection class for dynamic tie breaking
   */
  template<class _View>
  class ViewSelTieBreakDynamic {
  protected:
    /// Number of tie breakers
    int n;
    /// Tie breakers
    ViewSelVirtualBase<_View>** tb;
  public:
    /// View type
    typedef _View View;
    /// Default constructor
    ViewSelTieBreakDynamic(void);
    /// Constructor for initialization
    ViewSelTieBreakDynamic(Space* home, ViewSelVirtualBase<_View>** vsv,
                           int n);
    /// Intialize with view \a x
    ViewSelStatus init(const Space* home, _View x);
    /// Possibly select better view \a x
    ViewSelStatus select(const Space* home, _View x);
    /// Updating during cloning
    void update(Space* home, bool share, ViewSelTieBreakDynamic& vs);
    /// Delete view selection
    void dispose(Space* home);
    /// Type of this view selection (for reflection)
    static Support::Symbol type(void);
  };



  /**
   * \brief Generic branching by view and value selection
   *
   * Implements view-based branching for an array of views (of type
   * \a ViewSel::View) and value (of type \a ValSel::Val). The behaviour is 
   * defined by the class \a ViewSel (which view is selected for branching)
   * and the class \a ValSel (which value is selected for branching).
   *
   * The class \a ViewSel must be as described for ViewBranching.
   *
   * The class \a ValSel must provide the following members:
   *  - A type definition \a View defining the type. Note that the type
   *    defined by ViewSel::View can be different from ValSel::View, provided
   *    they share the same variable implementation type and only have
   *    a unary constructor taking a variable implementation as argument.
   *  - A type definition \a Val for the value to be selected.
   *  - A member static const unsigned int alternatives defining how many 
   *    alternatives a branching should provide.
   *
   * The class \a ValSel must implement the following member functions:
   *  - \a Val val(const Space* \a home, View \a x) const
   *    returns the value (most likely determined by \a x) to branch with.
   *  - Gecode::ModEvent tell(Space* \a home, unsigned int \a a, \a View \a x, \a Val \a n)
   *    performs a tell for alternative \a a on \a x with value \a n.
   *
   * For examples, see \link int/branch.hh integer branchings \endlink.
   */
  template <class ViewSel, class ValSel>
  class ViewValBranching : public ViewBranching<ViewSel> {
  protected:
    using ViewBranching<ViewSel>::viewsel;
    using ViewBranching<ViewSel>::x;
    /// Value selection object
    mutable ValSel valsel;
    /// Constructor for cloning \a b
    ViewValBranching(Space* home, bool share, ViewValBranching& b);
  public:
    /// Constructor for creation
    ViewValBranching(Space* home, ViewArray<typename ViewSel::View>& x,
                     ViewSel& vi_s, ValSel& va_s);
    /// Return branching description (of type Gecode::PosValDesc)
    virtual const BranchingDesc* description(const Space* home) const;
    /// Perform commit for branching description \a d and alternative \a a
    virtual ExecStatus commit(Space* home, const BranchingDesc* d,
                              unsigned int a);
    /// Return specification for this branching given a variable map \a m
    virtual Reflection::ActorSpec spec(const Space* home,
                                       Reflection::VarMap& m) const;
    /// Return specification for a branch
    virtual Reflection::BranchingSpec
    branchingSpec(const Space* home, 
                  Reflection::VarMap& m,
                  const BranchingDesc* d) const;
    /// Actor type identifier of this branching
    static Support::Symbol ati(void);
    /// Post branching according to specification
    static void post(Space* home, Reflection::VarMap& m,
                     const Reflection::ActorSpec& spec);
    /// Perform cloning
    virtual Actor* copy(Space* home, bool share);
    /// Delete branching and return its size
    virtual size_t dispose(Space* home);
  };

  /**
   * \brief Base class for value selection
   *
   * Defines the branching to be binary.
   */
  template <class _View, class _Val>
  class ValSelBase {
  public:
    /// View type
    typedef _View View;
    /// Value type
    typedef _Val Val;
    /// Number of alternatives
    static const unsigned int alternatives = 2;
    /// Default constructor
    ValSelBase(void);
    /// Constructor for initialization
    ValSelBase(Space* home, const ValBranchOptions& vbo);
    /// Updating during cloning
    void update(Space* home, bool share, ValSelBase& vs);
    /// Delete value selection
    void dispose(Space* home);
  };


  /// %Branching descriptions storing position
  class GECODE_VTABLE_EXPORT PosDesc : public BranchingDesc {
  private:
    /// Position information
    const Pos _pos;
  public:
    /// Initialize description for branching \a b, number of alternatives \a a, and position \a p
    PosDesc(const Branching* b, unsigned int a, const Pos& p);
    /// Return position in array
    Pos pos(void) const;
    /// Report size occupied
    GECODE_KERNEL_EXPORT virtual size_t size(void) const;
  };

  /// %Branching descriptions storing position and value
  template <class ValSel>
  class GECODE_VTABLE_EXPORT PosValDesc : public PosDesc {
  private:
    /// Value to assign to
    const typename ValSel::Val _val;
  public:
    /// Initialize description for branching \a b, position \a p, and value \a n
    PosValDesc(const Branching* b, const Pos& p, 
               const typename ValSel::Val& n);
    /// Return value to branch with
    typename ValSel::Val val(void) const;
    /// Report size occupied
    virtual size_t size(void) const;
  };
  //@}




  /*
   * Position information
   *
   */
  forceinline
  Pos::Pos(int p, int s) : pos(p), start(s) {}


  /*
   * Branching descriptions with position
   *
   */
  forceinline
  PosDesc::PosDesc(const Branching* b, unsigned int a, const Pos& p)
    : BranchingDesc(b,a), _pos(p) {}

  forceinline Pos
  PosDesc::pos(void) const {
    return _pos;
  }


  /*
   * Branching descriptions with position and value
   *
   */
  template <class ValSel>
  forceinline
  PosValDesc<ValSel>::PosValDesc(const Branching* b, const Pos& p,
                                 const typename ValSel::Val& n)
    : PosDesc(b,ValSel::alternatives,p), _val(n) {}

  template <class ValSel>
  forceinline typename ValSel::Val
  PosValDesc<ValSel>::val(void) const {
    return _val;
  }

  template <class ValSel>
  size_t
  PosValDesc<ValSel>::size(void) const {
    return sizeof(PosValDesc<ValSel>);
  }


  /*
   * Generic branching based on view selection
   *
   */

  template <class ViewSel>
  forceinline
  ViewBranching<ViewSel>::ViewBranching(Space* home,
                                        ViewArray<typename ViewSel::View>& x0,
                                        ViewSel& vi_s)
    : Branching(home), x(x0), start(0), viewsel(vi_s) {}


  template <class ViewSel>
  forceinline
  ViewBranching<ViewSel>::ViewBranching(Space* home, bool share, 
                                        ViewBranching& b)
    : Branching(home,share,b), start(b.start) {
    x.update(home,share,b.x);
    viewsel.update(home,share,b.viewsel);
  }

  template <class ViewSel>
  bool
  ViewBranching<ViewSel>::status(const Space*) const {
    for (int i=start; i < x.size(); i++)
      if (!x[i].assigned()) {
        start = i;
        return true;
      }
    return false;
  }

  template <class ViewSel>
  forceinline Pos
  ViewBranching<ViewSel>::pos(const Space* home) const {
    assert(!x[start].assigned());
    int i = start;
    int b = i++;
    if (viewsel.init(home,x[b]) != VSS_BEST)
      for (; i < x.size(); i++)
        if (!x[i].assigned())
          switch (viewsel.select(home,x[i])) {
          case VSS_BETTER:              b=i; break;
          case VSS_BEST:                b=i; goto create;
          case VSS_TIE: case VSS_WORSE: break;
          default:                      GECODE_NEVER;
          }
  create:
    Pos p(b-start,start);
    return p;
  }

  template <class ViewSel>
  forceinline typename ViewSel::View
  ViewBranching<ViewSel>::view(const Pos& p, bool c) const {
    if (c) {
      // Eliminate views from x[0] ... x[d->start()-1]
      x.drop_fst(p.start); start = 0;
      return x[p.pos];
    } else {
      return x[p.start+p.pos];
    }
  }

  template <class ViewSel>
  forceinline size_t
  ViewBranching<ViewSel>::dispose(Space* home) {
    viewsel.dispose(home);
    (void) Branching::dispose(home);
    return sizeof(ViewBranching<ViewSel>);
  }


  // Selection base class
  template<class View>
  forceinline
  ViewSelBase<View>::ViewSelBase(void) {}
  template<class View>
  forceinline
  ViewSelBase<View>::ViewSelBase(Space*, const VarBranchOptions&) {}
  template<class View>
  forceinline void 
  ViewSelBase<View>::update(Space*, bool, ViewSelBase<View>&) {}
  template<class View>
  forceinline void
  ViewSelBase<View>::dispose(Space*) {}

  // Select first view
  template<class View>
  forceinline
  ViewSelByNone<View>::ViewSelByNone(void) {}
  template<class View>
  forceinline
  ViewSelByNone<View>::ViewSelByNone(Space* home, const VarBranchOptions& vbo)
    : ViewSelBase<View>(home,vbo) {}
  template<class View>
  forceinline ViewSelStatus
  ViewSelByNone<View>::init(const Space*, View) {
    return VSS_BEST;
  }
  template<class View>
  forceinline ViewSelStatus
  ViewSelByNone<View>::select(const Space*, View) {
    return VSS_BEST;
  }
  template<class View>
  inline Support::Symbol
  ViewSelByNone<View>::type(void) {
    return Support::Symbol("Gecode::ViewSel::ByNone");
  }


  // Select variable with smallest degree
  template<class View>
  forceinline
  ViewSelByDegreeMin<View>::ViewSelByDegreeMin(void) {}
  template<class View>
  forceinline
  ViewSelByDegreeMin<View>::ViewSelByDegreeMin(Space* home, 
                                               const VarBranchOptions& vbo)
    : ViewSelBase<View>(home,vbo) {}
  template<class View>
  forceinline ViewSelStatus
  ViewSelByDegreeMin<View>::init(const Space*, View x) {
    degree = x.degree();
    return (degree == 0) ? VSS_BEST : VSS_BETTER;
  }
  template<class View>
  forceinline ViewSelStatus
  ViewSelByDegreeMin<View>::select(const Space*, View x) {
    if (x.degree() < degree) {
      degree = x.degree();
      return (degree == 0) ? VSS_BEST : VSS_BETTER;
    } else if (x.degree() > degree) {
      return VSS_WORSE;
    } else {
      return VSS_TIE;
    }
  }
  template<class View>
  inline Support::Symbol
  ViewSelByDegreeMin<View>::type(void) {
    return Support::Symbol("Gecode::ViewSel::ByDegreeMin");
  }

  // Select variable with smallest degree
  template<class View>
  forceinline
  ViewSelByDegreeMax<View>::ViewSelByDegreeMax(void) {}
  template<class View>
  forceinline
  ViewSelByDegreeMax<View>::ViewSelByDegreeMax(Space* home, 
                                               const VarBranchOptions& vbo)
    : ViewSelBase<View>(home,vbo) {}
  template<class View>
  forceinline ViewSelStatus
  ViewSelByDegreeMax<View>::init(const Space*, View x) {
    degree = x.degree();
    return VSS_BETTER;
  }
  template<class View>
  forceinline ViewSelStatus
  ViewSelByDegreeMax<View>::select(const Space*, View x) {
    if (x.degree() > degree) {
      degree = x.degree(); return VSS_BETTER;
    } else if (x.degree() < degree) {
      return VSS_WORSE;
    } else {
      return VSS_TIE;
    }
  }
  template<class View>
  inline Support::Symbol
  ViewSelByDegreeMax<View>::type(void) {
    return Support::Symbol("Gecode::ViewSel::ByDegreeMax");
  }


  // Virtualized view selection
  template <class View>
  forceinline void
  ViewSelVirtualBase<View>::operator delete(void*) {}
  template <class View>
  forceinline void
  ViewSelVirtualBase<View>::operator delete(void*, Space*) {}
  template <class View>
  forceinline void*
  ViewSelVirtualBase<View>::operator new(size_t s, Space* home) {
    return home->alloc(s);
  }

  template <class ViewSel>
  forceinline
  ViewSelVirtual<ViewSel>::ViewSelVirtual(void) {}
  template<class ViewSel>
  forceinline
  ViewSelVirtual<ViewSel>::ViewSelVirtual(Space* home, 
                                          const VarBranchOptions& vbo)
    : viewsel(home,vbo) {}
  template <class ViewSel>
  forceinline
  ViewSelVirtual<ViewSel>::ViewSelVirtual(Space* home, bool share, 
                                          ViewSelVirtual<ViewSel>& vsv) {
    viewsel.update(home,share,vsv.viewsel);
  }
  template <class ViewSel>
  ViewSelStatus
  ViewSelVirtual<ViewSel>::init(const Space* home, typename ViewSel::View x) {
    return viewsel.init(home,x);
  }
  template <class ViewSel>
  ViewSelStatus
  ViewSelVirtual<ViewSel>::select(const Space* home, typename ViewSel::View x) {
    return viewsel.select(home,x);
  }
  template <class ViewSel>
  ViewSelVirtualBase<typename ViewSel::View>*
  ViewSelVirtual<ViewSel>::copy(Space* home, bool share) {
    return new (home) ViewSelVirtual<ViewSel>(home,share,*this);
  }
  template <class ViewSel>
  size_t
  ViewSelVirtual<ViewSel>::dispose(Space* home) {
    viewsel.dispose(home);
    return sizeof(ViewSelVirtual<ViewSel>);
  }


  // Select variable with static tie breaking
  template<class A, class B>
  forceinline
  ViewSelTieBreakStatic<A,B>::ViewSelTieBreakStatic(void) {}
  template<class A, class B>
  forceinline
  ViewSelTieBreakStatic<A,B>::
  ViewSelTieBreakStatic(Space* home, A& a0, B& b0)
    : a(a0), b(b0) {}
  template<class A, class B>
  forceinline ViewSelStatus
  ViewSelTieBreakStatic<A,B>::init(const Space* home, typename A::View x) {
    ViewSelStatus s = a.init(home,x);
    return (b.init(home,x) != VSS_BEST) ? VSS_BETTER : s;
  }
  template<class A, class B>
  forceinline ViewSelStatus
  ViewSelTieBreakStatic<A,B>::select(const Space* home, typename A::View x) {
    switch (a.select(home,x)) {
    case VSS_BEST:
      return (b.init(home,x) != VSS_BEST) ? VSS_BETTER : VSS_BEST;
    case VSS_BETTER: 
      (void) b.init(home,x);
      return VSS_BETTER;
    case VSS_WORSE:
      return VSS_WORSE;
    case VSS_TIE:
      switch (b.select(home,x)) {
      case VSS_BEST:   return VSS_BETTER;
      case VSS_BETTER: return VSS_BETTER;
      case VSS_TIE:    return VSS_TIE;
      case VSS_WORSE:  return VSS_WORSE;
      default: GECODE_NEVER;
      }
    default: GECODE_NEVER;
      return VSS_WORSE;
    }
  }
  template<class A, class B>
  inline Support::Symbol
  ViewSelTieBreakStatic<A,B>::type(void) {
    return Reflection::mangle<A,B>("Gecode::ViewSel::TieBreakStatic");
  }
  template<class A, class B>
  forceinline void
  ViewSelTieBreakStatic<A,B>::update(Space* home, bool share, 
                                     ViewSelTieBreakStatic<A,B>& vstb) {
    a.update(home,share,vstb.a);
    b.update(home,share,vstb.b);
  } 
  template<class A, class B>
  forceinline void
  ViewSelTieBreakStatic<A,B>::dispose(Space* home) {
    a.dispose(home);
    b.dispose(home);
  } 

  // Select variable with dynamic tie breaking
  template<class View>
  forceinline
  ViewSelTieBreakDynamic<View>::ViewSelTieBreakDynamic(void) {}
  template<class View>
  forceinline
  ViewSelTieBreakDynamic<View>::
  ViewSelTieBreakDynamic(Space* home, ViewSelVirtualBase<View>** vsv, int n0) 
    : n(n0), tb(static_cast<ViewSelVirtualBase<View>**>
                (home->alloc(sizeof(ViewSelVirtualBase<View>*)*n))) {
    for (int i=0; i<n; i++)
      tb[i]=vsv[i];
    assert(n > 0);
  }
  template<class View>
  forceinline ViewSelStatus
  ViewSelTieBreakDynamic<View>::init(const Space* home, View x) {
    ViewSelStatus s = VSS_BEST;
    for (int i=0; i<n; i++)
      if (tb[i]->init(home,x) != VSS_BEST)
        s = VSS_BETTER;
    return s;
  }
  template<class View>
  forceinline ViewSelStatus
  ViewSelTieBreakDynamic<View>::select(const Space* home, View x) {
    switch (tb[0]->select(home,x)) {
    case VSS_BEST:
      {
        ViewSelStatus s = VSS_BEST;
        for (int i=1; i<n; i++)
          if (tb[i]->init(home,x) != VSS_BEST)
            s = VSS_BETTER;
        return s;
      }
    case VSS_BETTER: 
      for (int i=1; i<n; i++)
        (void) tb[i]->init(home,x);
      return VSS_BETTER;
    case VSS_WORSE:
      return VSS_WORSE;
    case VSS_TIE:
      for (int i=1; i<n; i++)
        switch (tb[i]->select(home,x)) {
        case VSS_BEST:   return VSS_BETTER;
        case VSS_BETTER: return VSS_BETTER;
        case VSS_TIE:    break;
        case VSS_WORSE:  return VSS_WORSE;
        default: GECODE_NEVER;
        }
      return VSS_TIE;
    default: GECODE_NEVER;
      return VSS_WORSE;
    }
  }
  template<class View>
  inline Support::Symbol
  ViewSelTieBreakDynamic<View>::type(void) {
    return Reflection::mangle<View>("Gecode::ViewSel::TieBreakDynamic");
  }
  template<class View>
  forceinline void
  ViewSelTieBreakDynamic<View>::update(Space* home, bool share, 
                                       ViewSelTieBreakDynamic<View>& vstb) {
    n = vstb.n;
    tb = static_cast<ViewSelVirtualBase<View>**>
      (home->alloc(sizeof(ViewSelVirtualBase<View>*)*n));
    for (int i=0; i<n; i++)
      tb[i] = vstb.tb[i]->copy(home,share);
  } 
  template<class View>
  forceinline void
  ViewSelTieBreakDynamic<View>::dispose(Space* home) {
    for (int i=0; i<n; i++)
      home->reuse(tb[i],tb[i]->dispose(home));
    home->reuse(tb,sizeof(ViewSelVirtualBase<View>*)*n);
  } 



  /*
   * Generic branching based on variable/value selection
   *
   */

  template <class ViewSel, class ValSel>
  forceinline
  ViewValBranching<ViewSel,ValSel>::
  ViewValBranching(Space* home, ViewArray<typename ViewSel::View>& x,
                   ViewSel& vi_s, ValSel& va_s)
    : ViewBranching<ViewSel>(home,x,vi_s), valsel(va_s) {}

  template <class ViewSel, class ValSel>
  forceinline
  ViewValBranching<ViewSel,ValSel>::
  ViewValBranching(Space* home, bool share, ViewValBranching& b)
    : ViewBranching<ViewSel>(home,share,b) {
    valsel.update(home,share,b.valsel);
  }
  
  template <class ViewSel, class ValSel>
  Actor*
  ViewValBranching<ViewSel,ValSel>::copy(Space* home, bool share) {
    return new (home)
      ViewValBranching<ViewSel,ValSel>(home,share,*this);
  }

  template <class ViewSel, class ValSel>
  const BranchingDesc*
  ViewValBranching<ViewSel,ValSel>::description(const Space* home) const {
    Pos p = ViewBranching<ViewSel>::pos(home);
    typename ValSel::View v(ViewBranching<ViewSel>::view(p).var());
    return new PosValDesc<ValSel>(this,p,valsel.val(home,v));
  }

  template <class ViewSel, class ValSel>
  ExecStatus
  ViewValBranching<ViewSel,ValSel>
  ::commit(Space* home, const BranchingDesc* d, unsigned int a) {
    const PosValDesc<ValSel>* pvd 
      = static_cast<const PosValDesc<ValSel>*>(d);
    typename ValSel::View 
      v(ViewBranching<ViewSel>::view(pvd->pos(),true).var());
    return me_failed(valsel.tell(home,a,v,pvd->val())) ? ES_FAILED : ES_OK;
  }

  template <class ViewSel, class ValSel>
  Support::Symbol
  ViewValBranching<ViewSel,ValSel>::ati(void) {
    return Reflection::mangle<ViewSel,ValSel>("Gecode::ViewValBranching");
  }

  template <class ViewSel, class ValSel>
  void
  ViewValBranching<ViewSel,ValSel>
  ::post(Space* home, Reflection::VarMap& vars,
         const Reflection::ActorSpec& spec) {
    spec.checkArity(1);
    ViewArray<typename ViewSel::View> x(home, vars, spec[0]);
    (void) new (home) ViewValBranching<ViewSel,ValSel>(home, x);
  }

  template <class ViewSel, class ValSel>
  Reflection::ActorSpec
  ViewValBranching<ViewSel,ValSel>
  ::spec(const Space* home, Reflection::VarMap& m) const {
    Reflection::ActorSpec s(ati());
    return s << x.spec(home, m);
  }

  template <class ViewSel, class ValSel>
  Reflection::BranchingSpec
  ViewValBranching<ViewSel,ValSel>
  ::branchingSpec(const Space* home, 
                  Reflection::VarMap& m, const BranchingDesc* d) const {
    const PosValDesc<ValSel>* pvd 
      = static_cast<const PosValDesc<ValSel>*>(d);
    Reflection::BranchingSpec bs(3);
    bs[0] = view(pvd->pos()).spec(home, m);
    bs[1] = Reflection::Arg::newString(valsel.type());
    bs[2] = Reflection::Arg::newInt(pvd->val());
    return bs;
  }

  template <class ViewSel, class ValSel>
  forceinline size_t
  ViewValBranching<ViewSel,ValSel>::dispose(Space* home) {
    valsel.dispose(home);
    (void) ViewBranching::dispose(home);
    return sizeof(ViewValBranching<ViewSel,ValSel>);
  }

  // Value selection base class
  template<class View, class Val>
  forceinline
  ValSelBase<View,Val>::ValSelBase(void) {}
  template<class View, class Val>
  forceinline 
  ValSelBase<View,Val>::ValSelBase(Space*, const ValBranchOptions&) {}
  template<class View, class Val>
  forceinline void 
  ValSelBase<View,Val>::update(Space*, bool, ValSelBase<View,Val>&) {}
  template<class View, class Val>
  forceinline void
  ValSelBase<View,Val>::dispose(Space*) {}

}

// STATISTICS: kernel-other
