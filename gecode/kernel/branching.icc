/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Christian Schulte <schulte@gecode.org>
 *     Guido Tack <tack@gecode.org>
 *
 *  Copyright:
 *     Christian Schulte, 2004
 *     Guido Tack, 2004
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  Permission is hereby granted, free of charge, to any person obtaining
 *  a copy of this software and associated documentation files (the
 *  "Software"), to deal in the Software without restriction, including
 *  without limitation the rights to use, copy, modify, merge, publish,
 *  distribute, sublicense, and/or sell copies of the Software, and to
 *  permit persons to whom the Software is furnished to do so, subject to
 *  the following conditions:
 *
 *  The above copyright notice and this permission notice shall be
 *  included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

namespace Gecode {

  /**
   * \defgroup TaskBranchViewVal Generic branching based on view and value selection
   *
   * Implements view-based branching for an array of views and value.
   * \ingroup TaskActor
   */

  //@{
  /// Status returned by member functions of view selection class
  enum ViewSelStatus {
    VSS_BEST,   ///< Current view is a best one
    VSS_BETTER, ///< Current view is better
    VSS_TIE,    ///< Current view is as good as
    VSS_WORSE   ///< Current view is worse
  };

  /// Position information
  class Pos {
  public:
    /// Position of view
    const int pos;
    /// Start position in view array
    const int start;
    /// Create position information
    Pos(int p, int s=0);
    /// Return sum of start and position
    operator int(void);
  };

  /**
   * \brief Generic branching by view and value selection
   *
   * Implements view-based branching for an array of views (of type
   * \a ViewSel::View) and value (of type \a ValSel::Val). The behaviour is 
   * defined by the class \a ViewSel (which view is selected for branching)
   * and the class \a ValSel (which value is selected for branching).
   *
   * The class \a ViewSel must implement two member functions:
   *  - Gecode::ViewSelStatus init(const Space* \a home, \a View \a x)
   *    Initializes view selection with the \a View \a x. If \a x
   *    is known to be a best one, VSS_BEST should be returned.
   *    Otherwise, VSS_BETTER should be returned.
   *  - Gecode::ViewSelStatus select(const Space* \a home, \a View \a x)
   *    If \a x is better than the previously selected view,
   *    return VSS_BETTER. If it is a best view, return VSS_BEST. If it 
   *    is worse, return VSS_WORSE. If it is equally good, return VSS_TIE.
   *
   * The class \a ValSel must implement two member functions:
   *  - \a Val val(const Space* \a home, View \a x) const
   *    returns the value (most likely determined by \a x) to branch with.
   *  - Gecode::ModEvent tell(Space* \a home, unsigned int \a a, \a View \a x, \a Val \a n)
   *    performs a tell for alternative \a a on \a x with value \a n.
   *
   * For examples, see \link int/branch.hh integer branchings \endlink.
   */
  template <class ViewSel, class ValSel>
  class ViewValBranching : public Branching {
  private:
    /// Views to branch on
    mutable ViewArray<typename ViewSel::View> x; 
    /// Unassigned views start at x[start]
    mutable int start;  
  protected:
    /// Return position information
    Pos pos(const Space* home) const;
    /**
     * \brief Return view according to position information \a p
     *
     * If used during a commit, \a c must be true (eliminates views).
     */
    typename ViewSel::View view(const Pos& p, bool c=false) const;
    /// Constructor for cloning \a b
    ViewValBranching(Space* home, bool share, ViewValBranching& b);
  public:
    /// Constructor for creation
    ViewValBranching(Space* home, ViewArray<typename ViewSel::View>& x);
    /// Check status of branching, return true if alternatives left
    virtual bool status(const Space* home) const;
    /// Return branching description (of type Gecode::PosValDesc)
    virtual const BranchingDesc* description(const Space* home) const;
    /// Perform commit for branching description \a d and alternative \a a
    virtual ExecStatus commit(Space* home, const BranchingDesc* d,
                              unsigned int a);
    /// Return specification for this branching given a variable map \a m
    virtual Reflection::ActorSpec spec(const Space* home,
                                       Reflection::VarMap& m) const;
    /// Return specification for a branch
    virtual Reflection::BranchingSpec
    branchingSpec(const Space* home, 
                  Reflection::VarMap& m,
                  const BranchingDesc* d) const;
    /// Actor type identifier of this branching
    static Support::Symbol ati(void);
    /// Post branching according to specification
    static void post(Space* home, Reflection::VarMap& m,
                     const Reflection::ActorSpec& spec);
    /// Perform cloning
    virtual Actor* copy(Space* home, bool share);
  };


  /**
   * \brief %Branching descriptions storing position
   *
   * The maximal number of alternatives is defined by \a alt.
   */
  template <unsigned int alt>
  class PosDesc : public BranchingDesc {
  private:
    /// Position information
    const Pos _pos;
  public:
    /// Initialize description for branching \a b and position \a p
    PosDesc(const Branching* b, const Pos& p);
    /// Return position in array
    Pos pos(void) const;
    /// Report size occupied
    virtual size_t size(void) const;
  };

  /**
   * \brief %Branching descriptions storing position and value
   *
   * The maximal number of alternatives is defined by \a alt.
   */
  template <class Val, unsigned int alt>
  class PosValDesc : public PosDesc<alt> {
  private:
    /// Value to assign to
    const Val _val;
  public:
    /// Initialize description for branching \a b, position \a p, and value \a n
    PosValDesc(const Branching* b, const Pos& p, const Val& n);
    /// Return value to branch with
    Val val(void) const;
    /// Report size occupied
    virtual size_t size(void) const;
  };
  //@}




  /*
   * Position information
   *
   */
  forceinline
  Pos::Pos(int p, int s) : pos(p), start(s) {}
  forceinline
  Pos::operator int(void) {
    return pos+start;
  }

  /*
   * Branching descriptions with position
   *
   */
  template <unsigned int alt>
  forceinline
  PosDesc<alt>::PosDesc(const Branching* b, const Pos& p)
    : BranchingDesc(b,alt), _pos(p) {}

  template <unsigned int alt>
  forceinline Pos
  PosDesc<alt>::pos(void) const {
    return _pos;
  }

  template <unsigned int alt>
  size_t
  PosDesc<alt>::size(void) const {
    return sizeof(PosDesc<alt>);
  }


  /*
   * Branching descriptions with position and value
   *
   */
  template <class Val, unsigned int alt>
  forceinline
  PosValDesc<Val,alt>::PosValDesc(const Branching* b, const Pos& p,
                                  const Val& n)
    : PosDesc<alt>(b,p), _val(n) {}

  template <class Val, unsigned int alt>
  forceinline Val
  PosValDesc<Val,alt>::val(void) const {
    return _val;
  }

  template <class Val, unsigned int alt>
  size_t
  PosValDesc<Val,alt>::size(void) const {
    return sizeof(PosValDesc<Val,alt>);
  }


  /*
   * Generic branching based on variable/value selection
   *
   */

  template <class ViewSel, class ValSel>
  forceinline
  ViewValBranching<ViewSel,ValSel>
  ::ViewValBranching(Space* home, ViewArray<typename ViewSel::View>& x0)
    : Branching(home), x(x0), start(0) {}


  template <class ViewSel, class ValSel>
  forceinline
  ViewValBranching<ViewSel,ValSel>
  ::ViewValBranching(Space* home, bool share, ViewValBranching& b)
    : Branching(home,share,b), start(b.start) {
    x.update(home,share,b.x);
  }

  template <class ViewSel, class ValSel>
  Actor*
  ViewValBranching<ViewSel,ValSel>::copy(Space* home, bool share) {
    return new (home)
      ViewValBranching<ViewSel,ValSel>(home,share,*this);
  }

  template <class ViewSel, class ValSel>
  bool
  ViewValBranching<ViewSel,ValSel>
  ::status(const Space*) const {
    for (int i=start; i < x.size(); i++)
      if (!x[i].assigned()) {
        start = i;
        return true;
      }
    return false;
  }

  template <class ViewSel, class ValSel>
  forceinline Pos
  ViewValBranching<ViewSel,ValSel>::pos(const Space* home) const {
    assert(!x[start].assigned());
    ViewSel vs; // For view selection
    int i = start;
    int b = i++;
    if (vs.init(home,x[b]) != VSS_BEST)
      for (; i < x.size(); i++)
        if (!x[i].assigned())
          switch (vs.select(home,x[i])) {
          case VSS_BETTER:              b=i; break;
          case VSS_BEST:                b=i; goto create;
          case VSS_TIE: case VSS_WORSE: break;
          default:                      GECODE_NEVER;
          }
  create:
    Pos p(b-start,start);
    return p;
  }

  template <class ViewSel, class ValSel>
  forceinline typename ViewSel::View
  ViewValBranching<ViewSel,ValSel>::view(const Pos& p, bool c) const {
    if (c) {
      // Eliminate views from x[0] ... x[d->start()-1]
      x.drop_fst(p.start); start = 0;
      return x[p.pos];
    } else {
      return x[p.start+p.pos];
    }
  }

  template <class ViewSel, class ValSel>
  const BranchingDesc*
  ViewValBranching<ViewSel,ValSel>::description(const Space* home) const {
    assert(!x[start].assigned());
    Pos p = pos(home);
    ValSel vl; // For value selection
    return new PosValDesc<typename ValSel::Val,ValSel::alternatives>
      (this,p,vl.val(home,view(p)));
  }

  template <class ViewSel, class ValSel>
  ExecStatus
  ViewValBranching<ViewSel,ValSel>
  ::commit(Space* home, const BranchingDesc* d, unsigned int a) {
    const PosValDesc<typename ValSel::Val,ValSel::alternatives>* pvd 
      = static_cast<const PosValDesc<typename ValSel::Val,ValSel::alternatives>*>(d);
    ValSel vs;
    return me_failed(vs.tell(home,a,view(pvd->pos(),true),pvd->val()))
      ? ES_FAILED : ES_OK;
  }

  template <class ViewSel, class ValSel>
  Support::Symbol
  ViewValBranching<ViewSel,ValSel>::ati(void) {
    return Reflection::mangle<ViewSel,ValSel>("Gecode::ViewValBranching");
  }

  template <class ViewSel, class ValSel>
  void
  ViewValBranching<ViewSel,ValSel>
    ::post(Space* home, Reflection::VarMap& vars,
           const Reflection::ActorSpec& spec) {
    spec.checkArity(1);
    ViewArray<typename ViewSel::View> x(home, vars, spec[0]);
    (void) new (home) ViewValBranching<ViewSel,ValSel>(home, x);
  }

  template <class ViewSel, class ValSel>
  Reflection::ActorSpec
  ViewValBranching<ViewSel,ValSel>
  ::spec(const Space* home, Reflection::VarMap& m) const {
    Reflection::ActorSpec s(ati());
    return s << x.spec(home, m);
  }

  template <class ViewSel, class ValSel>
  Reflection::BranchingSpec
  ViewValBranching<ViewSel,ValSel>
  ::branchingSpec(const Space* home, 
                  Reflection::VarMap& m, const BranchingDesc* d) const {
    const PosValDesc<typename ValSel::Val,ValSel::alternatives>* pvd 
      = static_cast<const PosValDesc<typename ValSel::Val,ValSel::alternatives>*>(d);
    Reflection::BranchingSpec bs(3);
    bs[0] = view(pvd->pos()).spec(home, m);
    bs[1] = Reflection::Arg::newString(ValSel::type());
    bs[2] = Reflection::Arg::newInt(pvd->val());
    return bs;
  }

}

// STATISTICS: kernel-other
