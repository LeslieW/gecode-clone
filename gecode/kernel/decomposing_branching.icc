/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Guido Tack <tack@gecode.org>
 *     Martin Mann <mmann@informatik.uni-freiburg.de>
 *     Sebastian Will <will@informatik.uni-freiburg.de>
 *
 *  Copyright:
 *     Guido Tack, 2008
 *     Martin Mann, 2008
 *     Sebastian Will, 2008
 *
 *  Last modified:
 *     $Date: 2007-04-05 15:25:13 +0200 (Thu, 05 Apr 2007) $ by $Author: tack $
 *     $Revision: 4322 $
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

#include <vector>
#include <utility>

namespace Gecode {

  namespace Decomposition {
    template <class View>
    class IdxView {
    public:
      View view;
      int idx;
      IdxView(void);
      IdxView(View v, int i);

      /// \name Cloning
      //@{
      /// Update this view to be a clone of view \a x
      void update(Space* home, bool share, IdxView<View>& x);
      //@}
      
      /// \name Reflection
      //@{
      /// Return specification for this view, using variable map \a m
      Reflection::Arg* spec(const Space* home, Reflection::VarMap& m) const;
      static Support::Symbol type(void);
      //@}
      
    };
  }

  template <class View>
  forceinline
  Decomposition::IdxView<View>::IdxView(void) {}

  template <class View>
  forceinline
  Decomposition::IdxView<View>::IdxView(View v, int i) : view(v), idx(i) {}

  template <class View>
  void
  Decomposition::IdxView<View>::update(Space* home, bool share,
                                       Decomposition::IdxView<View>& v) {
    idx = v.idx;
    view.update(home, share, v.view);
  }

  template <class View>
  Reflection::Arg*
  Decomposition::IdxView<View>::spec(const Space* home,
                                     Reflection::VarMap& vm) const {
    return view.spec(home, vm);
  }

  template <class View>
  Support::Symbol
  Decomposition::IdxView<View>::type(void) {
    return View::type();
  }

  /**
   * \brief Branching for decomposition during search
   *
   * This branching analyzes the constraint graph and decomposes the search
   * if the graph contains more than one connected component.
   *
   * Otherwise, the branching behaves like a normal ViewValBranching.
   *
   */    
  template <class View, class Val, class ViewSel, class ValSel>
  class DecomposingViewValBranching : public Branching {
  protected:
    ViewArray<Decomposition::IdxView<View> > x;
    mutable int start;
    mutable bool selectFirst;

    DecomposingViewValBranching(Space* home, bool share,
                                DecomposingViewValBranching& b);

  public:
    DecomposingViewValBranching(Space* home, ViewArray<View>& x);
    virtual bool status(const Space* home) const;
    virtual const BranchingDesc* description(const Space* home) const;
    virtual ExecStatus commit(Space* home, const BranchingDesc* d,
                              unsigned int a);
    virtual Actor* copy(Space* home, bool share);
    
    /// Return specification for this branching given a variable map \a m
    virtual Reflection::ActorSpec spec(const Space* home,
                                       Reflection::VarMap& m) const;
    // /// Return specification for a branch
    virtual Reflection::BranchingSpec
    branchingSpec(const Space* home, 
                  Reflection::VarMap& m,
                  const BranchingDesc* d) const;
    /// Actor type identifier of this branching
    static Support::Symbol ati(void);
    /// Post branching according to specification
    static void post(Space* home, Reflection::VarMap& m,
                     const Reflection::ActorSpec& spec);
    
  };

  namespace Decomposition {
  
    /// Branching description for decomposition
    class GECODE_VTABLE_EXPORT DecompDesc : public BranchingDesc {
    protected:
      /// The significant variables in the components
      const std::vector<std::pair<int,int> > label;
      /// Start index
      const int start;
      /// Selected variables
      const std::vector<int> select;

    public:
      /// Constructor
      DecompDesc(const Branching* b, int start,
                 const std::vector<std::pair<int,int> >& l,
                 const std::vector<int>& select);
      /// Return the stored label
      int operator[](int i) const;
      /// Return the selected view index for component \a alt
      int getSelection(unsigned int alt) const;
      /// Return the start index
      int getStart(void) const;
      /// Return the significant variables for alternative \a alt in \a sv
      void significantVars(int alt, std::vector<int>& sv) const;
      /// Return size
      virtual size_t size(void) const;
    };

    /// A branching description for singleton components
    class GECODE_KERNEL_EXPORT SingletonDescBase : public BranchingDesc {
    private:
      /// Index of the singleton view
      unsigned int _idx;
      /// Size of the domain of the singleton component
      unsigned int _size;
    public:
      /// Constructor
      SingletonDescBase(const Branching* b, unsigned int alt,
                        unsigned int idx, unsigned int size);
      /// Return index of the singleton view
      unsigned int idx(void) const;
      /// Return size of the domain of the singleton component
      unsigned int domainSize(void) const;
      /// Return size
      virtual size_t size(void) const;
    };

    /// Wrapper class for PosValDesc that stores an additional component size
    template <class Val, int alt>
    class GECODE_KERNEL_EXPORT SingletonDesc : public SingletonDescBase {
    private:
      PosValDesc<Val,alt>* _pvd;
    public:
      /// Constructor
      SingletonDesc(const Branching* b, Val v, int start,
                    unsigned int idx, unsigned int size);
      /// Destructor
      ~SingletonDesc(void);
      /// Acces embedded PosValDesc
      PosValDesc<Val,alt>* pvd(void) const;
      /// Return size
      virtual size_t size(void) const;
    };
  
    inline
    DecompDesc::DecompDesc(const Branching* b, int start0,
                           const std::vector<std::pair<int,int> >& l, 
                           const std::vector<int>& select_)
    : BranchingDesc(b,select_.size()-1), label(l), start(start0), 
      select(select_) {}

    forceinline
    int
    DecompDesc::getStart(void) const { return start; }

    forceinline
    int
    DecompDesc::operator[](int i) const {
      return label[i].first;
    }
  
    forceinline
    int 
    DecompDesc::getSelection(unsigned int alt) const {
      return select[alt];
    }

    template <class Val, int alt>
    SingletonDesc<Val,alt>::SingletonDesc(const Branching* b, Val v,
                                          int start,
                                          unsigned int idx,
                                          unsigned int size)
      : SingletonDescBase(b,alt,idx,size),
        _pvd(new PosValDesc<Val,alt>(b, 0, v, start)) 
    {}
    
    template <class Val, int alt>
    SingletonDesc<Val,alt>::~SingletonDesc(void) {
      delete _pvd;
    }

    template <class Val, int alt>
    PosValDesc<Val,alt>*
    SingletonDesc<Val,alt>::pvd(void) const { return _pvd; }

    template <class Val, int alt>
    size_t
    SingletonDesc<Val,alt>::size(void) const {
      return sizeof(SingletonDesc<Val,alt>);
    }

    /// Compute connected components of the constraint graph
    GECODE_KERNEL_EXPORT void
    connectedComponents(const Space* home, Reflection::VarMap& vars,
                        std::vector<int>& label,
                        std::vector<int>& separators);

  }

  /*
   * Generic branching based on variable/value selection
   *
   */

  template <class View, class Val, class ViewSel, class ValSel>
  forceinline
  DecomposingViewValBranching<View,Val,ViewSel,ValSel>
  ::DecomposingViewValBranching(Space* home, ViewArray<View>& x0)
    : Branching(home), x(home, x0.size()), start(0), selectFirst(false) {
    for (int i=x0.size(); i--;)
      x[i] = Decomposition::IdxView<View>(x0[i], i);
  }


  template <class View, class Val, class ViewSel, class ValSel>
  forceinline
  DecomposingViewValBranching<View,Val,ViewSel,ValSel>
  ::DecomposingViewValBranching(Space* home, bool share, 
                                DecomposingViewValBranching& b)
    : Branching(home,share,b), start(b.start), selectFirst(b.selectFirst) {
    x.update(home,share,b.x);
  }

  template <class View, class Val, class ViewSel, class ValSel>
  Actor*
  DecomposingViewValBranching<View,Val,ViewSel,ValSel>
  ::copy(Space* home, bool share) {
    return new (home)
      DecomposingViewValBranching<View,Val,ViewSel,ValSel>(home,
        share,*this);
  }

  template <class View, class Val, class ViewSel, class ValSel>
  bool
  DecomposingViewValBranching<View,Val,ViewSel,ValSel>
  ::status(const Space*) const {
    for (int i=start; i < x.size(); i++)
      if (!x[i].view.assigned()) {
        start = i;
        return true;
      }
    return false;
  }

  template <class View, class Val, class ViewSel, class ValSel>
  const BranchingDesc*
  DecomposingViewValBranching<View,Val,ViewSel,ValSel>
  ::description(const Space* home) const {

    assert(!x[start].view.assigned());

    if (selectFirst && !x[0].view.assigned()) {
      selectFirst = false;
      ValSel  vl; // For value selection
      if (x.size() == 1) {
        return
          new Decomposition::SingletonDesc<Val,2>(
            this,vl.val(home,x[0].view),
            0, x[0].idx, DomainSize<View>::size(x[0].view));
      } else {
        return new PosValDesc<Val,2>(this,0,vl.val(home,x[0].view),0);
      }
    }

    int componentNumber = 1;
    std::vector<int> label;
    std::vector<int> separators;

    if (x.size()-start > 1) {

      // Compute connected components in the constraint graph
      Reflection::VarMap vm;
      typedef typename ViewVarImpTraits<View>::VarImp VarImp;
      typedef typename VarImpVarTraits<VarImp>::Var Var;
      for (int i=start; i<x.size(); i++) {
        Var v(x[i].view);
        vm.put(home, v, "", false);
      }
      
      Decomposition::connectedComponents(home, vm, label, separators);
      componentNumber = separators.size()-1;

    } else if (x[start].view.degree() == 0) {
      assert(x.size() - start == 1);
      ValSel  vl; // For value selection
      return
        new Decomposition::SingletonDesc<Val,2>(
          this,
          vl.val(home,x[start].view),
          start,
          x[start].idx,
          DomainSize<View>::size(x[start].view));
    }
    
    if (start+1 < x.size() && componentNumber > 1) {
      // do decomposing branching

      std::vector<std::pair<int,int> > outputLabel;
      std::vector<int> outputSeparators;
      
      outputSeparators.push_back(0);

      ViewSel vs;
      while (label.size() > 0) {
        // Find selected variable
        ViewSelStatus vss = vs.init(home,x[start+label[0]].view);
        int lastSelect = 0;
        unsigned int i = 0;
        while (vss != VSS_COMMIT && i<label.size()) {
          if (!x[start+label[i]].view.assigned()) {
            vss = vs.select(home,x[start+label[i]].view);
            if (vss != VSS_NONE)
              lastSelect = i;
          }
          i++;
        }
        
        // Find component of selected variable
        int selectedComponent = -1;
        for (unsigned int c=0; c < separators.size()-1; c++) {
          if (lastSelect >= separators[c] && lastSelect < separators[c+1]) {
            selectedComponent = c;
            break;
          }
        }
        assert(selectedComponent >= 0);
        
        // Copy component of selected variable to outputLabel
        for (int i=separators[selectedComponent]; 
             i<separators[selectedComponent+1]; i++) {
          outputLabel.push_back(std::pair<int,int>(label[i],
                                                   x[start+label[i]].idx));
        }
        outputSeparators.push_back(outputLabel.size());

        // Remove selected component from label
        int next = separators[selectedComponent];
        int nextSep = selectedComponent+1;
        for (unsigned int c=selectedComponent+1; c<separators.size()-1; c++) {
          for (int i=separators[c]; i<separators[c+1]; i++)
            label[next++] = label[i];
          separators[nextSep++] = next;
        }
        label.resize(next);
        separators.pop_back();
      }

      // create decomposition description
      return new Decomposition::DecompDesc(this, start, outputLabel,
                                           outputSeparators);
    } else {
      // do normal branching

      ViewSel vs; // For view selection
      ValSel  vl; // For value selection
      int i = start;
      int b = i++;
      if (vs.init(home,x[b].view) != VSS_COMMIT)
         for (; i < x.size(); i++) {
            if (!x[i].view.assigned()) {
              switch (vs.select(home,x[i].view)) {
              case VSS_SELECT:
                b=i; break;
              case VSS_COMMIT:
                b=i;
                return new 
                  PosValDesc<Val,2>(this,b-start,vl.val(home,x[b].view),
                                    start);
              case VSS_NONE:   break;
              default:         GECODE_NEVER;
              }
            }
         }
      return new PosValDesc<Val,2>(this,b-start,vl.val(home,x[b].view),start);
    }

  }

  template <class View, class Val, class ViewSel, class ValSel>
  ExecStatus
  DecomposingViewValBranching<View,Val,ViewSel,ValSel>
  ::commit(Space* home, const BranchingDesc* d, unsigned int a) {

    const Decomposition::DecompDesc* dd =
      dynamic_cast<const Decomposition::DecompDesc*>(d);
    if( dd == NULL) { // --> normal handling of PosValDescriptions
      
      const PosValDesc<Val,2>* pvd;
      if (const Decomposition::SingletonDesc<Val,2>* sd =
          dynamic_cast<const Decomposition::SingletonDesc<Val,2>*>(d)) {
        pvd = sd->pvd();
      } else {
        pvd = static_cast<const PosValDesc<Val,2>*>(d); 
      }
      // Eliminate views from x[0] ... x[start-1]
      x.drop_fst(pvd->start()); start = 0;
      ValSel vs;
      return me_failed(vs.tell(home,a,x[pvd->pos()].view,pvd->val()))
          ? ES_FAILED : ES_OK;
    } else {
      // Eliminate views from x[0] ... x[start-1]
      x.drop_fst(dd->getStart()); start = 0;
      
      // Collect selected component at beginning of x array
      int compSize = dd->getSelection(a+1)-dd->getSelection(a);
      GECODE_AUTOARRAY(Decomposition::IdxView<View>, tmp, compSize);
      for (int i=compSize; i--; ) {
        tmp[i] = x[(*dd)[i+dd->getSelection(a)]];
      }
      for (int i=compSize; i--; ) {
        x[i] = tmp[i];
      }

      // Eliminate all views from x that are not in the selected component
      x.drop_lst(compSize-1);

      // No decomposition possible directly after decomposition
      selectFirst = true;

      return ES_OK;
    }
  }


  template <class View, class Val, class ViewSel, class ValSel>
  Reflection::BranchingSpec
  DecomposingViewValBranching<View,Val,ViewSel,ValSel>
  ::branchingSpec(const Space* home,
                  Reflection::VarMap& m,
                  const BranchingDesc* d) const {
    Reflection::BranchingSpec bs(d);
    const PosValDesc<Val,2>* pvd = dynamic_cast<const PosValDesc<Val,2>*>(d);
    if (pvd) {
      ValSel vs;
      vs.branchingSpec(home, m, bs, 2, x[pvd->start()+pvd->pos()].view, 
                       pvd->val());
    } else {
      const Decomposition::DecompDesc* dd =
        dynamic_cast<const Decomposition::DecompDesc*>(d);
      assert(dd);
      for (unsigned int i=0; i<dd->alternatives(); i++) {
        int compSize = dd->getSelection(i+1)-dd->getSelection(i);
        Reflection::ArrayArg* arg = Reflection::Arg::newArray(2*compSize-1);
        int k=0;
        for (int j=dd->getSelection(i); j<dd->getSelection(i+1); j++) {
          (*arg)[k++] = Reflection::Arg::newInt((*dd)[j]);
          if (j<dd->getSelection(i+1)-1)
            (*arg)[k++] = Reflection::Arg::newString(",");
        }
        bs[i] = arg;
      }
    }
    return bs;
  }

  template <class View, class Val, class ViewSel, class ValSel>
  Support::Symbol
  DecomposingViewValBranching<View,Val,ViewSel,ValSel>::ati(void) {
    return Reflection::mangle<View,Val,ViewSel,ValSel>(
      "Gecode::DecomposingViewValBranching");
  }

  template <class View, class Val, class ViewSel, class ValSel>
  void
  DecomposingViewValBranching<View,Val,ViewSel,ValSel>
    ::post(Space* home, Reflection::VarMap& vars,
           const Reflection::ActorSpec& spec) {
    spec.checkArity(1);
    ViewArray<Decomposition::IdxView<View> > x(home, vars, spec[0]);
    (void) new (home) 
      DecomposingViewValBranching<View,Val,ViewSel,ValSel>(home, x);
  }

  template <class View, class Val, class ViewSel, class ValSel>
  Reflection::ActorSpec
  DecomposingViewValBranching<View,Val,ViewSel,ValSel>
  ::spec(const Space* home,
         Reflection::VarMap& m) const {
    Reflection::ActorSpec s(ati());
    return s << x.spec(home, m);
  }

}

// STATISTICS: dds-any
