/* -*- mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*- */
/*
 *  Main authors:
 *     Guido Tack <tack@gecode.org>
 *     Martin Mann <mmann@informatik.uni-freiburg.de>
 *     Sebastian Will <will@informatik.uni-freiburg.de>
 *
 *  Copyright:
 *     Guido Tack, 2008
 *     Martin Mann, 2008
 *     Sebastian Will, 2008
 *
 *  Last modified:
 *     $Date: 2007-04-05 15:25:13 +0200 (Thu, 05 Apr 2007) $ by $Author: tack $
 *     $Revision: 4322 $
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

namespace Gecode {
  namespace Decomposition {

    inline
    DecompDesc::DecompDesc(const Branching* b, int start0,
                           const ConstraintGraph::ComponentLabel& l, 
                           const std::vector<int>& select_)
    : BranchingDesc(b,select_.size()), label(l), start(start0), 
      select(select_) {}

    forceinline
    size_t
    DecompDesc::size(void) const {
      return sizeof(DecompDesc);
    }

    forceinline
    int
    DecompDesc::getStart(void) const { return start; }

    forceinline
    const ConstraintGraph::ComponentLabel&
    DecompDesc::getComponentLabel(void) const {
      return label;
    }
  
    forceinline
    int 
    DecompDesc::getSelection(unsigned int alt) const {
      return select[alt];
    }

    forceinline unsigned int
    SingletonDescBase::domainSize(void) const { return _size; }

    template <class Val, int alt>
    inline
    SingletonDesc<Val,alt>::SingletonDesc(const Branching* b, Val v,
                                          int start,
                                          unsigned int size)
      : PosValDesc<Val,alt>(b, 0, v, start) {
        SingletonDescBase::_size = size;
      }

    /// Compute the constraint graph of \a s given the root set of variables \a vars
    template <class View>
    ConstraintGraph*
    graph(const Space* s, const ViewArray<View>& vars, unsigned int start) {
      Reflection::VarMap vm;
      for (int i=start; i<vars.size(); i++) {
        vm.put(vars[i].var(), NULL);
      }
      ConstraintGraph* g = new ConstraintGraph(vm.size());
      int oldSize = vm.size();
      int propIndex = 0;
      for (Reflection::ActorSpecIter si(s,vm); si(); ++si) {
        for(int i=oldSize; i<vm.size(); i++) {
          g->addEdge(i,propIndex);
        }
        propIndex++;
      }
      return g;
    }

  }

  /*
   * Generic branching based on variable/value selection
   *
   */

  template <class View, class Val, class DomSize, class ViewSel, class ValSel>
  forceinline
  DecomposingViewValBranching<View,Val,DomSize,ViewSel,ValSel>
  ::DecomposingViewValBranching(Space* home, ViewArray<View>& x0)
    : Branching(home), x(x0), start(0), selectFirst(false) {}


  template <class View, class Val, class DomSize, class ViewSel, class ValSel>
  forceinline
  DecomposingViewValBranching<View,Val,DomSize,ViewSel,ValSel>
  ::DecomposingViewValBranching(Space* home, bool share, 
                                DecomposingViewValBranching& b)
    : Branching(home,share,b), start(b.start), selectFirst(b.selectFirst) {
    x.update(home,share,b.x);
  }

  template <class View, class Val, class DomSize, class ViewSel, class ValSel>
  Actor*
  DecomposingViewValBranching<View,Val,DomSize,ViewSel,ValSel>
  ::copy(Space* home, bool share) {
    return new (home)
      DecomposingViewValBranching<View,Val,DomSize,ViewSel,ValSel>(home,
        share,*this);
  }

  template <class View, class Val, class DomSize, class ViewSel, class ValSel>
  bool
  DecomposingViewValBranching<View,Val,DomSize,ViewSel,ValSel>
  ::status(const Space*) const {
    for (int i=start; i < x.size(); i++)
      if (!x[i].assigned()) {
        start = i;
        return true;
      }
    return false;
  }

  template <class View, class Val, class DomSize, class ViewSel, class ValSel>
  const BranchingDesc*
  DecomposingViewValBranching<View,Val,DomSize,ViewSel,ValSel>
  ::description(const Space* home) const {

    assert(!x[start].assigned());

    if (selectFirst && !x[0].assigned()) {
      selectFirst = false;
      ValSel  vl; // For value selection
      if (x.size() == 1) {
        DomSize ds;
        return new Decomposition::SingletonDesc<Val,2>(this,vl.val(home,x[0]),
                                                       0,ds(x[0]));
      } else {
        return new PosValDesc<Val,2>(this,0,vl.val(home,x[0]),0);
      }
    }

    int componentNumber = 1;
    Decomposition::ConstraintGraph::ComponentLabel label;

    if (x.size()-start > 1) {

      // get constraint graph for the variable set x
      Decomposition::ConstraintGraph * cg =
        Decomposition::graph<View>(home, x, start);

      // check for components
      componentNumber = cg->getComponentLabel(label);
      delete cg;  // garbage collection

      // merge singlets together (just optimizing)
      componentNumber = mergeAssigned(label, componentNumber);
    } else if (x[start].degree() == 0) {
      assert(x.size() - start == 1);
      ValSel  vl; // For value selection
      DomSize ds;
      return new Decomposition::SingletonDesc<Val,2>(this,
                                                     vl.val(home,x[start]),
                                                     start, ds(x[start]));
    }

    if (start+1 < x.size() && componentNumber > 1) {
        // do decomposing branching

      int firstLabel;
      std::vector<int> selected = std::vector<int>(componentNumber);

      // calculate component order and view selection for each component
      for (int comp = 0; comp < componentNumber; comp++) {
        int firstLabelIdx = -1;
        ViewSel vs; // For view selection
        int i = start;
        while(label[i-start] >= 0) i++;
        int b = i++;
        if (vs.init(home,x[b]) != VSS_COMMIT) {
          for (; firstLabelIdx == -1 && i < x.size(); i++) {
            if (label[i-start] < 0 && !x[i].assigned()) {
              switch (vs.select(home,x[i])) {
              case VSS_SELECT:
                b=i; break;
              case VSS_COMMIT:
                b=i;
                firstLabelIdx = b; break;
              case VSS_NONE:   break;
              default:         GECODE_NEVER;
              }
            }
          }
        }
        selected[comp] = ((firstLabelIdx == -1) ? b : firstLabelIdx) - start;
        firstLabel = label[selected[comp]];
        //std::cerr <<" s(" <<comp <<") = " <<firstLabel;
        // recoloring of the current component to the current component number
        for(unsigned int j = 0; j<label.size(); j++)
          if (label[j] == firstLabel) 
            label[j] = comp;
      }
      // create decomposition description
      return new Decomposition::DecompDesc(this, start, label, selected);;

    } else {
      // do normal branching

      ViewSel vs; // For view selection
      ValSel  vl; // For value selection
      int i = start;
      int b = i++;
      if (vs.init(home,x[b]) != VSS_COMMIT)
         for (; i < x.size(); i++) {
            if (!x[i].assigned()) {
              switch (vs.select(home,x[i])) {
              case VSS_SELECT:
                b=i; break;
              case VSS_COMMIT:
                b=i;
                return new 
                  PosValDesc<Val,2>(this,b-start,vl.val(home,x[b]),start);
              case VSS_NONE:   break;
              default:         GECODE_NEVER;
              }
            }
         }
      return new PosValDesc<Val,2>(this,b-start,vl.val(home,x[b]),start);
    }

  }

  template <class View, class Val, class DomSize, class ViewSel, class ValSel>
  ExecStatus
  DecomposingViewValBranching<View,Val,DomSize,ViewSel,ValSel>
  ::commit(Space* home, const BranchingDesc* d, unsigned int a) {

    const Decomposition::DecompDesc* dd =
      dynamic_cast<const Decomposition::DecompDesc*>(d);
    if( dd == NULL) { // --> normal handling of PosValDescriptions
      
      const PosValDesc<Val,2>* pvd = static_cast<const PosValDesc<Val,2>*>(d);
      // Eliminate views from x[0] ... x[start-1]
      x.drop_fst(pvd->start()); start = 0;
      ValSel vs;
      return me_failed(vs.tell(home,a,x[pvd->pos()],pvd->val()))
          ? ES_FAILED : ES_OK;
    } else {
      int oldSize = x.size()-start;
      // Eliminate views from x[0] ... x[start-1]
      x.drop_fst(dd->getStart()); start = 0;
      
        // component labeling and label of alternative a
      Decomposition::ConstraintGraph::ComponentLabel myComponent = 
        dd->getComponentLabel();

      // move selected position to the front
      {
        int selected = dd->getSelection(a), toOverwrite=0;
        for (toOverwrite=0; toOverwrite< selected; toOverwrite++) {
          if (myComponent[toOverwrite] == (int)a)
            break;
        }
        if (toOverwrite < selected) {
          View tmp = x[toOverwrite];
          x[toOverwrite] = x[selected];
          x[selected] = tmp;
        }
      }
      selectFirst = true;

      int lastFillPos = 0;
        // find first position that can be overwritten
        for (lastFillPos = 0; lastFillPos<x.size(); lastFillPos++) {
          if (myComponent[lastFillPos] != (int)a)
            break;
        }

        // shift all component elements together
        for (int i=lastFillPos+1; i<x.size(); i++) {
          if (myComponent[i] == (int)a) {
            x[lastFillPos+start] = x[i+start];
            lastFillPos++;
          }
        }

      // Eliminate views from x[lastFillPos] ... x[x.size()-1]
      x.drop_lst(lastFillPos+start-1);
      // restrict propagation if neccessary
      if (oldSize > x.size()) {
        // DDSSpace* ds = dynamic_cast<DDSSpace*>(home);
        // if (ds != NULL)
        //   ds->restrictProp(x, start);
      }
      // no graph generation neccessary after decomposition
      return ES_OK;
    }
  }


  template <class View, class Val, class DomSize, class ViewSel, class ValSel>
  int
  DecomposingViewValBranching<View,Val,DomSize,ViewSel,ValSel>
  ::mergeAssigned(Decomposition::ConstraintGraph::ComponentLabel & label,
                  int labelNumber) 
    const {

    std::vector<int> compSize(labelNumber,0);  // init component sizes
    // remove temporary variables and propagators nodes from labeling
    // resizing the labeling to the variables in context
    label.resize(x.size()-start);

    // check current labeling
    // and remember the label of the last unassigned variable ( == mergeLabel)
    int mergeLabel = 0;
    for (int i=0; i<x.size()-start; i++) {
      compSize[label[i]]++;
      if (!x[start+i].assigned())
        mergeLabel = label[i];
    }

    // count how many colors are really available
    int colors = 0;
    for (std::vector<int>::size_type i = 0; i < compSize.size(); i++) {
      if (compSize[i] > 0 ) {
        colors++;
      }
    }

    // recoloring and color decreasing due to merging of assigned variables
    for (int i=0; i<x.size()-start; i++) {
      if (compSize[label[i]] == 1 && x[i+start].assigned()) {
        label[i] = mergeLabel;
        colors--;
      }
      // invert all indices and substract 1 as a preprocessing for viewSelection
      label[i] = -label[i] - 1;
    }

    // add 1 if 'mergeLabel' is assigned singlet too
    return std::max(colors,1);
  }
}

// STATISTICS: dds-any
