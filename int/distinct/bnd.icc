/*
 *  Main authors:
 *     Christian Schulte <schulte@gecode.org>
 *
 *  Copyright:
 *     Christian Schulte, 2003
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */

#include "support/sort.hh"

namespace Gecode { namespace Int { namespace Distinct {

  template <class View, bool shared>
  inline
  BndImp<View,shared>::BndImp(Space* home, ViewArray<View>& x0)
    : Propagator(home), x(x0), y(home,x0) {
    // Both x and y initially contain the same variables
    //  - x is used for bounds propagation
    //  - y is used for performing singleton propagation
    // They can not be shared as singleton propagation removes
    // determined variables still required for bounds propagation.
    y.subscribe(home,this,PC_INT_BND);
  }

  template <class View, bool shared>
  BndImp<View,shared>::~BndImp(void) {
    y.cancel(this,PC_INT_BND);
  }

  template <class View, bool shared>
  forceinline
  BndImp<View,shared>::BndImp(Space* home, bool share, BndImp<View,shared>& p)
    : Propagator(home,share,p) {
      x.update(home,share,p.x);
      y.update(home,share,p.y);
  }

  template <class View, bool shared>
  Actor*
  BndImp<View,shared>::copy(Space* home, bool share) {
    return new (home) BndImp<View,shared>(home,share,*this);
  }

  template <class View, bool shared>
  PropCost
  BndImp<View,shared>::cost(void) const {
    return (View::pme(this) == ME_INT_VAL)
      ? cost_lo(y.size(),PC_LINEAR_LO)
      : cost_hi(x.size(),PC_LINEAR_HI);
  }


  /// Rank information
  class Rank {
  public:
    int min, max;
  };

  /// Sort-order by increasing maximum
  template <class View>
  class MaxInc {
  protected:
    ViewArray<View> x;
  public:
    MaxInc(const ViewArray<View>& x0) : x(x0) {}
    forceinline bool
    operator()(const int i, const int j) {
      return x[i].max() < x[j].max();
    }
  };

  /// Sort-order by increasing minimum
  template <class View>
  class MinInc {
  public:
    forceinline bool
    operator()(const View& x, const View& y) {
      return x.min() < y.min();
    }
  };

  /// Information on Hall intervals
  class HallInfo {
  public:
    int bounds, t, d, h;
  };

  inline void
  pathset_t(HallInfo hall[], int start, int end, int to) {
    int k, l;
    for (l=start; (k=l) != end; hall[k].t=to) {
      l = hall[k].t;
    }
  }

  inline void
  pathset_h(HallInfo hall[], int start, int end, int to) {
    int k, l;
    for (l=start; (k=l) != end; hall[k].h=to) {
      l = hall[k].h;
    }
  }

  forceinline int
  pathmin_h(const HallInfo hall[], int i) {
    while (hall[i].h < i)
      i = hall[i].h;
    return i;
  }

  forceinline int
  pathmin_t(const HallInfo hall[], int i) {
    while (hall[i].t < i)
      i = hall[i].t;
    return i;
  }

  forceinline int
  pathmax_h(const HallInfo hall[], int i) {
    while (hall[i].h > i)
      i = hall[i].h;
    return i;
  }

  forceinline int
  pathmax_t(const HallInfo hall[], int i) {
    while (hall[i].t > i)
      i = hall[i].t;
    return i;
  }

#define minsorted(i) (i)
#define maxsorted(i) (_maxsorted[i])

  template <class View, bool shared>
  ExecStatus
  prop_bnd(Space* home, ViewArray<View>& x) {
    // Sort variable array for minimum directly
    MinInc<View> min_inc;
    Support::insertion<View,MinInc<View> >(&x[0], x.size(), min_inc);

    const int n = x.size();

    GECODE_AUTOARRAY(int, _maxsorted, n);
    for (int i = n; i--; )
      _maxsorted[i]=i;

    MaxInc<View> max_inc(x);
    Support::insertion<int,MaxInc<View> >(_maxsorted, n, max_inc);

    // Setup rank and bounds info
    GECODE_AUTOARRAY(HallInfo, hall, 2*n+2);
    GECODE_AUTOARRAY(Rank,     rank, n);

    int nb = 0;
    {
      int min  = x[minsorted(0)].min();
      int max  = x[maxsorted(0)].max() + 1;
      int last = min - 2;

      hall[0].bounds = last;

      int i = 0;
      int j = 0;
      while (true) {
	if (i < n && min < max) {
	  if (min != last)
	    hall[++nb].bounds = last = min;
	  rank[minsorted(i)].min = nb;
	  if (++i < n)
	    min = x[minsorted(i)].min();
	} else {
	  if (max != last)
	    hall[++nb].bounds = last = max;
	  rank[maxsorted(j)].max = nb;
	  if (++j == n)
	    break;
	  max = x[maxsorted(j)].max() + 1;
	}
      }
      hall[nb+1].bounds = hall[nb].bounds + 2;
    }

    // If tells cross holes, we do not compute a fixpoint
    ExecStatus es = ES_FIX;

    // Propagate lower bounds
    for (int i=nb+2; --i;) {
      hall[i].t = hall[i].h = i-1;
      hall[i].d = hall[i].bounds - hall[i-1].bounds;
    }
    for (int i=0; i<n; i++) { // visit intervals in increasing max order
      int x0 = rank[maxsorted(i)].min;
      int z = pathmax_t(hall, x0+1);
      int j = hall[z].t;
      if (--hall[z].d == 0)
	hall[z = pathmax_t(hall, hall[z].t=z+1)].t = j;
      pathset_t(hall, x0+1, z, z); // path compression
      int y = rank[maxsorted(i)].max;
      if (hall[z].d < hall[z].bounds-hall[y].bounds)
	return ES_FAILED;
      if (hall[x0].h > x0) {
	int w = pathmax_h(hall, hall[x0].h);
	int m = hall[w].bounds;
	// Check whether there are tells to shared variables
	if (shared && x[maxsorted(i)].modified())
	  es = ES_NOFIX;
	ModEvent me = x[maxsorted(i)].gq(home,m);
	if (me_failed(me))
	  return ES_FAILED;
	if (me_modified(me) && (m != x[maxsorted(i)].min()))
	  es = ES_NOFIX;
	pathset_h(hall, x0, w, w); // path compression
      }
      if (hall[z].d == hall[z].bounds-hall[y].bounds) {
	pathset_h(hall, hall[y].h, j-1, y); // mark hall interval
	hall[y].h = j-1;
      }
    }

    // Propagate upper bounds
    for (int i=nb+1; i--;) {
      hall[i].t = hall[i].h = i+1;
      hall[i].d = hall[i+1].bounds - hall[i].bounds;
    }
    for (int i=n; --i>=0; ) { // visit intervals in decreasing min order
      int x0 = rank[minsorted(i)].max;
      int z = pathmin_t(hall, x0-1);
      int j = hall[z].t;
      if (--hall[z].d == 0)
	hall[z = pathmin_t(hall, hall[z].t=z-1)].t = j;
      pathset_t(hall, x0-1, z, z);
      int y = rank[minsorted(i)].min;
      if (hall[z].d < hall[y].bounds-hall[z].bounds)
	return ES_FAILED;
      if (hall[x0].h < x0) {
	int w = pathmin_h(hall, hall[x0].h);
	int m = hall[w].bounds - 1;
	// Test again for sharing: this is quite inaccurate as there
	// are two opreations perfomed per variable: hence if both
	// lower and upper bound are changed, and shared is true,
	// the propagator will report to be not at fixpoint.
	if (shared && x[maxsorted(i)].modified())
	  es = ES_NOFIX;
	ModEvent me = x[minsorted(i)].lq(home,m);
	if (me_failed(me))
	  return ES_FAILED;
	if (me_modified(me) && (m != x[minsorted(i)].max()))
	  es = ES_NOFIX;
	pathset_h(hall, x0, w, w);
      }
      if (hall[z].d == hall[y].bounds-hall[z].bounds) {
	pathset_h(hall, hall[y].h, j+1, y);
	hall[y].h = j+1;
      }
    }

    return es;
  }

#undef minsorted
#undef maxsorted

  template <class View, bool shared>
  ExecStatus
  BndImp<View,shared>::propagate(Space* home) {
    assert(x.size() > 1);

    if (View::pme(this) == ME_INT_VAL) {
      ExecStatus es = prop_val<View,false>(home,y);
      if ((es == ES_FAILED) || (es == ES_SUBSUMED))
	return es;
      if (es == ES_FIX)
	return ES_FIX_PARTIAL(View::pme(ME_INT_BND));
    }

    if (y.size() == 2) {
      GECODE_ES_CHECK(Rel::Nq<View>::post(home,y[0],y[1]));
      return ES_SUBSUMED;
    }

    return prop_bnd<View,shared>(home,x);
  }

  template <class View>
  ExecStatus
  Bnd<View>::post(Space* home, ViewArray<View>& x){
    if (x.size() == 2)
      return Rel::Nq<View>::post(home,x[0],x[1]);
    if (x.size() > 2)
      if (x.shared()) {
	if (x.same())
	  return ES_FAILED;
	else
	  (void) new (home) BndImp<View,true>(home,x);
      } else {
	(void) new (home) BndImp<View,false>(home,x);
      }
    return ES_OK;
  }


}}}

// STATISTICS: int-prop

