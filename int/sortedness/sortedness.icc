/*
 *  Main authors:
 *     Patrick Pekczynski <pekczynski@ps.uni-sb.de>
 *
 *  Copyright:
 *     Patrick Pekczynski, 2004
 *
 *  Last modified:
 *     $Date$ by $Author$
 *     $Revision$
 *
 *  This file is part of Gecode, the generic constraint
 *  development environment:
 *     http://www.gecode.org
 *
 *  See the file "LICENSE" for information on usage and
 *  redistribution of this file, and for a
 *     DISCLAIMER OF ALL WARRANTIES.
 *
 */	

namespace Gecode { namespace Int { namespace Sortedness {


  /* 
   * Summary of the propagation algorithm as implemented in the
   * propagate method below:
   *
   * STEP 1: Normalize the domains of the y variables
   * STEP 2: Sort the domains of the x variables according to their lower
   *         and upper endpoints
   * STEP 3: Compute the matchings phi and phiprime with 
   *         Glover's matching algorithm
   * STEP 4: Compute the strongly connected components in 
   *         the oriented intersection graph
   * STEP 5: Narrow the domains of the variables
   *
   */

  /**
   * \brief Perform bounds consistent sortedness propagation 
   *
   * Implements the propagation algorithm for Sortedness::Sortedness
   * and is provided as seperate function, because a second pass of 
   * the propagation algorithm is needed in order to achieve idempotency
   * in case explicit permutation variables are provided. 
   * 
   * If \a Perm is true, permutation variables form the 
   * third argument which implies additional inferences, 
   * consistency check on the permutation variables and eventually a
   * second pass of the propagation algorithm. 
   * Otherwise, the algorithm does not take care of the permutation 
   * variables resulting in a better performance. 
   */

  template<class View, class Tuple, bool Perm, bool shared>
  ExecStatus  
  bounds_propagation(Space* home, 
		     ViewArray<Tuple>& xz, 
		     ViewArray<View>& y, 
		     bool& repairpass, 
		     bool& nofix, 
		     bool& match_fixed){

    int n        = xz.size();

    GECODE_AUTOARRAY(int, tau,      n);
    GECODE_AUTOARRAY(int, phi,      n);
    GECODE_AUTOARRAY(int, phiprime, n);
    GECODE_AUTOARRAY(OfflineMinItem, sequence, n);
    GECODE_AUTOARRAY(int, vertices, n);

    if (match_fixed) {
      // sorting is determined
      // sigma and tau coincide
      for (int i = xz.size(); i--; ) {
	int pi = xz[i][1].val();
	tau[pi] = i;
      }
    } else {
      for (int i = n; i--; ) {
	tau[i] = i;
      }
    }
    
    bool yval    = true;
    bool ysorted = true;
    for (int i = n; i--; ) {
      yval    &= y[i].assigned();
      if (i) {
	ysorted &= (y[i].min() <= y[i - 1].min() &&
		    y[i].max() <= y[i - 1].max());
      }
    }

    if (Perm) {

      // normalized and sorted
      // collect all bounds
      int mib = y[0].min();
      int mab = y[n - 1].max();
      int ivs = (mab - mib + 1);
      GECODE_AUTOARRAY(Rank, allbnd, ivs);
      int iter = mib;
      int idx = 0;
      while(iter <= mab && idx < n) {
	if (y[idx].min() > iter) {
	  // idx cannot be zero because consisteny in posting
	  assert(idx > 0);
	  allbnd[iter - mib].min = idx;
	  allbnd[iter - mib].max = idx - 1;
	  iter++;
	} else {
	  if (y[idx].min() <= iter && iter <= y[idx].max() ) {
	    allbnd[iter - mib].min = idx;
	    allbnd[iter - mib].max = idx;
	    iter++;
	  } else {
	    idx++;
	  }
	}
      }

      iter = mab;
      idx = n -1;
      while(iter >= mib && idx >= 0) {
	if (y[idx].min() > iter) {
	  // idx cannot be zero because consisteny in posting
	  assert(idx > 0);
	  allbnd[iter - mib].max = idx - 1;
	  iter--;
	} else {
	  if (y[idx].min() <= iter && iter <= y[idx].max() ) {
	    allbnd[iter - mib].max = idx;
	    iter--;
	  } else {
	    idx--;
	  }
	}
      }

      for (int i = n; i--; ) {
	// first reachable y bound
	if (shared && xz[i][0].modified()) {
	  return ES_NOFIX;
	}
	// minimum reachable y-variable
	int minr = allbnd[xz[i][0].min() - mib].min;
	int maxr = allbnd[xz[i][0].max() - mib].max;

	ModEvent me = xz[i][0].gq(home, y[minr].min());
	if (me_failed(me)) {
	  return ES_FAILED;
	}
	nofix |= (me_modified(me) && 
		  xz[i][0].min() != y[minr].min());

	me = xz[i][0].lq(home, y[maxr].max());
	if (me_failed(me)) {
	  return ES_FAILED;
	}
	nofix |= (me_modified(me) && 
		  xz[i][0].min() != y[maxr].max());

	me = xz[i][1].gq(home, minr);
	if (me_failed(me)) {
	  return ES_FAILED;
	}
	nofix |= (me_modified(me) &&  xz[i][1].min() != minr);

	me = xz[i][1].lq(home, maxr);
	if (me_failed(me)) {
	  return ES_FAILED;
	}
	nofix |= (me_modified(me) &&  xz[i][1].max() != maxr);

      }
      // x vars and z vars are consistent

      for (int i = n; i--; ) {
	if (xz[i][1].assigned()) {

	  // if the permutation variable is determined
	  
	  int v = xz[i][1].val();
	  if (xz[i][0].assigned()) {
	    // channel equality from x to y
	    if (shared && y[v].modified()) {
	      return ES_NOFIX;
	    }
	    GECODE_ME_CHECK(y[v].eq(home, xz[i][0].val()));
	  } else {
	    if (y[v].assigned()) {
	      // channel equality from y to x
	      if (shared && xz[i][0].modified()) {
		return ES_NOFIX;
	      }
	      GECODE_ME_CHECK(xz[i][0].eq(home, y[v].val()));
	    } else {
	      // constrain upper bound
	      if (shared && xz[i][0].modified()) {
		return ES_NOFIX;
	      }
	      ModEvent me = xz[i][0].lq(home, y[v].max());
	      if (me_failed(me)) {
		return ES_FAILED;
	      }
	      nofix |= (me_modified(me) && xz[i][0].max() != y[v].max());

	      // constrain lower bound
	      if (shared && xz[i][0].modified()) {
		return ES_NOFIX;
	      }
	      
	      me = xz[i][0].gq(home, y[v].min());
	      if (me_failed(me)) {
		return ES_FAILED;
	      }
	      nofix |= (me_modified(me) && xz[i][0].min() != y[v].min());

	      // constrain the sorted variable
	      // constrain upper bound
	      if (shared && y[v].modified()) {
		return ES_NOFIX;
	      }

	      me = y[v].lq(home, xz[i][0].max());
	      if (me_failed(me)) {
		return ES_FAILED;
	      }
	      nofix |= (me_modified(me) && y[v].max() != xz[i][0].max());

	      // constrain lower bound
	      if (shared && y[v].modified()) {
		return ES_NOFIX;
	      }
	      
	      me = y[v].gq(home, xz[i][0].min());
	      if (me_failed(me)) {
		return ES_FAILED;
	      }
	      nofix |= (me_modified(me) && y[v].min() != xz[i][0].min());
	    }
	  }
	} else {
	  
	  // if the permutation variable is undetermined
	  int l = xz[i][1].min();
	  int r = xz[i][1].max();
	 
	  // upper bound
	  if (shared && xz[i][0].modified()) {
	    return ES_NOFIX;
	  }

	  ModEvent me = xz[i][0].lq(home, y[r].max());
	  if (me_failed(me)) {
	    return ES_FAILED;
	  }
	  nofix |= (me_modified(me) && xz[i][0].max() != y[r].max());

	  // lower bound
	  if (shared && xz[i][0].modified()) {
	    return ES_NOFIX;
	  }
	    
	  me = xz[i][0].gq(home, y[l].min());
	  if (me_failed(me)) {
	    return ES_FAILED;
	  }
	  nofix |= (me_modified(me) && xz[i][0].min() != y[l].min());
	}
      }
      if (nofix) {
	return ES_NOFIX;
      }
    }

    /* 
     * STEP 1:
     *  normalization is implemented in "sortedness/order.icc"
     *    o  setting the lower bounds of the y_i domains (\lb E_i)
     *       to max(\lb E_{i-1},\lb E_i)
     *    o  setting the upper bounds of the y_i domains (\ub E_i) 
     *       to min(\ub E_i,\ub E_{i+1})
     */

    if (!normalize<View, Tuple, shared>(home, y, xz, nofix)) {
      return ES_FAILED;
    }

    if (shared && nofix) {
      return ES_NOFIX;
    }

    // if bounds have changed we have to recreate sigma to restore
    // optimized dropping of variables

    if (!match_fixed) {
      sort_sigma<View, Tuple, Perm>(xz, match_fixed);
    }

    bool subsumed   = true;
    bool array_subs = false;
    int  dropfst  = 0;
    bool noperm_bc = false;

    if (!(check_subsumption<View, Tuple, Perm>
	  (home, xz, y, subsumed, dropfst)) ||
	!(array_assigned<View, Tuple, Perm, shared>
	  (home, xz, y, array_subs, match_fixed, nofix, noperm_bc))) {
      return ES_FAILED;
    }

    if (shared && nofix) {
      return ES_NOFIX;
    }

    if (subsumed || array_subs) {
      return ES_SUBSUMED; 
    }


    /*
     * STEP 2: creating tau 
     * Sort the domains of the x variables according 
     * to their lower bounds, where we use an 
     * intermediate array of integers for sorting
     */
    sort_tau<View, Tuple, Perm>(xz, tau);

    /* 
     * STEP 3:
     *  Compute the matchings \phi and \phi' between 
     *  the x and the y variables
     *  with Glover's matching algorithm.
     *        o  phi is computed with the glover function
     *        o  phiprime is computed with the revglover function
     *  glover and revglover are implemented in "sortedness/matching.icc"
     */

    if (!match_fixed) {

      if (!glover<View, Tuple, Perm>
	  (home, xz, y, tau, phi, sequence, vertices)) {
	return ES_FAILED;
      }
    } else {
      for (int i = xz.size(); i--; ) {
	phi[i]      = xz[i][1].val();
	phiprime[i] = phi[i];
      }
    }

    if(!yval) {
      // phiprime is not needed to narrow the domains of the x-variables
      if (!match_fixed) {
	if (!revglover<View, Tuple, Perm>
	    (home, xz, y, tau, phiprime, sequence, vertices)) {
	  return ES_FAILED;
	}
      } 
      
      if (!narrow_domy<View, Tuple, Perm, shared>
	  (home, xz, y, phi, phiprime, nofix)) {
	return ES_FAILED;
      }

      if (shared && nofix) {
	return ES_NOFIX;
      }

      if (nofix && !match_fixed) {
	// data structures (matching) destroyed by domains with holes
	    
	for (int i = y.size(); i--; ) {
	  phi[i] = 0;
	  phiprime[i] = 0;
	}
	if (!glover<View, Tuple, Perm>
	    (home, xz, y, tau, phi, sequence, vertices)) {
	  return ES_FAILED;
	}
	    
	if (!revglover<View, Tuple, Perm>
	    (home, xz, y, tau, phiprime, sequence, vertices)) {
	  return ES_FAILED;
	}

	if (!narrow_domy<View, Tuple, Perm, shared>
	    (home, xz, y, phi, phiprime, nofix)) {
	  return ES_FAILED;
	}

	if (shared && nofix) {
	  return ES_NOFIX;
	}

      }
    }

    /* 
     * STEP 4:
     *  Compute the strongly connected components in 
     *  the oriented intersection graph
     *  the computation of the sccs is implemented in 
     *  "sortedness/narrowing.icc" in the function narrow_domx
     */

    GECODE_AUTOARRAY(int,          scclist, n);
    GECODE_AUTOARRAY(SccComponent, sinfo  , n);
    
    for(int i = n; i--; ) {
      sinfo[i].left       = i;
      sinfo[i].right      = i;
      sinfo[i].rightmost  = i;
      sinfo[i].leftmost   = i;
    }

    computesccs<View>(home, xz, y, phi, sinfo, scclist);

    /*
     * STEP 5:
     *  Narrow the domains of the variables
     *  Also implemented in "sortedness/narrowing.icc"
     *  in the functions narrow_domx and narrow_domy
     */

    if (!narrow_domx<View, Tuple, Perm, shared>
	(home, xz, y, tau, phi, scclist, sinfo, nofix)) {
      return ES_FAILED;
    }

    if (shared && nofix) {
      return ES_NOFIX;
    }
    
    if (Perm) {
      if (!noperm_bc) {
	if (!perm_bc<View, Tuple, Perm, shared>
	    (home, tau, sinfo, scclist, xz, repairpass, nofix)) {
	  // std::cout << "perm bc failed\n";
	  return ES_FAILED;
	}

	if (shared && nofix) {
	  return ES_NOFIX;
	}
      
      }
    }

    return nofix ? ES_NOFIX : ES_FIX;
  } 
  
  template<class View, class Tuple, bool Perm, bool shared>
  Sortedness<View, Tuple, Perm, shared>::
  Sortedness(Space* home, bool share, Sortedness<View, Tuple, Perm, shared>& p):
    Propagator(home, share, p), 
    reachable(p.reachable) {
    xz.update(home, share, p.xz);
    y.update(home, share, p.y);
    w.update(home, share, p.w);
  }

  template<class View, class Tuple, bool Perm, bool shared>
  Sortedness<View, Tuple, Perm, shared>::
  Sortedness(Space* home, ViewArray<Tuple>& xz0, ViewArray<View>& y0):
    Propagator(home,true), xz(xz0), y(y0), w(home, y0), reachable(-1) {
    xz.subscribe(home, this, PC_INT_BND);
    y.subscribe(home, this, PC_INT_BND);
    
  }

  template<class View, class Tuple, bool Perm, bool shared>
  Sortedness<View, Tuple, Perm, shared>::~Sortedness(void) {
    xz.cancel(this, PC_INT_BND);
    y.cancel(this, PC_INT_BND);
  }

  template<class View, class Tuple, bool Perm, bool shared>
  Actor* Sortedness<View, Tuple, Perm, shared>::copy(Space* home, bool share) {
    return new (home) Sortedness<View, Tuple, Perm, shared>(home, share, *this);
  }

  template<class View, class Tuple, bool Perm, bool shared>
  PropCost Sortedness<View, Tuple, Perm, shared>::cost(void) const {
    return PC_LINEAR_LO;
  }

  template<class View, class Tuple, bool Perm, bool shared>
  ExecStatus
  Sortedness<View, Tuple, Perm, shared>::propagate(Space* home) {

    int  n           = xz.size();
    bool secondpass  = false; 
    bool nofix       = false;
    int  dropfst     = 0;

    bool subsumed    = false;
    bool array_subs  = false;
    bool match_fixed = false;

    // normalization of x and y
    if (!normalize<View, Tuple, shared>(home, y, xz, nofix)) {
      return ES_FAILED;
    }

    // create sigma sorting
    sort_sigma<View, Tuple, Perm>(xz, match_fixed);


    if (shared && nofix) {
      return ES_NOFIX;
    }
    bool noperm_bc = false;
    if (!array_assigned<View, Tuple, Perm, shared>
	(home, xz, y, array_subs, match_fixed, nofix, noperm_bc)) {
      return ES_FAILED;
    }

    if (shared && nofix) {
      return ES_NOFIX;
    }

    if (array_subs) {
      return ES_SUBSUMED;
    }

    if (match_fixed) {
      sort_sigma<View, Tuple, Perm>(xz, match_fixed);
    }
    
    // in this case check_subsumptions is guaranteed to find
    // the xs ordered by sigma

    if (!check_subsumption<View, Tuple, Perm>
	(home, xz, y, subsumed, dropfst)) {
      return ES_FAILED;
    }

    if (shared && nofix) {
      return ES_NOFIX;
    }

    if (subsumed) {
      return ES_SUBSUMED; 
    }	  

    // If explicit permutation variables are used

    if (Perm) {
      // dropping possibly yields inconsistent indices on permvars

      if (dropfst) {
	reachable = w[dropfst - 1].max();
	bool unreachable = true;
	for (int i = xz.size(); unreachable && i-- ; ) {
	  unreachable &= (reachable < xz[i][0].min());
	}

	if (unreachable) {
	  xz.drop_fst(dropfst, this, PC_INT_BND);
	  y.drop_fst (dropfst, this, PC_INT_BND);
	} else {
	  dropfst = 0;
	}
      }

      n = xz.size();

      if (n < 2) {
	if (xz[0][0].max() < y[0].min() || y[0].max() < xz[0][0].min()) {
	  return ES_FAILED;
	} else {
	  Rel::EqBnd<View>::post(home, xz[0][0], y[0]);

	  // in this case xz[0] is the rightmost problem variable
	  if (shared && xz[0][1].modified()) {
	    return ES_NOFIX;
	  }

	  GECODE_ME_CHECK(xz[0][1].eq(home, w.size() - 1));

	  return ES_SUBSUMED;
	}
      }

      // check whether shifting the permutation variables 
      // is necessary after dropping x and y vars

      // highest reachable index
      int  valid = n - 1; 
      int  index = 0;     
      int  shift = 0;

      for (int i = n; i--; ){
	if (xz[i][1].max() > index) {
	  index = xz[i][1].max();
	}
	if (index > valid) {
	  shift = index - valid;
	}
      }

      if (shift) {
	
     	ViewArray<ViewTuple<OffsetView,2> > oxz(home, n);
	ViewArray<OffsetView> oy(home, n);

	for (int i = n; i--; ) {

	  GECODE_ME_CHECK(xz[i][1].gq(home, shift)); 

	  oxz[i][1] = OffsetView(xz[i][1], -shift);
	  oxz[i][0] = OffsetView(xz[i][0], 0);
	  oy[i] = OffsetView(y[i], 0);
	}

	GECODE_ES_CHECK((bounds_propagation<OffsetView, 
			 ViewTuple<OffsetView,2>, Perm, shared >
			 (home, oxz, oy, secondpass, nofix, match_fixed)));

	if (secondpass) {
	  GECODE_ES_CHECK((bounds_propagation<OffsetView, 
			   ViewTuple<OffsetView,2>, Perm, shared >
			   (home, oxz, oy, secondpass, nofix, match_fixed)));
	}
      } else {
	GECODE_ES_CHECK((bounds_propagation<View, Tuple, Perm, shared>
			 (home, xz, y, secondpass, nofix, match_fixed)));

	if (secondpass) {
	  GECODE_ES_CHECK((bounds_propagation<View, Tuple, Perm, shared>
			   (home, xz, y, secondpass, nofix, match_fixed)));
	}
      }
    } else {
      // dropping has no consequences

      if (dropfst) {
	xz.drop_fst(dropfst, this, PC_INT_BND);
	y.drop_fst (dropfst, this, PC_INT_BND);
      }

      n = xz.size();

      if (n < 2) {
	if (xz[0][0].max() < y[0].min() || y[0].max() < xz[0][0].min()) {
	  return ES_FAILED;
	} else {
	  Rel::EqBnd<View>::post(home, xz[0][0], y[0]);
	  return ES_SUBSUMED;
	}
      }
      GECODE_ES_CHECK((bounds_propagation<View, Tuple, Perm, shared>
		       (home, xz, y, secondpass, nofix, match_fixed)));
      // no second pass possible if there are no permvars
    }

    if (!normalize<View, Tuple, shared>(home, y, xz, nofix)) {
      return ES_FAILED;
    }

    subsumed   = true;
    array_subs = false;
    noperm_bc  = false;
    // creating sorting anew
    if (!match_fixed) {
      sort_sigma<View, Tuple, Perm>(xz, match_fixed);
    } 

    if (!array_assigned<View, Tuple, Perm, shared>
	(home, xz, y, array_subs, match_fixed, nofix, noperm_bc)) {
      return ES_FAILED;
    }

    if (array_subs) {
      return ES_SUBSUMED;
    }

    if (!check_subsumption<View, Tuple, Perm>
	(home, xz, y, subsumed, dropfst)) {
      return ES_FAILED;
    }

    if (subsumed) {
      return ES_SUBSUMED;
    }

    return nofix ? ES_NOFIX : ES_FIX;
  }

  template<class View, class Tuple, bool Perm, bool shared>
  ExecStatus
  Sortedness<View, Tuple, Perm, shared>::
  post(Space* home, ViewArray<Tuple>& xz0, ViewArray<View>& y0) {
    int n = xz0.size();
    if (n < 2) {
      if ((xz0[0][0].max() < y0[0].min()) || (y0[0].max() < xz0[0][0].min())) {
	return ES_FAILED;
      } else {
	Rel::EqBnd<View>::post(home, xz0[0][0], y0[0]);
	if (Perm) {
	  GECODE_ME_CHECK(xz0[0][1].eq(home, 0));
	}
      }
    } else { 
      new (home) Sortedness<View, Tuple, Perm, shared>(home, xz0, y0); 
    }
    return ES_OK;
  }
  
}}}

// STATISTICS: int-prop

  
  
