/*
 * Author: Morten Nielsen
 * Date: 2005-02-10
 * File: controller.icc
 * Description:
 * This file contains the definition of some of the functions in the
 * controller class for the parallel engine for the Gecode project.
 *
 * History:
 * 2005-02-10: Morten Nielsen : This file is created
 * 2005-02-16: Morten Nielsen
 *						 change to use templates. fixed find, no longer checks all
 *             workers. Also uses mutex locks for access too control.
 * 2005-03-07: Morten Nielsen
 *             Cleaning up after deadlock hunt. Also fixed worker array to be
 *             of dynamic size.
 * 2005-03-08: Morten Nielsen : Find now uses spaces instead of nodes.
 * 2005-03-09: Morten Nielsen : This file is added to GECODE.
 * 2005-05-07: Morten Nielsen
 *             The stop function now takes the new solution as input, in
 *             preparation for bestsolution search. Best solution search
 *             now only needs the searchscript. Also ShareStrategy is added.
 */

 //#include <iostream>
 #include <pthread.h>
 using namespace std;



 template <class T, class SearchScript>
 Controller<T, SearchScript>::Controller(T* root, int n, ShareStrategy* o): n_workers(n), cur_sol(NULL) {
   //Initialize the workers in the workers[] array.
	
	 workers = new Worker<T, SearchScript>* [n_workers];
	
	 pthread_mutex_init(&control, NULL);
	 pthread_cond_init(&cond_sol, NULL);
	 pthread_mutex_init(&solution, NULL);
	 pthread_cond_init(&cond_workers, NULL);
	pthread_barrier_init(&start, NULL , (unsigned int) (n_workers+1));
	 cur_sol = NULL;
	
	
	

   for(int i=1; i < n_workers; i++) {
     workers[i] = new Worker<T, SearchScript>(this, &start, cond_workers,o);
   }
	
	 //We give the initial space to the first worker.
   workers[0] = new Worker<T, SearchScript>(this, &start, cond_workers, root,o);

   pthread_barrier_wait(&start);
	 cout << "search engine ready to chop wood sir!" << endl;
 }

 //Basicly the same constructor as above, except that it passes arguments for
 //the search engines.
 template <class T, class SearchScript>
 Controller<T, SearchScript>::Controller(T* root, int c_d, int a_d, int n, ShareStrategy* o): n_workers(n), cur_sol(NULL) {
   //Initialize the workers in the workers[] array.
	

	 int res;
	 res = pthread_mutex_init(&control, NULL);
	 if(res) cout << "control mutex failed" << endl;
	 res = pthread_cond_init(&cond_sol, NULL);
	 if(res) cout << "control cond failed" << endl;
	 res = pthread_mutex_init(&solution, NULL);
	 if(res) cout << "solution mutex failed" << endl;
	 res = pthread_cond_init(&cond_workers, NULL);
	 if(res) cout << "workers cond failed" << endl;
	//cond_workers = PTHREAD_COND_INITIALIZER;
	 cur_sol = NULL;
	 pthread_barrier_init(&start, NULL , (unsigned int) (n_workers+1));

	//This is most likely not the best way to solve this, this is a temporary solution
  //for now.	 
	SearchScript* t = new SearchScript(a_d, c_d);
	 workers = t->init(n_workers,&start, this,cond_workers, root, o, a_d, c_d);
	delete t;
  
	 /*for(int i=1; i < n_workers; i++) {
     workers[i] = new Worker<T, SearchScript>(this, &start, cond_workers, c_d, a_d,o);
   }
	
	 //We give the initial space to the first worker.
   workers[0] = new Worker<T, SearchScript>(this, &start, cond_workers, c_d, a_d, root, o);
	*/
	
	 pthread_barrier_wait(&start);
	 //cout << "search engine ready to chop wood sir!" << endl;
 }

 template <class T, class SearchScript>
 Controller<T, SearchScript>::~Controller() {
     delete [] workers;
 }

 //This function is used to find work from the workers. It calls share to each
 //worker in turn.
 //This function needs to work with spaces, rather than working with nodes.
 template <class T, class SearchScript>
 T* Controller<T, SearchScript>::find(unsigned int &alt, void* option) {
	 searches++;
	 int res = pthread_mutex_trylock(&control);
	 if(res != EBUSY) {
	 T* t = NULL;
	 int working = 0;
	//cout << "controller: finding work." << endl;
   for(int i=0; i < n_workers; i++) { //Calling functions on all workers. fixed.
		// cout << "controller: checking worker " << i << endl;
		 if(workers[i]->getStatus() == WORKER_WORKING) working++;
		 t = workers[i]->share(alt, option);
     if(t != NULL) {
			  pthread_mutex_unlock(&control);
			  shares++;
			  return t;
		 }
   }
	 if(working == 0) {
		    for(int i = 0; i < n_workers; i++) {
			 workers[i]->stop(NULL);
		 //  cout << "stopped thread " << i << endl;
		 }
		 		 pthread_cond_signal(&cond_sol);
	 }
	 pthread_mutex_unlock(&control);
  }
	 return NULL;
 }

 //This function tells each worker to start looking for a solution.
 template <class T, class SearchScript>
 T* Controller<T, SearchScript>::next() {
	 SearchScript* t = new SearchScript(0, 0);
	 T* b = NULL;
	 restart:
	 
	 cur_sol = NULL;
   //T* s = NULL;
	
	 //cout << "starting workers" << endl;
	 //Set all the workers to work.
	 pthread_mutex_lock(&control);
	 //pthread_barrier_wait(&start);
   for(int i = 0; i < n_workers; i++)		 workers[i]->explore();
   int res = pthread_cond_broadcast(&cond_workers);
	 pthread_mutex_unlock(&control);
	 //Wait for mutexlock here. doesnt work... what if no work left.
	 //Start a thread to check if all workers have work.

	
	//cout << "workers started" << endl;
	//  struct timespec tv;
	//	 tv.tv_nsec = 700;
	//   tv.tv_sec = 0;
	
	//	int working = n_workers;

	 	 pthread_mutex_lock(&solution);
		//cout << "new explore" << endl;
		//pthread_cond_timedwait(&cond_sol, &solution, &tv);
		
		
		//cout << "Broadcast results: " << res << endl;
	  //The broadcast starts the worker threads.
	  //The cond_sol is signaled when a solution is found or the find() functions
	  //sees that there are no workers working.
		pthread_cond_wait(&cond_sol, &solution);
		pthread_mutex_unlock(&solution);

	/* if(t->bab()&&cur_sol != NULL) {
		 delete b;
		 b = cur_sol;
		 //cerr << "starting new search" << endl;
		 for(int i = 0; i < n_workers; i++)		 workers[i]->explore();
		 goto restart;
	 }
	 if(t->bab()&& cur_sol ==	NULL) cur_sol = b; */
   return cur_sol;
 }

 template <class T, class SearchScript>
 inline
 int
 Controller<T, SearchScript>::collect(T* s) {
	 int r = pthread_mutex_trylock(&control);
	 if(r != EBUSY) {
	 pthread_mutex_lock(&solution);
	 //cout << "collecting.. " << endl;
	 if((cur_sol == NULL)) { cur_sol = s; //Need to check this..

		 unsigned int a;
		 if(cur_sol->status(a) != SS_SOLVED) cout << "trubbel med lÃ¶sning!!!" << endl;
	// cout << "stopping threads" << endl;
   //We have found a solution stop all work.
   for(int i = 0; i < n_workers; i++) {
			 workers[i]->stop(s);
		 //  cout << "stopped thread " << i << endl;
		 }
		 //Singal the condition to make controller check.
		
	 //cout << "all threads stopped" << endl;
	 pthread_mutex_unlock(&solution);
   pthread_cond_signal(&cond_sol);	
		 pthread_mutex_unlock(&control);
		 return 1;
	 }
	//cout << "wrong exit" << endl;
	 return 0;
 }
 //cout << "wrong exit 2" << endl;
 //cout << "EINVAL " << (r == EINVAL) << endl << "EDEADLK " << (r == EDEADLK) << endl << "EBUSY " << (r == EBUSY) << endl;
 return 0;
 }

 template <class T, class SearchScript>
 ParallelStatistics
 Controller<T, SearchScript>::statistics(void) {
	
	 ParallelStatistics t;
	 for(int i=0;i<n_workers;i++) {
		ParallelStatistics s = workers[i]->stats();
		t.propagate += s.propagate;
		t.fail += s.fail;
		t.clone += s.clone;
		t.commit += s.commit;
		t.memory += s.memory;
	 }
	 t.searches = searches;
	 t.shares = shares;
	 return t;
 }
