/*
 * Author: Morten Nielsen
 * Date: 2005-02-10
 * File: worker.icc
 * Description:
 * This file contains the definition of some of the functions in the
 * worker class for the parallel engine for the Gecode project.
 *
 * History:
 * 2005-02-10: Morten Nielsen : This file is created
 * 2005-02-15: Morten Nielsen
 *						 minor changes and "bugfixes", adjustment to working with
 *             templates and to use "searchScript" instead of doing search
 *             directly in the worker class.
 * 2005-02-16: Morten Nielsen 
 *             Added contructor that takes space as argument. Added mutexlocks.
 * 2005-02-21: Morten Nielsen Bug hunt.
 * 2005-03-07: Morten Nielsen : Cleaning up after deadlock hunt.
 * 2005-03-08: Morten Nielsen : Share now uses spaces.
 * 2005-03-09: Morten Nielsen : This file is combined and added to GECODE.
 * 2005-05-04: Morten Nielsen : Chaning so commiting is done in the sharee
 * 2005-05-07: Morten Nielsen 
 *             The stop function now takes the new solution as input, in
 *             preparation for bestsolution search. Best solution search
 *             now only needs the searchscript. Also ShareStrategy is added.
 *             Made a slight change to when status changes, should take care
 *             of premature stop of search.
 * 2005-05-16: Morten Nielsen : The find function wasnt updating status correctly.
 *
 */
 
 using namespace std;
 //This method makes the worker stop its search.
 template <class T, class SearchScript>
 void Worker<T, SearchScript>::stop(T* newSolution){
	 //cout << "stopping " << tid << endl;
	 pthread_mutex_lock(&search);
	 this->pause = 1;
	 status = WORKER_IDLE;

	 //cerr << "test start" << endl;
	 se->solution(newSolution);
	 pthread_mutex_unlock(&search);
	 //cerr << "test done" << endl;
	 //if(tid != 0)	 pthread_cancel(tid);
 	 //cout << tid << " canceled" << endl;
	 //tid = 0;
 }
 
template <class T, class SearchScript>
 inline
 T* Worker<T, SearchScript>:: share(unsigned int &alt, void* option) {
	 if(this->pause) return NULL;
	 if(this->searching) return NULL;
	 if(this->tid == 0) return NULL;
	 if(this->status == WORKER_IDLE) return NULL;
	 if(se->status() == SEARCH_DONE) return NULL;
   T* s = NULL;
	 pthread_mutex_lock(&search);
	 //cout << tid << " checking share" << endl;
   s= se->share(alt, option);
   pthread_mutex_unlock(&search);
	 //cout << tid << " shared results" << endl;
	 return s;
 }
 
 //This function is used for the controller class to check the status of the
 //worker.
 template <class T, class SearchScript>
 inline
 WorkerStatus Worker<T, SearchScript>::getStatus() const {
	 	   //pthread_mutex_lock(&search);
	 
   		 return status;
	 	   //pthread_mutex_unlock(&search);
 }
 template <class T, class SearchScript>
 void Worker<T, SearchScript>::initialize() {
	 pthread_mutexattr_t* mat;
	 pthread_mutexattr_init(mat);
	 pthread_mutexattr_settype(mat, PTHREAD_MUTEX_ERRORCHECK_NP);
	 pthread_mutex_init(&search, mat);
	 //pthread_mutex_init(&search, NULL);
	 pthread_attr_init(&tattr);
	 pthread_attr_setscope(&tattr, PTHREAD_SCOPE_SYSTEM);
 int res;
 	 pthread_attr_init(&tattr);
	 pthread_attr_setscope(&tattr, PTHREAD_SCOPE_SYSTEM);
	 pthread_attr_setdetachstate(&tattr, PTHREAD_CREATE_DETACHED);
   res = pthread_create(&tid, &tattr, (Worker<T, SearchScript>::thread_entry),this);
   if(res) cout << res << " result" << endl;
 }
 
 //Constructor for the worker class.
 template <class T, class SearchScript>
 Worker<T, SearchScript>::Worker(Controller<T, SearchScript>* cnt, pthread_barrier_t* st, pthread_cond_t &t, ShareStrategy* o) : _cur(NULL), control(cnt), pause(1), se(new SearchScript()), status(WORKER_WORKING), cond_workers(t), start(st) {
	 initialize();
 }

 template <class T, class SearchScript>
 Worker<T, SearchScript>::Worker(Controller<T, SearchScript>* cnt, pthread_barrier_t* st, pthread_cond_t &t, int c_d, int a_d, ShareStrategy* o) :  _cur(NULL),se(new SearchScript(c_d, a_d)), control(cnt), pause(1), status(WORKER_WORKING), cond_workers(t), start(st) {
	 initialize();
 }
 
 //Constructor for the worker class but taking a space to work on.
 template <class T, class SearchScript>
 Worker<T, SearchScript>::Worker(Controller<T, SearchScript>* cnt, pthread_barrier_t* st, pthread_cond_t &t, T* s, ShareStrategy* o) : _cur(NULL), control(cnt), pause(1), se(new SearchScript()), status(WORKER_WORKING), cond_workers(t), start(st) {
   status = WORKER_WORKING;
	 se->newRoot(s); 
   initialize();
   
 }
 
 template <class T, class SearchScript>
 Worker<T, SearchScript>::Worker(Controller<T, SearchScript>* cnt, pthread_barrier_t* st, pthread_cond_t &t, int c_d, int a_d, T* s, ShareStrategy* o) : _cur(NULL), se(new SearchScript(c_d, a_d)), control(cnt), pause(1), status(WORKER_WORKING), cond_workers(t), start(st) {
   status = WORKER_WORKING;
	 se->newRoot(s); 
   initialize();
	 
 }
 
 template <class T, class SearchScript>
 Worker<T, SearchScript>::~Worker() { //cout << "deconstruction..." << endl;
	 pthread_cancel(tid);
	 delete se;
	 }
 
  template <class T, class SearchScript>
 void 
 Worker<T, SearchScript>::explore() {
   //Start parallel thread here, let it run the loop. will need a private
   //function for this later.
	 int res = pthread_mutex_lock(&search);
	 this->searching = 0;
	 this->pause=0;
	 status = WORKER_WORKING;
	 //cout << " workers: working " << endl;
	 pthread_mutex_unlock(&search);
	 
  //This is the controll variable for the search. keeps searching aslong as pause = 0;
	 //cout << "starting thread" << endl;
	 //if(!tid) {

	 //}
 }

 //This is the workhorse of the worker class, this is what is run in parallel.
 //While possible to just add code from an existing searchengine here it is
 //the need for added controls means we need to divide the search.
 template <class T, class SearchScript>
 void
  Worker<T, SearchScript>::run(void) {
		pthread_barrier_wait(start);
		//checkpause();
		//if(status != WORKER_WORKING) {
		//pause = 0;
		//}
		//Waiting for all workers tobecome active.

		//cout << "all workers started Im now working." << endl;
   while(1) {
		 checkpause();

		 if(status == WORKER_IDLE) {

			 find();
			 //if(se->status() == SEARCH_DONE) status= WORKER_IDLE;
			//The sleep makes sure that the thread wont be too eager to check for work
			//  checkpause();


		 } else {

     //Add mutex controll.
	   pthread_mutex_lock(&search);
		//	 cout << tid << "search step" << endl;
		 T* result = NULL;
		 result = se->searchStep();
			 
		//	cout << tid << "step done" << endl;
		// pthread_mutex_unlock(&search);

			 unsigned int a;
			 //cout << tid << "checking results" << endl;
		 if(result != NULL && result->status(a) == SS_SOLVED) {

			 
			 if(!control->collect(result)) {
			//	 checkpause();
				// pthread_mutex_lock(&search);
				 se->setCurrent(result);
			//	 pthread_mutex_unlock(&search);
			 }
			 result = NULL;
			// tid = ttid;
			 //pause = 1;
			 checkpause();

		 } else {
			 if(se->status() == SEARCH_DONE) {
				 //cout << "search script out of work." << endl;
				 			find();
				 			//The loop will make the worker search more later.
			 }
			 pthread_mutex_unlock(&search);
		 }

	 }
	 //The search state is maintained in the search object and thus we can stop
	 //the search wherever we want.
   }

	 status = WORKER_IDLE;
	 tid = 0;
	 cout << tid << " exiting" << endl;
	 pthread_exit(NULL);
	 //run();
	 return;
 }

 template <class T, class SearchScript>
 void * Worker<T, SearchScript>::thread_entry(void * t) {
	 pthread_setcancelstate(PTHREAD_CANCEL_DEFERRED, NULL);
	 Worker<T, SearchScript>	 * p = (Worker<T, SearchScript>*) t;
	 p->run();
	 return NULL;
 }

 template <class T, class SearchScript>
	 ParallelStatistics Worker<T, SearchScript>::stats() const{
		 return se->statistics();
	 }

 template <class T, class SearchScript>
	 inline void Worker<T, SearchScript>::checkpause() {

		int res = pthread_mutex_lock(&search);
		 //cout << "mutex results: " << res <<  " EINVAL = " << (res == EINVAL) << endl;
		// pthread_testcancel();
     if(pause) {	
			 //WorkerStatus t = status;
			 //cout << "pausing" << endl;	
			 //status = WORKER_IDLE;
			 //pthread_barrier_wait(start);
			 if(pause) pthread_cond_wait(&(control->cond_workers), &search);
			 //
			 //cout << "pause result: " << res << endl;

		 }
		 //pause = 0;
		 pthread_mutex_unlock(&search);

	 }

 template <class T, class SearchScript>
	 inline void Worker<T, SearchScript>::find() {
 							checkpause();
				   //   cout << tid << "looking for more work. 2" << endl;
		          unsigned int alt;
		          void* option;
							searching = 1;
				 			T* s = control->find(alt, option);
				      searching = 0;
				 			//If we find something then we set the search root to it.
			 				if(s != NULL) {
								pthread_mutex_lock(&search);
								se->newRoot(s, alt, option);
								delete s;
								status = WORKER_WORKING;
								pthread_mutex_unlock(&search);
							} else {
								status = WORKER_IDLE;
								//sleep(1);
								//cout << tid << " no more work." << endl;
							}
	 }
